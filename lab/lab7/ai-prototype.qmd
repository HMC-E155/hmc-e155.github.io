---
title: "Lab 7 AI Prototype"
subtitle: "Private IP"
---

## Learning Goals

The goal of this prototype is to experiment with using AI as a coding assistant to generate HDL, without leaking private IP. By the end of this experiment you should be able to:

- Prompt an LLM to generate code based on a specifications document it has not seen
- Compare this to the quality of code generated when the LLM has access to the full document

## Prototype

Fire up your favorite LLM. ChatGPT is a good place to start, but you may consider using other LLMs as well like Claude or Gemini. Upload the [FIPS-197 AES Specification](/assets/doc/NIST.FIPS.197-upd1.pdf) specifications and enter the prompt below (if your LLM does not support PDF uploading, use [this image](./images/ai-prototype-key-expansion.png) instead).

::: {.callout-note title="LLM Prompt"}
Write SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.
:::

Create a new Radiant project, type the code generated by the LLM in and analyze the results. 

Now start a new conversation (without the history of the old one) and prompt the LLM to generate the same module but *without* access to the whole FIPS-197 AES Specifications. An example prompt is below, but feel free to try your own prompt as well. Make sure not to mention AES in your prompt because the LLM was trained on data including AES, and we want to simulate a new specification it has no prior knowledge about!

::: {.callout-note title="LLM Prompt"}
Write SystemVerilog HDL to implement the following logic:
```
i = 0
while i < Nk do
    w[i] <- key[4*i..4*i+3]
    i <- i+1
end while
while i <= 4 * Nr + 3 do
    temp <- w[i-1]
    if i mod Nk = 0 then
        temp <- module1(module2(temp)) (+) Rcon[i/Nk]
    else if Nk > 6 and i mod Nk = 4 then
        temp <- module1(temp)
    end if
    w[i] <- w[i-Nk] (+) temp
    i <- i + 1
end while
return w
```
Assume module1 and module2 are existing modules that can be instantiated. (+) refers to XOR. Unwrap the loop in the provided pseudo code so it uses the previous iterations output to generate the new iteration.

Do not use any existing knowledge of the AES specifications in your answer.
:::

Create a new Radiant project, type the code generated by the LLM in and analyze the results, comparing it to the code generated by the first prompt.

## Reflect

Write up a few paragraphs reflecting on your experience using the LLM to help you code. Feel free to make full use of screenshots, code snippets, and other media as you write your reflections.

Here are a few ideas of on what you might comment on:

- How would you rate the quality of the output and why?
- What SystemVerilog constructs/syntax did the LLM generated that were new to you?
- Did the LLM-generated code synthesize the first time around? If not, what were the issues?
- What error or warning messages did Radiant output?
- What would you do differently the next time you use an LLM in your workflow?

