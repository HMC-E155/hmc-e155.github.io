[
  {
    "objectID": "syllabus/index.html",
    "href": "syllabus/index.html",
    "title": "Course Syllabus",
    "section": "",
    "text": "Item\nInformation\n\n\n\n\nInstructors:\nProf. Josh Brake\n\n\nLab Assistant(s):\nTBD\n\n\nWeb page:\nhttps://hmc-e155.github.io/\n\n\nLab Checkoff Sheet:\nSheet Link\n\n\nEmail list:\neng-155 [at] g.hmc.edu\n\n\nDiscord Server:\nSee email for invite\n\n\n\nBe sure to join the class Discord and check it regularly as it will be the main source of course-related communication for this semester.\n\n\n\n\n\n\nName\nInfo\n\n\n\n\nLecture\nTR 1:15 - 2:30 pm\n\n\nLab Checkoff\nTR afternoons by signup in the Digital Lab (PA B183)\n\n\nOffice Hours\nProf. Brake: Monday 1:10-2:00 p (Digital Lab)\n\n\n\nYou will be working on labs on your own time and it is not required that you attend the entire scheduled lab period. Instead, sign up for a time to get your lab checked off. Please sign up for a time during your lab section. If you are unable to find a spot that works for you, see if you can swap with one of your classmates. If you are still having trouble finding a time that works for you, reach out and let me know.\n“Office hours” is code for “come hang out.” You are encouraged to attend office hours to ask questions, get help with your labs, talk about careers and graduate school, or chat about something on your mind (whether it is related to this class, academics, or anything else). In addition to things related to Engineering, embedded systems, digital electronics, and microcontrollers, a short (but not comprehensive!) list of things I enjoy talking about are sports (MLB: NY Mets; NFL: Tennessee Titans), running/biking/hiking, life design, time management, or books/essays I’m reading. I am available more often than not, so try dropping me a line via Slack or email if you are having a problem with your lab or want to set up a time. You may also contact the lab assistant(s) for questions when I am not available.\n\n\n\nPlease note that I do not always respond immediately to messages. In particular I typically do not check email or Discord between 6:00 pm and 6:00 am on weeknights, and I typically do not check these at all on weekends.\nThat said,\n\nMessages sent on a weekday (Monday-Friday) before 4:00 pm PT will get a response the same day.\nMessages sent after 4:00 pm PT Monday-Thursday will get a response the next day.\nMessages sent after 4:00 pm PT on Fridays or on the weekend will get a response the following Monday.\n\n\n\n\nThe overarching goal of this course is to take you from a basic familiarity and knowledge of digital design with field gate programmable arrays (FPGAs) and microcontrollers programming and expand your capabilities to design, build, and test embedded systems. In particular, by the end of this course you should be able to:\n\nDesign and implement combinational and sequential circuits on an FPGA.\nUse an ARM-based microcontroller to interface with the real world via sensors and actuators.\nBuild an embedded system project of your own design from the ground up.\nSelect appropriate embedded hardware for a given task and use the appropriate hardware for a given problem.\nEffectively and efficiently debug electrical systems with measurement tools such as an oscilloscope and logic analyzer.\nRead and understand complicated datasheets at a level that enables you to incorporate them into your designs.\nClearly communicate technical results in a professional manner through oral presentations and written reports.\n\nIn broad strokes, MicroPs can be divided into two halves. The first half of the class focuses on giving you fundamental embedded systems concepts in lecture which you learn by experience through seven, hands-on labs. These labs are designed to be loosely structured design projects – you will be given information about the required specifications and some pointers on how to get started, but much of the development process is left open to you. The second half of the class is mainly focused on the project. The project gives you the opportunity to demonstrate independent and creative mastery of embedded system design in teams of two. The specific project task is very open-ended; the only requirement is that the project does something fun or useful and that it meaningfully uses both the FPGA and MCU. In addition to having a series of design review checkpoints, you will give a mid-project presentation to the class and a final presentation of your project when finished. The content of the lectures in the second half of the class focuses on exposing you to more advanced embedded systems concepts and exploring a range of various types of external hardware that may be useful to use in your project.\n\n\n\nThe ultimate goal for this course is to help you to master the material and become skilled embedded systems developers who understand how to build a system from a set of requirements and specifications and to verify that the system meets those specifications.\nHere are a few of the main pedagogical concepts that you can expect to see in this course.\n\nTransparent Teaching – you should not have to guess what you are supposed to get out of a given activity or assignment in this class. I strive to be as transparent about why we are doing what we are doing. This is most clearly articulated through explicit learning goals that accompany each lecture, lab, or project. If the purpose of anything we do in this class is ever unclear, please ask me and I will be happy to clarify it.\nPsychological Safety – A psychologically safe environment is one where each person feels able to share their questions, concerns, or mistakes without feeling embarrassed or looked down upon by others. Building a psychologically safe classroom is a joint venture which I expect each of you to join with me in pursuing.\nA Growth Mindset – growth can only happen when you reach the end of what you already know. Each of you coming into this class will have different levels of experience with the types of skills that are useful in this class like working with embedded systems, programming, debugging, design, etc. My goal as an instructor is to take you from wherever you are and bring you as far along in your journey as possible. To do that, I encourage each of you to ask questions and push yourself to the edge of your knowledge. It can be frustrating or embarrassing to have questions that you feel you should already have the answer to. You should take these moments as opportunities to ask questions and fill the gaps in your knowledge. In the end, having a growth mindset is strongly linked with deep curiosity about what you are learning and a realization that while being honest about the limits of your understanding might be challenging, embracing that discomfort allows you to grow and improve quickly.\nFrequent, Low-stakes Testing – Research has shown that having frequent opportunities to assess your knowledge is a powerful way to learn and correct any misconceptions. One way that this will take place is through regular in-class quizzes and activities.\nInterleaving – The scheduling of the material is arranged in such a way that you will return to many similar concepts throughout the semester with some time in between. The goal of this is to have you return to familiar concepts after some time away so that you reinforce the material after working on something else. This has been shown to improve long-term retention of the material (see Small Teaching by James Lang if you are curious in learning more).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek #\nMonday Date\nTuesday’s Class\nThursday’s Class\nDue\n\n\n\n\n1\n8/26\nIntro & Analog Behavior of Digital Systems\nCombinational and Sequential Logic\n(Lab Demos)\n\n\n2\n9/2\nVerilog Coding\nSynchronous Design\nLab 1 - Development Board Assembly\n\n\n3\n9/9\nFPGA Documentation\nArchitecture & Assembly Review\nLab 2 - Muxed 7-Segment Display\n\n\n4\n9/16\nAssembly Programming\nC Programming on an MCU\nLab 3 - Keypad\n\n\n5\n9/23\nClock Configuration\nTimers\nLab 4 - ARM Assembly Sort\n\n\n6\n9/30\nSerial Interfaces Overview & SPI\nUART and the IoT\nLab 5 - Digital Audio\n\n\n7\n10/7\nPCB Design\nAdvanced Encryption Standard (AES)\nLab 6 - SPI & The Internet of Things\n\n\n8\n10/14\nHappy Fall Break! No class\nProject Kickoff\n\n\n\n9\n10/21\nGraphics and Displays\nMotors and Speakers\nLab 7 - AES & Project Proposal\n\n\n10\n10/28\nInterrupts Pt. 1\nInterrupts Pt. 2\nProposal Debriefs\n\n\n11\n11/4\nPresentations\nPresentations\n\n\n\n12\n11/11\nThe Fast Fourier Transform (FFT)\nProject Status Report and Demo\nProject Status Reports & Demo\n\n\n13\n11/18\nEmerging Topics in Embedded Systems\nHappy Thanksgiving! No class\n\n\n\n14\n11/25\nIntroduction to Real Time Operating Systems\nDirect Memory Access\n\n\n\n15\n12/2\nTBD\nInterview Questions & Life Beyond Mudd\nProject Checkoffs, Report, Demo Day\n\n\n\n\n\n\nI assume you have a solid grasp of digital design at the level of E85; review Digital Design and Computer Architecture, ARM Edition (link) if you feel rusty on a topic. We will not be closely following a textbook, but you may find The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors by Joseph Yiu to be a helpful, comprehensive reference for the microcontroller. An electronic version of the book is available through the library (link).\n\n\n\nThe grading for this class is based on a variation of specifications-grading and may be a bit different than what you have seen in other classes. If you have questions or concerns, please contact the instructors for clarification.\nThe grade you earn in the class will be determined based the number of deliverables you successfully complete and the level of polish to which you complete them across three different bundles:\n\nLabs\nProject\nIn-class participation.\n\nEach assignment will contain a list of specifications (or specs) for two levels of completeness: proficiency and excellence. The list of specifications are designed to be aligned with the learning goals for the assignment. The proficiency specifications will indicate the level of completeness that demonstrates that you have achieved a level of comfort with the material in the assignment such that you would be able to implement the learning outcomes in a different setting. Excellence specs are above and beyond proficiency specs. Meeting the excellence specs for an assignment indicates that you have not only achieved the basic level of expected knowledge of the material, but have truly understood and are able to apply the techniques with deftness.\nThe table below describes the levels that you need to meet in each bundle (i.e., column) in order to earn the grade in the respective row. To earn the grade in a given row, you must meet all the criteria in that row. In other words, to get a B, you must complete the following:\n\nAll 7 labs to the proficiency specs and 4 of those labs must meet the excellence specs.\nAll 5 project elements must meet proficiency specs and 3 of them must meet the excellence specs.\n\n\n\n\nGrade\nLabs\nProject\n\n\n\n\nF\nP \\(\\lt\\) 5\nP \\(\\lt\\) 4\n\n\nD\nP \\(\\geq\\) 5, E \\(\\geq\\) 1\nP \\(\\geq\\) 4\n\n\nC\nP \\(\\geq\\) 6, E \\(\\geq\\) 2\nP \\(\\geq\\) 4, E \\(\\geq\\) 2\n\n\nB\nP = 7, E \\(\\geq\\) 5\nP = 5, E \\(\\geq\\) 3\n\n\nA\nP = 7, E = 7\nP = 5, E = 5\n\n\n\nPerformance on the labs and project is weighted equally. +/- grades will be assigned for situations in which your performance falls between the conditions for each row.\nIn-class participation is also an important part of practicing and learning this material and can help to boost your grade in the class by up to half a letter grade (e.g., from a B- to a B or B+ to an A-). As one example, if you meet the requirements for an A in the labs bundle but the requirements for a B in the project bundle, you can expect to earn either a B+ or A-. In these situations, your in-class participation is a contributing factor to split the difference between the - of the higher tier and the + of the lower tier.\n\n\n\n\n\nAI tools like ChatGPT are an emerging and active area of research. Following the public release of ChatGPT in late 2022, large language models (LLMs) hit the mainstream and have been the subject of robust conversations about how educators and students should approach these tools. AI tools, whether in the form of an LLM or something else, are likely to have an impact on your career and work as an engineer. In this class, we will be approaching AI tools with a posture of cautious engagement. The guiding principle for the use of AI tools is that these tools must be used in the spirit of the assignment.\nTo frame the discussion about AI in this class, here are three general ways that educators are approaching AI use in their classes1:\n\nBan\nEmbrace\nCritical exploration\n\nEach of these approaches has its merits in specific circumstances. The key is to ensure that the use of the tool is aligned with the overarching learning outcomes of the course or assignment. There are some instances where AI use is not aligned with learning. For example, it is important to understand the fundamentals of how to write accurate code in a Hardware Description Language (HDL) such as the SystemVerilog language we will learn in this class. Relying on a Large Language Model (LLM) like ChatGPT to write the code for you will supplant rather than support your ability to understand the important concepts for designing digital systems. Not to mention that ChatGPT, based on my experience, writes really bad HDL!2\nThere are other instances where an embrace of AI is worth considering. Maybe after building your own general understanding of SystemVerilog you want to experiment with an LLM to see if it can generate a template design that you can slightly modify for a new design. In this situation, the LLM is acting more like an advanced auto-complete tool. The key is that you possess the expertise to be able to understand and analyze whether the output is correct. In the spirit of full embrace, you may try to have an LLM write your code for you, comment your code, or write descriptions of what the code is doing. Embracing the AI tool full on will help you to quickly generate text, but the quality of the output may end up being incorrect or of poor quality. User beware.\nThe third approach is in the middle of the previous two, approaching AI tools like LLMs with a cautious optimism and an eye towards reflection. Here, a user embraces the tool and engages their curiosity to prototype new ways in which the tool might be useful but is continually asking questions and reflecting on the approach and how the design of the tools influences the applications for which they are well suited. By diving deeply into how these tools work, analyzing their areas of strength and weakness, and experimenting with them with an attitude of critical curiosity, one can learn how these tools might be a valuable tool in the toolkit and other situations when they are best avoided. This approach also opens up space to ask questions about the array of ethical issues that must be discussed, including but not limited to: data privacy concerns, the environmental impacts of training these systems, alignment of AI tools with human values, bias, and the potentially dangerous ways in which these tools can be used.\nMy own approach to AI use is that when we choose to use it, we should be using it as a ladder and not a crutch. If and when we choose to use AI tools we should use it to extend our abilities but not in a way that might create unhealthy dependencies on it (e.g., not learning foundational programming concepts because ChatGPT can write the code for you). If you use AI tools in an unhealthy way, you are likely to be doing yourself more harm than good. In this vein, it is similar to other forms of academic dishonesty that supplant the learning intended as part of a given assignment or assessment.\nIf you have any questions or are curious about exploring AI tools in this class, please reach out and ask. Our default posture will be the third approach of reflective engagement. In most instances this means that we will avoid the use of these tools since they will often be in direct opposition to the goals of learning the fundamental concepts. If you would like to use these tools in an assignment, please reach out to me and I would be happy to talk with you about it. In general you will be required to submit a quick justification of\n\nWhat you would like to use the tool for.\nWhy you think the use of AI is aligned with and not opposed to the learning goals of the assignment.\nA short reflection, submitted with the assignment, on your experience using AI on the assignment and what you learned.\n\n\n\n\n\nWhile there is not a textbook to purchase, you will need to buy a lab kit. The fee is $75 in Claremont Cash, and should be paid by filling out the Google Form (link) which authorizes Sydney Torrey in the Engineering office to charge your Claremont Cash account. Once you have paid for your kit via the form, see Sam Abdelmuati in the stockroom to pick up your kit. If you cook your board this semester, you can buy and rebuild a replacement, but ask the instructor for help troubleshooting first. You’ll also check out a large breadboard from the stockroom, and will need to return it at the end of the semester.\nThe kit fee can be waived in cases of financial hardship. To request a waiver fill out the form here (link). Course instructors will not know about waiver requests.\n\n\n\nThe Digital Lab (Parson B183) is available for you to use when working on your labs. The current door code will be shared on Slack when it is available. There are Windows PCs available with SEGGER Embedded Studio for ARM and Lattice Radiant installed along with the drivers required to program your board. The lab also has the electronics assembly equipment needed to solder, oscilloscopes and power supplies at the lab stations, and a lab cabinet with various resistors and some of the parts like wires, seven-segment LEDs, and transistors you will need for some of your labs. You are welcome to use these while working on your lab, but please make sure to return the components to the lab cabinet when you are done.\nIn addition, the software we will be using for programming the MCU (SEGGER Embedded Studio for ARM) and FPGA (Lattice Radiant) are free and supported on a variety of platforms if you wish to download them on your personal computer. SEGGER Embedded Studio is supported on Windows, MacOS, and Linux and Lattice Radiant is supported on Windows and Linux. If you are running MacOS, you can download and virtualize Windows using VMWare Fusion Player under a Personal Use License for free. More details and download links can be found here (link).\n\n\n\nStudents in this class are expected to follow the HMC honor code. An honor code policy appears below and prescribes behavior that is considered honorable, so read those maxims and follow them closely. Any honor code violations will be handled through JB.\n\n\n\n\nAll students enrolled in this course are bound by the HMC Honor Code. More information on the HMC Honor Code can be found in the HMC Student Handbook.\nIt is your responsibility to determine whether your actions adhere to the HMC Honor Code. If this document does not clarify the legitimacy of a particular action, you should contact the course instructor and request clarification.\nWork you submit for individual assignments should be your own, and you should complete all assignments based on your own understanding of the underlying material. If you work with, or receive help from, another individual on an assignment, provide a written acknowledgement in complete sentences that includes the person’s name and the nature of the help.\nThis document is not meant to be an exhaustive list of every possible Honor Code violation. Infractions not explicitly mentioned here may still violate the Honor Code.\nBoundaries of Collaboration Verbal collaboration with other students on individual assignments is encouraged AFTER you have given serious thought to each component yourself. However, all submitted written work should be written by yourself individually, and not a collaborative effort or copied from a common source (e.g., a chalkboard). It is NOT acceptable to work on labs in lockstep with another classmate.\nUse of Computer Software The use of graphing calculators and computer software to aid in course work is acceptable, as long as it does not substitute for an understanding of the course material.\nUse of Web Resources The use of Internet resources to aid in course work is acceptable, as long it does not substitute for an understanding of the course material. Plagiarism and direct copying from online (or any other) sources is strictly prohibited.\nUse of Your Own Work from Previous Semesters If you have previously attempted this course, you may resubmit your work from previous semesters as this semester’s coursework, as long as you understand the underlying material.\nUse of Other Course Resources from Previous Semesters You may not reference assignments (labs, problem sets, activities) of this course from previous semesters.\nRetention of Course Resources Assignments and exams from this course may not be committed to dorm repositories or otherwise used to help future students.\n\n\n\n\nWe do difficult work in this class and everyone should feel comfortable engaging with the material. We explicitly want you to feel safe doing this work, so it is worth stating that the instructors are committed to making the class a safe space for everyone regardless of race, gender, ethnicity, sexual orientation, religion, and academic history. If you feel that you are experiencing a hostile environment, speak to an instructor immediately.\n\n\n\nHMC is committed to providing an inclusive learning environment and support for all students. Students with a disability (including mental health, chronic or temporary medical conditions) who may need some accommodation in order to fully participate in this class are encouraged to contact Educational Accessibility Services at ability@g.hmc.edu to request accommodations. Students from the other Claremont Colleges should contact their home college’s disability resources officer."
  },
  {
    "objectID": "syllabus/index.html#contact-information",
    "href": "syllabus/index.html#contact-information",
    "title": "Course Syllabus",
    "section": "",
    "text": "Item\nInformation\n\n\n\n\nInstructors:\nProf. Josh Brake\n\n\nLab Assistant(s):\nTBD\n\n\nWeb page:\nhttps://hmc-e155.github.io/\n\n\nLab Checkoff Sheet:\nSheet Link\n\n\nEmail list:\neng-155 [at] g.hmc.edu\n\n\nDiscord Server:\nSee email for invite\n\n\n\nBe sure to join the class Discord and check it regularly as it will be the main source of course-related communication for this semester."
  },
  {
    "objectID": "syllabus/index.html#course-meeting-schedule",
    "href": "syllabus/index.html#course-meeting-schedule",
    "title": "Course Syllabus",
    "section": "",
    "text": "Name\nInfo\n\n\n\n\nLecture\nTR 1:15 - 2:30 pm\n\n\nLab Checkoff\nTR afternoons by signup in the Digital Lab (PA B183)\n\n\nOffice Hours\nProf. Brake: Monday 1:10-2:00 p (Digital Lab)\n\n\n\nYou will be working on labs on your own time and it is not required that you attend the entire scheduled lab period. Instead, sign up for a time to get your lab checked off. Please sign up for a time during your lab section. If you are unable to find a spot that works for you, see if you can swap with one of your classmates. If you are still having trouble finding a time that works for you, reach out and let me know.\n“Office hours” is code for “come hang out.” You are encouraged to attend office hours to ask questions, get help with your labs, talk about careers and graduate school, or chat about something on your mind (whether it is related to this class, academics, or anything else). In addition to things related to Engineering, embedded systems, digital electronics, and microcontrollers, a short (but not comprehensive!) list of things I enjoy talking about are sports (MLB: NY Mets; NFL: Tennessee Titans), running/biking/hiking, life design, time management, or books/essays I’m reading. I am available more often than not, so try dropping me a line via Slack or email if you are having a problem with your lab or want to set up a time. You may also contact the lab assistant(s) for questions when I am not available."
  },
  {
    "objectID": "syllabus/index.html#communication-policy",
    "href": "syllabus/index.html#communication-policy",
    "title": "Course Syllabus",
    "section": "",
    "text": "Please note that I do not always respond immediately to messages. In particular I typically do not check email or Discord between 6:00 pm and 6:00 am on weeknights, and I typically do not check these at all on weekends.\nThat said,\n\nMessages sent on a weekday (Monday-Friday) before 4:00 pm PT will get a response the same day.\nMessages sent after 4:00 pm PT Monday-Thursday will get a response the next day.\nMessages sent after 4:00 pm PT on Fridays or on the weekend will get a response the following Monday."
  },
  {
    "objectID": "syllabus/index.html#course-learning-objectives",
    "href": "syllabus/index.html#course-learning-objectives",
    "title": "Course Syllabus",
    "section": "",
    "text": "The overarching goal of this course is to take you from a basic familiarity and knowledge of digital design with field gate programmable arrays (FPGAs) and microcontrollers programming and expand your capabilities to design, build, and test embedded systems. In particular, by the end of this course you should be able to:\n\nDesign and implement combinational and sequential circuits on an FPGA.\nUse an ARM-based microcontroller to interface with the real world via sensors and actuators.\nBuild an embedded system project of your own design from the ground up.\nSelect appropriate embedded hardware for a given task and use the appropriate hardware for a given problem.\nEffectively and efficiently debug electrical systems with measurement tools such as an oscilloscope and logic analyzer.\nRead and understand complicated datasheets at a level that enables you to incorporate them into your designs.\nClearly communicate technical results in a professional manner through oral presentations and written reports.\n\nIn broad strokes, MicroPs can be divided into two halves. The first half of the class focuses on giving you fundamental embedded systems concepts in lecture which you learn by experience through seven, hands-on labs. These labs are designed to be loosely structured design projects – you will be given information about the required specifications and some pointers on how to get started, but much of the development process is left open to you. The second half of the class is mainly focused on the project. The project gives you the opportunity to demonstrate independent and creative mastery of embedded system design in teams of two. The specific project task is very open-ended; the only requirement is that the project does something fun or useful and that it meaningfully uses both the FPGA and MCU. In addition to having a series of design review checkpoints, you will give a mid-project presentation to the class and a final presentation of your project when finished. The content of the lectures in the second half of the class focuses on exposing you to more advanced embedded systems concepts and exploring a range of various types of external hardware that may be useful to use in your project."
  },
  {
    "objectID": "syllabus/index.html#teaching-philosophy",
    "href": "syllabus/index.html#teaching-philosophy",
    "title": "Course Syllabus",
    "section": "",
    "text": "The ultimate goal for this course is to help you to master the material and become skilled embedded systems developers who understand how to build a system from a set of requirements and specifications and to verify that the system meets those specifications.\nHere are a few of the main pedagogical concepts that you can expect to see in this course.\n\nTransparent Teaching – you should not have to guess what you are supposed to get out of a given activity or assignment in this class. I strive to be as transparent about why we are doing what we are doing. This is most clearly articulated through explicit learning goals that accompany each lecture, lab, or project. If the purpose of anything we do in this class is ever unclear, please ask me and I will be happy to clarify it.\nPsychological Safety – A psychologically safe environment is one where each person feels able to share their questions, concerns, or mistakes without feeling embarrassed or looked down upon by others. Building a psychologically safe classroom is a joint venture which I expect each of you to join with me in pursuing.\nA Growth Mindset – growth can only happen when you reach the end of what you already know. Each of you coming into this class will have different levels of experience with the types of skills that are useful in this class like working with embedded systems, programming, debugging, design, etc. My goal as an instructor is to take you from wherever you are and bring you as far along in your journey as possible. To do that, I encourage each of you to ask questions and push yourself to the edge of your knowledge. It can be frustrating or embarrassing to have questions that you feel you should already have the answer to. You should take these moments as opportunities to ask questions and fill the gaps in your knowledge. In the end, having a growth mindset is strongly linked with deep curiosity about what you are learning and a realization that while being honest about the limits of your understanding might be challenging, embracing that discomfort allows you to grow and improve quickly.\nFrequent, Low-stakes Testing – Research has shown that having frequent opportunities to assess your knowledge is a powerful way to learn and correct any misconceptions. One way that this will take place is through regular in-class quizzes and activities.\nInterleaving – The scheduling of the material is arranged in such a way that you will return to many similar concepts throughout the semester with some time in between. The goal of this is to have you return to familiar concepts after some time away so that you reinforce the material after working on something else. This has been shown to improve long-term retention of the material (see Small Teaching by James Lang if you are curious in learning more)."
  },
  {
    "objectID": "syllabus/index.html#schedule",
    "href": "syllabus/index.html#schedule",
    "title": "Course Syllabus",
    "section": "",
    "text": "Week #\nMonday Date\nTuesday’s Class\nThursday’s Class\nDue\n\n\n\n\n1\n8/26\nIntro & Analog Behavior of Digital Systems\nCombinational and Sequential Logic\n(Lab Demos)\n\n\n2\n9/2\nVerilog Coding\nSynchronous Design\nLab 1 - Development Board Assembly\n\n\n3\n9/9\nFPGA Documentation\nArchitecture & Assembly Review\nLab 2 - Muxed 7-Segment Display\n\n\n4\n9/16\nAssembly Programming\nC Programming on an MCU\nLab 3 - Keypad\n\n\n5\n9/23\nClock Configuration\nTimers\nLab 4 - ARM Assembly Sort\n\n\n6\n9/30\nSerial Interfaces Overview & SPI\nUART and the IoT\nLab 5 - Digital Audio\n\n\n7\n10/7\nPCB Design\nAdvanced Encryption Standard (AES)\nLab 6 - SPI & The Internet of Things\n\n\n8\n10/14\nHappy Fall Break! No class\nProject Kickoff\n\n\n\n9\n10/21\nGraphics and Displays\nMotors and Speakers\nLab 7 - AES & Project Proposal\n\n\n10\n10/28\nInterrupts Pt. 1\nInterrupts Pt. 2\nProposal Debriefs\n\n\n11\n11/4\nPresentations\nPresentations\n\n\n\n12\n11/11\nThe Fast Fourier Transform (FFT)\nProject Status Report and Demo\nProject Status Reports & Demo\n\n\n13\n11/18\nEmerging Topics in Embedded Systems\nHappy Thanksgiving! No class\n\n\n\n14\n11/25\nIntroduction to Real Time Operating Systems\nDirect Memory Access\n\n\n\n15\n12/2\nTBD\nInterview Questions & Life Beyond Mudd\nProject Checkoffs, Report, Demo Day"
  },
  {
    "objectID": "syllabus/index.html#recommended-texts",
    "href": "syllabus/index.html#recommended-texts",
    "title": "Course Syllabus",
    "section": "",
    "text": "I assume you have a solid grasp of digital design at the level of E85; review Digital Design and Computer Architecture, ARM Edition (link) if you feel rusty on a topic. We will not be closely following a textbook, but you may find The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors by Joseph Yiu to be a helpful, comprehensive reference for the microcontroller. An electronic version of the book is available through the library (link)."
  },
  {
    "objectID": "syllabus/index.html#grading",
    "href": "syllabus/index.html#grading",
    "title": "Course Syllabus",
    "section": "",
    "text": "The grading for this class is based on a variation of specifications-grading and may be a bit different than what you have seen in other classes. If you have questions or concerns, please contact the instructors for clarification.\nThe grade you earn in the class will be determined based the number of deliverables you successfully complete and the level of polish to which you complete them across three different bundles:\n\nLabs\nProject\nIn-class participation.\n\nEach assignment will contain a list of specifications (or specs) for two levels of completeness: proficiency and excellence. The list of specifications are designed to be aligned with the learning goals for the assignment. The proficiency specifications will indicate the level of completeness that demonstrates that you have achieved a level of comfort with the material in the assignment such that you would be able to implement the learning outcomes in a different setting. Excellence specs are above and beyond proficiency specs. Meeting the excellence specs for an assignment indicates that you have not only achieved the basic level of expected knowledge of the material, but have truly understood and are able to apply the techniques with deftness.\nThe table below describes the levels that you need to meet in each bundle (i.e., column) in order to earn the grade in the respective row. To earn the grade in a given row, you must meet all the criteria in that row. In other words, to get a B, you must complete the following:\n\nAll 7 labs to the proficiency specs and 4 of those labs must meet the excellence specs.\nAll 5 project elements must meet proficiency specs and 3 of them must meet the excellence specs.\n\n\n\n\nGrade\nLabs\nProject\n\n\n\n\nF\nP \\(\\lt\\) 5\nP \\(\\lt\\) 4\n\n\nD\nP \\(\\geq\\) 5, E \\(\\geq\\) 1\nP \\(\\geq\\) 4\n\n\nC\nP \\(\\geq\\) 6, E \\(\\geq\\) 2\nP \\(\\geq\\) 4, E \\(\\geq\\) 2\n\n\nB\nP = 7, E \\(\\geq\\) 5\nP = 5, E \\(\\geq\\) 3\n\n\nA\nP = 7, E = 7\nP = 5, E = 5\n\n\n\nPerformance on the labs and project is weighted equally. +/- grades will be assigned for situations in which your performance falls between the conditions for each row.\nIn-class participation is also an important part of practicing and learning this material and can help to boost your grade in the class by up to half a letter grade (e.g., from a B- to a B or B+ to an A-). As one example, if you meet the requirements for an A in the labs bundle but the requirements for a B in the project bundle, you can expect to earn either a B+ or A-. In these situations, your in-class participation is a contributing factor to split the difference between the - of the higher tier and the + of the lower tier."
  },
  {
    "objectID": "syllabus/index.html#course-policies",
    "href": "syllabus/index.html#course-policies",
    "title": "Course Syllabus",
    "section": "",
    "text": "AI tools like ChatGPT are an emerging and active area of research. Following the public release of ChatGPT in late 2022, large language models (LLMs) hit the mainstream and have been the subject of robust conversations about how educators and students should approach these tools. AI tools, whether in the form of an LLM or something else, are likely to have an impact on your career and work as an engineer. In this class, we will be approaching AI tools with a posture of cautious engagement. The guiding principle for the use of AI tools is that these tools must be used in the spirit of the assignment.\nTo frame the discussion about AI in this class, here are three general ways that educators are approaching AI use in their classes1:\n\nBan\nEmbrace\nCritical exploration\n\nEach of these approaches has its merits in specific circumstances. The key is to ensure that the use of the tool is aligned with the overarching learning outcomes of the course or assignment. There are some instances where AI use is not aligned with learning. For example, it is important to understand the fundamentals of how to write accurate code in a Hardware Description Language (HDL) such as the SystemVerilog language we will learn in this class. Relying on a Large Language Model (LLM) like ChatGPT to write the code for you will supplant rather than support your ability to understand the important concepts for designing digital systems. Not to mention that ChatGPT, based on my experience, writes really bad HDL!2\nThere are other instances where an embrace of AI is worth considering. Maybe after building your own general understanding of SystemVerilog you want to experiment with an LLM to see if it can generate a template design that you can slightly modify for a new design. In this situation, the LLM is acting more like an advanced auto-complete tool. The key is that you possess the expertise to be able to understand and analyze whether the output is correct. In the spirit of full embrace, you may try to have an LLM write your code for you, comment your code, or write descriptions of what the code is doing. Embracing the AI tool full on will help you to quickly generate text, but the quality of the output may end up being incorrect or of poor quality. User beware.\nThe third approach is in the middle of the previous two, approaching AI tools like LLMs with a cautious optimism and an eye towards reflection. Here, a user embraces the tool and engages their curiosity to prototype new ways in which the tool might be useful but is continually asking questions and reflecting on the approach and how the design of the tools influences the applications for which they are well suited. By diving deeply into how these tools work, analyzing their areas of strength and weakness, and experimenting with them with an attitude of critical curiosity, one can learn how these tools might be a valuable tool in the toolkit and other situations when they are best avoided. This approach also opens up space to ask questions about the array of ethical issues that must be discussed, including but not limited to: data privacy concerns, the environmental impacts of training these systems, alignment of AI tools with human values, bias, and the potentially dangerous ways in which these tools can be used.\nMy own approach to AI use is that when we choose to use it, we should be using it as a ladder and not a crutch. If and when we choose to use AI tools we should use it to extend our abilities but not in a way that might create unhealthy dependencies on it (e.g., not learning foundational programming concepts because ChatGPT can write the code for you). If you use AI tools in an unhealthy way, you are likely to be doing yourself more harm than good. In this vein, it is similar to other forms of academic dishonesty that supplant the learning intended as part of a given assignment or assessment.\nIf you have any questions or are curious about exploring AI tools in this class, please reach out and ask. Our default posture will be the third approach of reflective engagement. In most instances this means that we will avoid the use of these tools since they will often be in direct opposition to the goals of learning the fundamental concepts. If you would like to use these tools in an assignment, please reach out to me and I would be happy to talk with you about it. In general you will be required to submit a quick justification of\n\nWhat you would like to use the tool for.\nWhy you think the use of AI is aligned with and not opposed to the learning goals of the assignment.\nA short reflection, submitted with the assignment, on your experience using AI on the assignment and what you learned."
  },
  {
    "objectID": "syllabus/index.html#lab-kit",
    "href": "syllabus/index.html#lab-kit",
    "title": "Course Syllabus",
    "section": "",
    "text": "While there is not a textbook to purchase, you will need to buy a lab kit. The fee is $75 in Claremont Cash, and should be paid by filling out the Google Form (link) which authorizes Sydney Torrey in the Engineering office to charge your Claremont Cash account. Once you have paid for your kit via the form, see Sam Abdelmuati in the stockroom to pick up your kit. If you cook your board this semester, you can buy and rebuild a replacement, but ask the instructor for help troubleshooting first. You’ll also check out a large breadboard from the stockroom, and will need to return it at the end of the semester.\nThe kit fee can be waived in cases of financial hardship. To request a waiver fill out the form here (link). Course instructors will not know about waiver requests."
  },
  {
    "objectID": "syllabus/index.html#lab-access",
    "href": "syllabus/index.html#lab-access",
    "title": "Course Syllabus",
    "section": "",
    "text": "The Digital Lab (Parson B183) is available for you to use when working on your labs. The current door code will be shared on Slack when it is available. There are Windows PCs available with SEGGER Embedded Studio for ARM and Lattice Radiant installed along with the drivers required to program your board. The lab also has the electronics assembly equipment needed to solder, oscilloscopes and power supplies at the lab stations, and a lab cabinet with various resistors and some of the parts like wires, seven-segment LEDs, and transistors you will need for some of your labs. You are welcome to use these while working on your lab, but please make sure to return the components to the lab cabinet when you are done.\nIn addition, the software we will be using for programming the MCU (SEGGER Embedded Studio for ARM) and FPGA (Lattice Radiant) are free and supported on a variety of platforms if you wish to download them on your personal computer. SEGGER Embedded Studio is supported on Windows, MacOS, and Linux and Lattice Radiant is supported on Windows and Linux. If you are running MacOS, you can download and virtualize Windows using VMWare Fusion Player under a Personal Use License for free. More details and download links can be found here (link)."
  },
  {
    "objectID": "syllabus/index.html#honor-code-violations",
    "href": "syllabus/index.html#honor-code-violations",
    "title": "Course Syllabus",
    "section": "",
    "text": "Students in this class are expected to follow the HMC honor code. An honor code policy appears below and prescribes behavior that is considered honorable, so read those maxims and follow them closely. Any honor code violations will be handled through JB."
  },
  {
    "objectID": "syllabus/index.html#honor-code-policy",
    "href": "syllabus/index.html#honor-code-policy",
    "title": "Course Syllabus",
    "section": "",
    "text": "All students enrolled in this course are bound by the HMC Honor Code. More information on the HMC Honor Code can be found in the HMC Student Handbook.\nIt is your responsibility to determine whether your actions adhere to the HMC Honor Code. If this document does not clarify the legitimacy of a particular action, you should contact the course instructor and request clarification.\nWork you submit for individual assignments should be your own, and you should complete all assignments based on your own understanding of the underlying material. If you work with, or receive help from, another individual on an assignment, provide a written acknowledgement in complete sentences that includes the person’s name and the nature of the help.\nThis document is not meant to be an exhaustive list of every possible Honor Code violation. Infractions not explicitly mentioned here may still violate the Honor Code.\nBoundaries of Collaboration Verbal collaboration with other students on individual assignments is encouraged AFTER you have given serious thought to each component yourself. However, all submitted written work should be written by yourself individually, and not a collaborative effort or copied from a common source (e.g., a chalkboard). It is NOT acceptable to work on labs in lockstep with another classmate.\nUse of Computer Software The use of graphing calculators and computer software to aid in course work is acceptable, as long as it does not substitute for an understanding of the course material.\nUse of Web Resources The use of Internet resources to aid in course work is acceptable, as long it does not substitute for an understanding of the course material. Plagiarism and direct copying from online (or any other) sources is strictly prohibited.\nUse of Your Own Work from Previous Semesters If you have previously attempted this course, you may resubmit your work from previous semesters as this semester’s coursework, as long as you understand the underlying material.\nUse of Other Course Resources from Previous Semesters You may not reference assignments (labs, problem sets, activities) of this course from previous semesters.\nRetention of Course Resources Assignments and exams from this course may not be committed to dorm repositories or otherwise used to help future students."
  },
  {
    "objectID": "syllabus/index.html#inclusiveness-and-harassment",
    "href": "syllabus/index.html#inclusiveness-and-harassment",
    "title": "Course Syllabus",
    "section": "",
    "text": "We do difficult work in this class and everyone should feel comfortable engaging with the material. We explicitly want you to feel safe doing this work, so it is worth stating that the instructors are committed to making the class a safe space for everyone regardless of race, gender, ethnicity, sexual orientation, religion, and academic history. If you feel that you are experiencing a hostile environment, speak to an instructor immediately."
  },
  {
    "objectID": "syllabus/index.html#educational-accessibility",
    "href": "syllabus/index.html#educational-accessibility",
    "title": "Course Syllabus",
    "section": "",
    "text": "HMC is committed to providing an inclusive learning environment and support for all students. Students with a disability (including mental health, chronic or temporary medical conditions) who may need some accommodation in order to fully participate in this class are encouraged to contact Educational Accessibility Services at ability@g.hmc.edu to request accommodations. Students from the other Claremont Colleges should contact their home college’s disability resources officer."
  },
  {
    "objectID": "syllabus/index.html#footnotes",
    "href": "syllabus/index.html#footnotes",
    "title": "Course Syllabus",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee this article from Marc Watkins for a more in-depth discussion.↩︎\nThis makes sense because most of the HDL code you find on the internet is pretty lousy. Garbage in, garbage out.↩︎"
  },
  {
    "objectID": "tutorials/segger_embedded_studio_setup/index.html",
    "href": "tutorials/segger_embedded_studio_setup/index.html",
    "title": "SEGGER Embedded Studio Setup",
    "section": "",
    "text": "If you have not yet installed SEGGER Embedded Studio, first see and follow the instructions in Appendix A: Install SEGGER Embedded Studio & Support Packages.\nIn this section we will use the SEGGER Embedded Studio to create, build, and upload a simple program to blink the LED on your board.\nSEGGER studio development projects are grouped into projects and solutions.\n\nA project contains and organizes everything you need to create a single application or a library.\nA solution is a collection of projects and configurations.\n\nIn most cases, you will be designing a single application and the most straightforward organization is to have a single project within a solution.\nTo start, create a new project by navigating to “File &gt; New Project”. Select create the project in a new solution.\nScroll down and select “A C/C++ executable for STMicroelectronics STM32L4xx” and name the project “blink_demo.”\n\n\n\n\n\n\nFigure 1: New project template.\n\n\n\nSelect the proper Target processor (STM32L432KCUx).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Setting up the target processor.\n\n\n\nOn the next page, leave all the options checked and allow both configurations on the next page. Click finish to close the wizard.\n\n\n\n\n\n\nFigure 3: Project configuration.\n\n\n\nIf you click the arrows to expand the tree of files in the project you will see a main.c file in the source directory and the supporting basic system files and device drivers.\n\n\n\n\n\n\nFigure 4: Project files in default projects.\n\n\n\nNext, open up main.c and edit it to include the following code. This code toggles the GPIO pin PB3 on and off, blinking the on-board LED. A for loop that counts to a set value using a dummy variable serves to create a simple delay so that the LED blinks slow enough to easily see it.\n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : LED blink demo\n\n*/\n\n#include &lt;stm32l432xx.h&gt;\n#include &lt;stdint.h&gt;\n\nint main(void) {\n\n// Initialization code\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN;\n\nGPIOB-&gt;MODER |= GPIO_MODER_MODE3_0;\nGPIOB-&gt;MODER &= ~GPIO_MODER_MODE3_1;\n\nwhile(1) {\n for(volatile int i = 0; i &lt; 20000; i++);\n GPIOB-&gt;ODR ^= (1 &lt;&lt; 3);\n }\n}\n/*************************** End of file ****************************/\nAfter writing the code, build it by running “Build blink_led” from the Build menu or by using the keyboard shortcut F7. If you get any error messages, use the information printed in the output window to locate the error (double clicking on the error message should bring you to the appropriate section of code) and correct the bug. Note that frequently the line previous to the line identified as containing the bug is where the actual problem lies. After successfully resolving any compilation errors you are ready to move on to uploading and debugging your code."
  },
  {
    "objectID": "tutorials/segger_embedded_studio_setup/index.html#create-new-test-project",
    "href": "tutorials/segger_embedded_studio_setup/index.html#create-new-test-project",
    "title": "SEGGER Embedded Studio Setup",
    "section": "",
    "text": "If you have not yet installed SEGGER Embedded Studio, first see and follow the instructions in Appendix A: Install SEGGER Embedded Studio & Support Packages.\nIn this section we will use the SEGGER Embedded Studio to create, build, and upload a simple program to blink the LED on your board.\nSEGGER studio development projects are grouped into projects and solutions.\n\nA project contains and organizes everything you need to create a single application or a library.\nA solution is a collection of projects and configurations.\n\nIn most cases, you will be designing a single application and the most straightforward organization is to have a single project within a solution.\nTo start, create a new project by navigating to “File &gt; New Project”. Select create the project in a new solution.\nScroll down and select “A C/C++ executable for STMicroelectronics STM32L4xx” and name the project “blink_demo.”\n\n\n\n\n\n\nFigure 1: New project template.\n\n\n\nSelect the proper Target processor (STM32L432KCUx).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Setting up the target processor.\n\n\n\nOn the next page, leave all the options checked and allow both configurations on the next page. Click finish to close the wizard.\n\n\n\n\n\n\nFigure 3: Project configuration.\n\n\n\nIf you click the arrows to expand the tree of files in the project you will see a main.c file in the source directory and the supporting basic system files and device drivers.\n\n\n\n\n\n\nFigure 4: Project files in default projects.\n\n\n\nNext, open up main.c and edit it to include the following code. This code toggles the GPIO pin PB3 on and off, blinking the on-board LED. A for loop that counts to a set value using a dummy variable serves to create a simple delay so that the LED blinks slow enough to easily see it.\n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : LED blink demo\n\n*/\n\n#include &lt;stm32l432xx.h&gt;\n#include &lt;stdint.h&gt;\n\nint main(void) {\n\n// Initialization code\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN;\n\nGPIOB-&gt;MODER |= GPIO_MODER_MODE3_0;\nGPIOB-&gt;MODER &= ~GPIO_MODER_MODE3_1;\n\nwhile(1) {\n for(volatile int i = 0; i &lt; 20000; i++);\n GPIOB-&gt;ODR ^= (1 &lt;&lt; 3);\n }\n}\n/*************************** End of file ****************************/\nAfter writing the code, build it by running “Build blink_led” from the Build menu or by using the keyboard shortcut F7. If you get any error messages, use the information printed in the output window to locate the error (double clicking on the error message should bring you to the appropriate section of code) and correct the bug. Note that frequently the line previous to the line identified as containing the bug is where the actual problem lies. After successfully resolving any compilation errors you are ready to move on to uploading and debugging your code."
  },
  {
    "objectID": "tutorials/segger_embedded_studio_setup/index.html#uploading-the-code",
    "href": "tutorials/segger_embedded_studio_setup/index.html#uploading-the-code",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Uploading the Code",
    "text": "Uploading the Code\nTo upload your compiled code, use the Target menu and select “Connect J-Link”. If you get any errors check that your board is properly connected. If you are still having issues, contact the instructor as you might need to upgrade the firmware on your board from ST-LINK to J-Link.\nAfter connecting the J-Link, download the compiled code to the board by selecting Target &gt; Download blink_led from the menu. If everything is working correctly, you should see a message in the Output window that the download was successful and the green user LED (LD3) on your Nucleo board should start blinking.\nCongratulations, you have successfully built your first project on your microcontroller!"
  },
  {
    "objectID": "tutorials/segger_embedded_studio_setup/index.html#appendix-a-install-segger-embedded-studio-and-support-packages",
    "href": "tutorials/segger_embedded_studio_setup/index.html#appendix-a-install-segger-embedded-studio-and-support-packages",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Appendix A: Install SEGGER Embedded Studio and Support Packages",
    "text": "Appendix A: Install SEGGER Embedded Studio and Support Packages\nDownload Segger Embedded Studio. The current version as of this writing is 7.32. There are versions of the program available for Windows, Linux, and Mac. Make sure to choose the appropriate installer for your computer hardware. You may find the SEGGER Embedded Studio User Guide helpful for answering questions about how to navigate the program.\nYou will also need to download and install the J-Link Drivers for your operating system from here.\nBefore you create your project, you will need to download a few support packages for the CPU on our board. Download the following support packages in SEGGER Embedded Studio (tick the option in package manager gear icon in top right to show all downloaded packages, not just those that aren’t installed yet)\n\nSTM32L4xx CPU Support Package\nCMSIS 5 CMSIS-CORE Support Package\nCMSIS 5 Documentation Package"
  },
  {
    "objectID": "tutorials/segger_embedded_studio_setup/index.html#appendix-b-st-link-to-j-link-firmware-upgrade",
    "href": "tutorials/segger_embedded_studio_setup/index.html#appendix-b-st-link-to-j-link-firmware-upgrade",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Appendix B: ST-LINK to J-Link Firmware Upgrade",
    "text": "Appendix B: ST-LINK to J-Link Firmware Upgrade\nYour STM32 Nucleo boards come with an on-board debugger ST-LINK debugger. This debugger is not compatible out of the box with the SEGGER tools and the firmware needs to be updated to connect to SEGGER Embedded Studio. The boards in your kits should have already been updated so that they are ready to go, but if for some reason your computer is not recognizing the board, you may need to download and perform the firmware upgrade yourself. Instructions on how to do so can be found here. Note that this upgrade process can only be completed on Windows."
  },
  {
    "objectID": "tutorials/lattice_radiant_installation/index.html",
    "href": "tutorials/lattice_radiant_installation/index.html",
    "title": "Lattice Radiant Installation Instructions",
    "section": "",
    "text": "Introduction\nLattice Radiant is the synthesis tool provided by Lattice Semiconductor for targeting their FPGA devices.\n\n\nDownload\nDownload the software installer from Lattice’s website for your operating system from this link Lattice Radiant Software. (Windows and Linux only. You will need to use virtualization to use Radiant on Mac.) The current version as of this writing is 2023.1. You will need to create an account to access the download.\n\n\nWorking with the UPduino v3.1 on macOS\nI use the Windows version in a Parallels Windows 11 Virtual Machine. The synthesis and simulation works without a hitch but the programming is finicky. I suspect it has something to do with some wonkiness with the USB drivers and the Virtual Machine. To work around this, you can use the openFPGALoader project which is universal utility for programming FPGAs. Instructions for installation and use can be found here.\nThe easiest way is to directly install it as a Homebrew formula:\nbrew install openfpgaloader\nAfter installation, to program our UPduino v3.1 board, use the command:\nopenFPGALoader -b ice40_generic -c ft232  -f &lt;path_to_.bin_file&gt;\n\n\nInstallation\nAs part of the installation, make sure to select the iCE40 UltraPlus family device support package along with the Programmer and Mentor ModelSim Lattice Edition. After this menu, click through to finish the installation process.\n\n\n\n\n\n\nFigure 1: Installation components to select.\n\n\n\n\n\nLicensing\nTo run Radiant you will need to also request and install a license for the software. Navigate here and request a node-locked license. This license is designed to be run on a single computer.\nTo download the license you will need to find your Host Network Interface Card (NIC) address. To find the NIC address, follow the steps below.\nFor Windows, from an MS-DOS window (command prompt), use the ipconfig /all command\nFor Linux, from the command prompt, use the ifconfig -a command\n\n\n\n\n\n\nFigure 2: Finding NIC physical address.\n\n\n\nEnter your Host NIC address (without dashes) and click the required checkbox. You do not need to select any of the optional Radiant Free IP. Then click the “Generate License” button.\nAfter receiving the license file (license.dat), follow the instructions in the email about how to install the license. You should have to place it in the location specified in the email (C:on Windows), select this license location in the FlexNet License Finder window, and set the LM_LICENSE_FILE environment variable to the path of your license file (instructions). This should ensure that both Radiant and ModelSim are properly licensed.\n\n\n\n\n\n\nFigure 3: FlexNet License Finder dialog.\n\n\n\nYou can also check the license paths afterwards by using the License Debug Tool under the Help menu."
  },
  {
    "objectID": "lecture/index.html",
    "href": "lecture/index.html",
    "title": "Lecture",
    "section": "",
    "text": "Lecture 1: Introduction and Analog Behavior of Digital Systems [slides] [handout]\nLecture 2: Combinational and Sequential Logic [slides] [handout]\nLecture 3: Verilog [slides] [handout]\nLecture 4: Synchronous Design [slides] [handout]\nLecture 5: FPGA Documentation [slides] [handout]\nLecture 6: Introduction to the STM32 L432KC MCU [slides] [handout]\nLecture 7: ARM Assembly Programming [slides] [handout]\nLecture 8: C Programming [slides] [handout]\nLecture 9: Clock Configuration [slides] [handout]\nLecture 10: Timers [slides] [handout]\nLecture 11: Serial Interfaces and SPI [slides] [handout]\nLecture 12: UART and the Internet of Things [slides] [handout]\nLecture 13: Introduction to AES: Galois Fields [slides] [handout]\nLecture 14: The Advanced Encryption Standard (AES) [slides] [handout]\nLecture 15: Final Project Kickoff\nLecture 16: Graphics and Displays\nLecture 17: Motors and Speakers\nLecture 18: Interrupts [slides] [handout]\nLecture 19: Interrupts Activity [slides] [handout]\nLecture 20: The Fast Fourier Transform [slides] [handout]\nLecture 21: Direct Memory Access [slides] [handout]\nLecture 22: Introduction to Real Time Operating Systems [slides] [handout]"
  },
  {
    "objectID": "project/specs/project-checkoff-specs.html",
    "href": "project/specs/project-checkoff-specs.html",
    "title": "Project Final Checkoff Specs",
    "section": "",
    "text": "Project meets most of of the specifications as laid out in the proposal with explanations for any specifications that weren’t met.\nSystem operates without any major bugs (e.g., doesn’t freeze in operation)\nDocument listing each spec from the proposal along with a short (e.g., 3-5 sentence) summary explaining whether the spec was met or not.\nTechnical documentation (e.g., schematics, code, block diagrams) available for review at checkoff.\nVerilog HDL is functional and cleanly formatted\nMCU C code is functional and cleanly formatted"
  },
  {
    "objectID": "project/specs/project-checkoff-specs.html#proficiency",
    "href": "project/specs/project-checkoff-specs.html#proficiency",
    "title": "Project Final Checkoff Specs",
    "section": "",
    "text": "Project meets most of of the specifications as laid out in the proposal with explanations for any specifications that weren’t met.\nSystem operates without any major bugs (e.g., doesn’t freeze in operation)\nDocument listing each spec from the proposal along with a short (e.g., 3-5 sentence) summary explaining whether the spec was met or not.\nTechnical documentation (e.g., schematics, code, block diagrams) available for review at checkoff.\nVerilog HDL is functional and cleanly formatted\nMCU C code is functional and cleanly formatted"
  },
  {
    "objectID": "project/specs/project-checkoff-specs.html#excellence",
    "href": "project/specs/project-checkoff-specs.html#excellence",
    "title": "Project Final Checkoff Specs",
    "section": "Excellence",
    "text": "Excellence\n\nProject meets all the specifications as laid out in the proposal.\nProject is polished (e.g., wires are hidden, any physical interfaces are well-designed and reliable, clean user interface)\nVerilog code is efficient and demonstrates best coding practices (e.g., modularity, testbenches were appropriate, etc.)\nC code is efficient and well organized (e.g., code encapsulated in functions and custom libraries as appropriate)"
  },
  {
    "objectID": "project/specs/project-final-report-specs.html",
    "href": "project/specs/project-final-report-specs.html",
    "title": "Project Final Portfolio Specs",
    "section": "",
    "text": "Written documentation should follow all the specifications for written documentation as laid out in the general lab specs. In addition, the report should address these project-specific specifications."
  },
  {
    "objectID": "project/specs/project-final-report-specs.html#proficiency",
    "href": "project/specs/project-final-report-specs.html#proficiency",
    "title": "Project Final Portfolio Specs",
    "section": "Proficiency",
    "text": "Proficiency\n\nTechnical Information\n\nBill of materials including all relevant components with quantities, part numbers, and prices.\nMicrocontroller design overview: description of what the MCU is doing.\nFPGA design overview: what is the FPGA doing along with main design features.\n\n\n\nWritten Documentation\n\nNames and short bios of team members with link to personal website or LinkedIn profile.\nAbstract which briefly describes the main purpose and operation of the system.\nNew hardware listed in section with description\nResults: What are the main results of your project.\nReferences: Citation (and hyperlinks where relevant) to any outside resources that were referenced in the design of the project.\nAcknowledgements\nAll project code (software and HDL) included in Git repository\n\n\n\nWriting and Organization\n\nWebsite is well organized with clear separation of relevant information.\nNo more than a few minor spelling or grammar issues.\nNo missing placeholders (e.g., XX) or dead hyperlinks."
  },
  {
    "objectID": "project/specs/project-final-report-specs.html#excellence",
    "href": "project/specs/project-final-report-specs.html#excellence",
    "title": "Project Final Portfolio Specs",
    "section": "Excellence",
    "text": "Excellence\n\nTechnical Documentation\n\nSchematics are neatly drawn with a CAD program (e.g., KiCad). All necessary labels present (pins names & numbers, part numbers, etc.)\nBlock diagram is neat and completely specified (e.g., all communication protocols labeled, bus widths indicated, etc.)\n\n\n\nWritten Documentation\n\nNew hardware described with notes about the features to be implemented and how they go beyond the previous material covered in the course.\nResults section clearly and quantitatively outlines the key performance aspects of the design with commentary to explain the design decisions.\nReferences are formatted with a clean and consistent format.\nAll project code is accompanied by comments throughout\nGit repository contains a README.md file to describe the main elements of the project and where they are found.\n\n\n\nWriting and Organization\n\nExcellent spelling and grammar throughout\n\n\n\nMultimedia Documentation\n\nShort video showcasing a demonstration of the project\nPhotos documenting final design"
  },
  {
    "objectID": "project/specs/project-final-report-specs.html#optional",
    "href": "project/specs/project-final-report-specs.html#optional",
    "title": "Project Final Portfolio Specs",
    "section": "Optional",
    "text": "Optional\n\nPhotos documenting the build process"
  },
  {
    "objectID": "project/specs/project-design-review-presentation-specs.html",
    "href": "project/specs/project-design-review-presentation-specs.html",
    "title": "Project Design Review Presentation Specs",
    "section": "",
    "text": "The purpose of the design review presentation is to provide you with the opportunity to share the plan for your project with your classmates and solicit their feedback.\nYou are free to structure your presentation however you would like, but most successful presentations include the following components.\nThe specifications below lay out how you will be assessed."
  },
  {
    "objectID": "project/specs/project-design-review-presentation-specs.html#proficiency",
    "href": "project/specs/project-design-review-presentation-specs.html#proficiency",
    "title": "Project Design Review Presentation Specs",
    "section": "Proficiency",
    "text": "Proficiency\n\nPresentation gives overview of the project\nPresentation presents a problem or question for the class\nInput solicited from the class"
  },
  {
    "objectID": "project/specs/project-design-review-presentation-specs.html#excellence",
    "href": "project/specs/project-design-review-presentation-specs.html#excellence",
    "title": "Project Design Review Presentation Specs",
    "section": "Excellence",
    "text": "Excellence\n\nPresentation wraps up on time\nSlides are well formatted with no spelling, grammar, or formatting issues.\nPresentation presents an in-depth technical problem\nProblem or question for the class is technical in nature (e.g., soliciting feedback about tradeoffs for a specific protocol for an interface)."
  },
  {
    "objectID": "project/reports/2022/index.html",
    "href": "project/reports/2022/index.html",
    "title": "Fall 2022",
    "section": "",
    "text": "Title\nTeam Members\nWebsite URL\n\n\nRobotic Slide Whistle\nDeclan O’Neill, Kip Macsai-Goren\nhttps://doneill890.github.io/slide-whistle/\n\n\nAuto Audio Harmonizer\nBrian Simpkins, Kevin Kim\nhttps://briansimpkins.github.io/E155_Final/\n\n\nAnalog Signal Display (Scope)\nTristan Huang, Alexa Wright\nhttps://thuang8.github.io/E155_FA22_Final_Project_TH_AW/\n\n\nGuarded Safe\nLimnanthes Serafini, Noah Limpert\nhttps://magpyed.github.io/E155-FA22-Final-Project/\n\n\nRFID Doorbell\nJoseph Zales, Ava Fascetti\nhttps://joseph-q-zales.github.io/HMC-MicroPs-Final-Portfolio/\n\n\nPinball Machine\nAlessandro Maiuolo, Cristian Gonzalez\nhttps://cristiango23.github.io/E155-FA22-Final-Project/\n\n\nRandom Clock\nRuth Mueller, Kevin Wan\nhttps://koooo-142857.github.io/E155_Random_Clock/\n\n\nPet Autofeeder\nCedar Turek, Manuel Mendoza Manriquez\nhttps://cturek.github.io/E155-Autofeeder/\n\n\nSelf-balancing Robot\nTanvika Dasari, Eric Chen\nhttps://tanvikad.github.io/balance-robot/\n\n\nCrane Game\nMiles Cook, Penny Hernandez\nhttps://mcook26.github.io/Crane-Game/"
  },
  {
    "objectID": "project/storytelling-worksheet.html",
    "href": "project/storytelling-worksheet.html",
    "title": "Storytelling Worksheet",
    "section": "",
    "text": "Now that you’ve done all the hard technical work for your project, it’s time for the fun part: showing it off! As part of you final project website we’ll be creating short videos which showcase your project.\nThink of this like an elevator pitch for your project. You’ll have a minute to introduce your project and highlight the key features."
  },
  {
    "objectID": "project/storytelling-worksheet.html#format",
    "href": "project/storytelling-worksheet.html#format",
    "title": "Storytelling Worksheet",
    "section": "Format",
    "text": "Format\nWe’ll use the classic hero’s arc storytelling framework for making your video sticky.\n\n\n\nThe User’s Journey: Storymapping Projects That People Love, Lichaw, Donna, 2016. New York: Rosenfeld Media"
  },
  {
    "objectID": "project/storytelling-worksheet.html#designing-your-story",
    "href": "project/storytelling-worksheet.html#designing-your-story",
    "title": "Storytelling Worksheet",
    "section": "Designing Your Story",
    "text": "Designing Your Story\n\nCurrent State\nCharacter, what’s good, goals.\n\n\n\nProblem, Trigger, or Call to Action\nWhat’s the core problem your project addresses?\n\n\n\nImpediment(s)\nWhat’s the gap that your project addresses?\n\n\n\nYour Project\nWhat did you build?\n\n\n\nProblem Solved, Experience, or Delight\nHow does it solve it?\n\n\n\nThen what?\nWhat should you do next?\n\n\n\nEnd"
  },
  {
    "objectID": "resources/index.html",
    "href": "resources/index.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Development Board Schematic\nE155 Breadboard Adapter Schematic\nE155 Development Board BOM"
  },
  {
    "objectID": "resources/index.html#open-source-toolchain-for-ice40",
    "href": "resources/index.html#open-source-toolchain-for-ice40",
    "title": "Resources",
    "section": "Open Source Toolchain for iCE40",
    "text": "Open Source Toolchain for iCE40\n\napio\nProject IceStorm\nOSS CAD Suite\nShawn Hymel Introduction to FPGA YouTube Series"
  },
  {
    "objectID": "resources/index.html#past-versions-of-e155",
    "href": "resources/index.html#past-versions-of-e155",
    "title": "Resources",
    "section": "Past versions of E155",
    "text": "Past versions of E155\n\nFA19\nFA20\nFA21\nFA22"
  },
  {
    "objectID": "admin/syllabus.html",
    "href": "admin/syllabus.html",
    "title": "Course Syllabus",
    "section": "",
    "text": "Item\nInformation\n\n\n\n\nInstructor:\nProf. Josh Brake\n\n\nLab Assistant(s):\nTBD\n\n\nWeb page:\nhttp://pages.hmc.edu/brake/class/e155/\n\n\nEmail list:\neng-155 [at] g.hmc.edu\n\n\nDiscord Server:\nSee email for invite\n\n\n\nBe sure to join the class Slack workspace and check it regularly as it will be the main source of course-related communication for this semester.\n\n\n\n\n\n\n\n\n\n\nName\nInfo\n\n\n\n\nLecture\nTR 1:15 - 2:30 pm\n\n\nLab Checkoff\nTR afternoons by signup in the Digital Lab (PA B183)\n\n\nOffice Hours\nTBD\n\n\nLab Hours\nTBD\n\n\n\nYou will be working on labs on your own time and it is not required that you attend the entire scheduled lab period. Instead, sign up for a time to get your lab checked off. Please sign up for a time during your lab section. If you are unable to find a spot that works for you, see if you can swap with one of your classmates. If you are still having trouble finding a time that works for you, reach out and let me know.\n“Office hours” is code for “come hang out.” You are encouraged to attend office hours to ask questions, get help with your labs, talk about careers and graduate school, or chat about something on your mind (whether it is related to this class, academics, or anything else). In addition to things related to Engineering, embedded systems, digital electronics, and microcontrollers, a short (but not comprehensive!) list of things I enjoy talking about are sports (MLB: NY Mets; NFL: Tennessee Titans), running/biking/hiking, life design, time management, or books/essays I’m reading. I am available more often than not, so try dropping me a line via Slack or email if you are having a problem with your lab or want to set up a time. You may also contact the lab assistant(s) for questions when I am not available.\n\n\n\nThe overarching goal of this course is to take you from a basic familiarity and knowledge of digital design with field gate programmable arrays (FPGAs) and microcontrollers programming and expand your capabilities to design, build, and test embedded systems. In particular, by the end of this course you should be able to:\n\nDesign and implement combinational and sequential circuits on an FPGA.\nUse an ARM-based microcontroller to interface with the real world via sensors and actuators.\nBuild an embedded system project of your own design from the ground up.\nSelect appropriate embedded hardware for a given task and use the appropriate hardware for a given problem.\nEffectively and efficiently debug electrical systems with measurement tools such as an oscilloscope and logic analyzer.\nRead and understand complicated datasheets at a level that enables you to incorporate them into your designs.\nClearly communicate technical results in a professional manner through oral presentations and written reports.\n\nIn broad strokes, MicroPs can be divided into two halves. The first half of the class focuses on giving you fundamental embedded systems concepts in lecture which you learn by experience through seven, hands-on labs. These labs are designed to be loosely structured design projects – you will be given information about the required specifications and some pointers on how to get started, but much of the development process is left open to you. The second half of the class is mainly focused on the project. The project gives you the opportunity to demonstrate independent and creative mastery of embedded system design in teams of two. The specific project task is very open-ended; the only requirement is that the project does something fun or useful and that it meaningfully uses both the FPGA and MCU. In addition to having a series of design review checkpoints, you will give a mid-project presentation to the class and a final presentation of your project when finished. The content of the lectures in the second half of the class focuses on exposing you to more advanced embedded systems concepts and exploring a range of various types of external hardware that may be useful to use in your project.\n\n\n\nI love teaching at Harvey Mudd and having the opportunity to learn alongside all of you in the classroom and lab is one of the best parts of my job. My ultimate goal for this course is to help you to master the material and become skilled embedded systems developers who understand how to build a system from a set of requirements and specifications and to verify that the system meets those specifications. I am continually reading and learning from the literature on effective pedagogy and working to implement best practices in my teaching.\nHere are a few of the main pedagogical concepts that you can expect to see in this course.\n\nTransparent Teaching – you should not have to guess what you are supposed to get out of a given activity or assignment in this class. I strive to be as transparent about why we are doing what we are doing. This is most clearly articulated through explicit learning goals that accompany each lecture, lab, or project. If the purpose of anything we do in this class is ever unclear, please ask me and I will be happy to clarify it.\nPsychological Safety – A psychologically safe environment is one where each person feels able to share their questions, concerns, or mistakes without feeling embarrassed or looked down upon by others. Building a psychologically safe classroom is a joint venture which I expect each of you to join with me in pursuing.\nA Growth Mindset – growth can only happen when you reach the end of what you already know. Each of you coming into this class will have different levels of experience with the types of skills that are useful in this class like working with embedded systems, programming, debugging, design, etc. My goal as an instructor is to take you from wherever you are and bring you as far along in your journey as possible. To do that, I encourage each of you to ask questions and push yourself to the edge of your knowledge. It can be frustrating or embarrassing to have questions that you feel you should already have the answer to. You should take these moments as opportunities to ask questions and fill the gaps in your knowledge. In the end, having a growth mindset is strongly linked with deep curiosity about what you are learning and a realization that while being honest about the limits of your understanding might be challenging, embracing that discomfort allows you to grow and improve quickly.\nFrequent, Low-stakes Testing – Research has shown that having frequent opportunities to assess your knowledge is a powerful way to learn and correct any misconceptions. One way that this will take place is through regular in-class quizzes and activities.\nInterleaving – The scheduling of the material is arranged in such a way that you will return to many similar concepts throughout the semester with some time in between. The goal of this is to have you return to familiar concepts after some time away so that you reinforce the material after working on something else. This has been shown to improve long-term retention of the material (see Small Teaching by James Lang if you are curious in learning more).\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTuesday’s Class\nThursday’s Class\nDue\n\n\n\n\n8/29\nIntro & Analog Behavior of Digital Systems\nCombinational and Sequential Logic\n(Lab Demos)\n\n\n9/5\nVerilog Coding\nSynchronous Design\nLab 1 - Development Board Assembly\n\n\n9/12\nFPGA Documentation\nArchitecture & Assembly Review\nLab 2 - Muxed 7-Segment Display\n\n\n9/19\nAssembly Programming\nC Programming on an MCU\nLab 3 - Keypad\n\n\n9/26\nClock Configuration\nTimers\nLab 4 - ARM Assembly Sort\n\n\n10/3\nSerial Interfaces Overview & SPI\nUART and the IoT\nLab 5 - Digital Audio\n\n\n10/10\nPCB Design\nAdvanced Encryption Standard (AES)\nLab 6 - SPI & The Internet of Things\n\n\n10/17\nHappy Fall Break! No Class\nProject Kickoff\n\n\n\n10/24\nGraphics and Displays\nMotors and Speakers\nLab 7 - AES & Project Proposal\n\n\n10/31\nInterrupts Pt. 1\nInterrupts Pt. 2\nProposal Debriefs\n\n\n11/7\nThe Fast Fourier Transform (FFT)\nDirect Memory Access\n\n\n\n11/14\nIntroduction to Real Time Operating Systems\nProject Status Report and Demo\nProject Status Reports & Demo\n\n\n11/21\nEmerging Topics in Embedded Systems\nHappy Thanksgiving! No class\n\n\n\n11/28\nPresentations\nPresentations\n\n\n\n12/5\nGuest Lecture: Benson Tsai ’06\nInterview Questions & Life Beyond Mudd\nProject Checkoffs, Report, Demo Day\n\n\n\n\n\n\nI assume you have a mastery of digital design at the level of E85; review Digital Design and Computer Architecture, ARM Edition (link) if you feel rusty on a topic. We will not be closely following a textbook, but you may find The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors by Joseph Yiu to be a helpful, comprehensive reference for the microcontroller. An electronic version of the book is available through the library (link).\n\n\n\n\n\n\n\nItem\nPercentage\n\n\n\n\nLabs\n50%\n\n\nFinal Project\n45%\n\n\nParticipation\n5%\n\n\n\n\nYour grade in the class is based on seven labs and a final project. You may have an extension of up to one week on one of your labs except for the final lab; otherwise, late work is not accepted. The last lab must be submitted on time in order to allow you to get started on your project. Your lowest lab score will have half the weight of the others. Labs are done individually. You are welcome to discuss them with other students or the instructor, but only after you have made an effort by yourself. Please list the names of other students you have worked with on your submissions. Although collaboration is strongly encouraged, you must turn in your own work, not work identical to that of another person. It is an honor code violation to simply copy someone else’s work. Solutions to past year’s labs have been handed out. It is also an honor code violation to refer to these solutions while doing your lab. The final project will be done in groups of two.\nThe deliverables for each lab will consist a brief written report which should include the following:\n\nAn overview which must not exceed one page, that provides a summary of the work, context for the other materials, an explanation of major design decisions, and a succinct explanation of whether the lab met requirements or how it deviates.\nSchematics of the circuits constructed for the lab. Use standard symbols for standard components, and be sure the schematic is sufficient for another engineer to reproduce your circuit.\nCode written for the lab.\nFigures that illustrate the output of the circuits or other results of the lab.\n\nThe purpose of these deliverables is to train you in professional, technical communication, so they will be held to high standards. All schematics must feature neat wiring, up to date values for every component, and ports labeled with both the pin and the signal associated with them. Figures must be readable and must include labeled axes and legends. Code should be commented; omit library code that is provided elsewhere. The report should be grammatically correct, succinct, tightly focused and complete. Properly referencing figures will help keep the report brief.\nWe will use Gradescope to collect lab submissions. Each lab should be submitted as a single PDF report including all written documentation.\nLabs are graded on a 7-point scale. 3 points are given for the system meeting its specified requirements and 3 points are given for the report, schematics, and code.\nThe last point for the lab grade is given for answering a fault tolerance question (FTQ). Students occasionally feel stressed about the FTQs, but these are designed to test the depth of your understanding about the concepts explored in the lab and simulate real world experience.\nThe final project will be done in groups of two. More information about the final project will be provided in the middle of the semester, but begin thinking now about who you might want to work with and begin brainstorming projects. You may see the course webpage for a listing of projects from previous years for inspiration. The final project is designed to give you a great deal of flexibility in choosing something you are interested in – the main requirement is that your project uses both the microcontroller and FPGA meaningfully to do something useful or interesting. Using the FPGA meaningfully is often the most difficult part so think about this carefully. You are more than welcome to discuss potential project ideas with me at any time.\nThe participation portion of your grade will be awarded for attending and engaging during class time and for completing various in-class activities. I put significant time and effort into making the most of the lecture periods we have together and hope that you also can bring a positive and enthusiastic attitude as we learn together this semester.\n\n\n\nWhile there is not a textbook to purchase, you will need to buy a lab kit. The fee is $75 in Claremont Cash, and should be paid by filling out the Google Form (link) which authorizes Sydney Torrey in the Engineering office to charge your Claremont Cash account. Once you have paid for your kit via the form, see Sam Abdelmuati in the stockroom to pick up your kit. If you cook your board this semester, you can buy and rebuild a replacement, but ask the instructor for help troubleshooting first. You’ll also check out a large breadboard from the stockroom, and will need to return it at the end of the semester.\nThe kit fee can be waived in cases of financial hardship. To request a waiver fill out the form here (link). Course instructors will not know about waiver requests.\n\n\n\nThe Digital Lab (Parson B183) is available for you to use when working on your labs. The current door code will be shared on Slack when it is available. There are Windows PCs available with SEGGER Embedded Studio for ARM and Lattice Radiant installed along with the drivers required to program your board. The lab also has the electronics assembly equipment needed to solder, oscilloscopes and power supplies at the lab stations, and a lab cabinet with various resistors and some of the parts like wires, seven-segment LEDs, and transistors you will need for some of your labs. You are welcome to use these while working on your lab, but please make sure to return the components to the lab cabinet when you are done.\nIn addition, the software we will be using for programming the MCU (SEGGER Embedded Studio for ARM) and FPGA (Lattice Radiant) are free and supported on a variety of platforms if you wish to download them on your personal computer. SEGGER Embedded Studio is supported on Windows, MacOS, and Linux and Lattice Radiant is supported on Windows and Linux. If you are running MacOS, you can download and virtualize Windows using VMWare Fusion Player under a Personal Use License for free. More details and download links can be found here (link).\n\n\n\nStudents in this class are expected to follow the HMC honor code. An honor code policy appears below and prescribes behavior that is considered honorable, so read those maxims and follow them closely. Any honor code violations will be handled through JB.\n\n\n\n\nAll students enrolled in this course are bound by the HMC Honor Code. More information on the HMC Honor Code can be found in the HMC Student Handbook.\nIt is your responsibility to determine whether your actions adhere to the HMC Honor Code. If this document does not clarify the legitimacy of a particular action, you should contact the course instructor and request clarification.\nWork you submit for individual assignments should be your own, and you should complete all assignments based on your own understanding of the underlying material. If you work with, or receive help from, another individual on an assignment, provide a written acknowledgement in complete sentences that includes the person’s name and the nature of the help.\nThis document is not meant to be an exhaustive list of every possible Honor Code violation. Infractions not explicitly mentioned here may still violate the Honor Code.\nBoundaries of Collaboration Verbal collaboration with other students on individual assignments is encouraged AFTER you have given serious thought to each component yourself. However, all submitted written work should be written by yourself individually, and not a collaborative effort or copied from a common source (e.g., a chalkboard). It is NOT acceptable to work on labs in lockstep with another classmate.\nUse of Computer Software The use of graphing calculators and computer software to aid in course work is acceptable, as long as it does not substitute for an understanding of the course material.\nUse of Web Resources The use of Internet resources to aid in course work is acceptable, as long it does not substitute for an understanding of the course material. Plagiarism and direct copying from online (or any other) sources is strictly prohibited.\nUse of Your Own Work from Previous Semesters If you have previously attempted this course, you may resubmit your work from previous semesters as this semester’s coursework, as long as you understand the underlying material.\nUse of Other Course Resources from Previous Semesters You may not reference assignments (labs, problem sets, activities) of this course from previous semesters.\nRetention of Course Resources Assignments and exams from this course may not be committed to dorm repositories or otherwise used to help future students.\n\n\n\n\nWe do difficult work in this class and everyone should feel comfortable engaging with the material. We explicitly want you to feel safe doing this work, so it is worth stating that the instructors are committed to making the class a safe space for everyone regardless of race, gender, ethnicity, sexual orientation, religion, and academic history. If you feel that you are experiencing a hostile environment, speak to an instructor immediately.\n\n\n\nHMC is committed to providing an inclusive learning environment and support for all students. Students with a disability (including mental health, chronic or temporary medical conditions) who may need some accommodation in order to fully participate in this class are encouraged to contact Educational Accessibility Services at ability@g.hmc.edu to request accommodations. Students from the other Claremont Colleges should contact their home college’s disability resources officer."
  },
  {
    "objectID": "admin/syllabus.html#contact-information",
    "href": "admin/syllabus.html#contact-information",
    "title": "Course Syllabus",
    "section": "",
    "text": "Item\nInformation\n\n\n\n\nInstructor:\nProf. Josh Brake\n\n\nLab Assistant(s):\nTBD\n\n\nWeb page:\nhttp://pages.hmc.edu/brake/class/e155/\n\n\nEmail list:\neng-155 [at] g.hmc.edu\n\n\nDiscord Server:\nSee email for invite\n\n\n\nBe sure to join the class Slack workspace and check it regularly as it will be the main source of course-related communication for this semester."
  },
  {
    "objectID": "admin/syllabus.html#course-meeting-schedule",
    "href": "admin/syllabus.html#course-meeting-schedule",
    "title": "Course Syllabus",
    "section": "",
    "text": "Name\nInfo\n\n\n\n\nLecture\nTR 1:15 - 2:30 pm\n\n\nLab Checkoff\nTR afternoons by signup in the Digital Lab (PA B183)\n\n\nOffice Hours\nTBD\n\n\nLab Hours\nTBD\n\n\n\nYou will be working on labs on your own time and it is not required that you attend the entire scheduled lab period. Instead, sign up for a time to get your lab checked off. Please sign up for a time during your lab section. If you are unable to find a spot that works for you, see if you can swap with one of your classmates. If you are still having trouble finding a time that works for you, reach out and let me know.\n“Office hours” is code for “come hang out.” You are encouraged to attend office hours to ask questions, get help with your labs, talk about careers and graduate school, or chat about something on your mind (whether it is related to this class, academics, or anything else). In addition to things related to Engineering, embedded systems, digital electronics, and microcontrollers, a short (but not comprehensive!) list of things I enjoy talking about are sports (MLB: NY Mets; NFL: Tennessee Titans), running/biking/hiking, life design, time management, or books/essays I’m reading. I am available more often than not, so try dropping me a line via Slack or email if you are having a problem with your lab or want to set up a time. You may also contact the lab assistant(s) for questions when I am not available."
  },
  {
    "objectID": "admin/syllabus.html#course-learning-objectives",
    "href": "admin/syllabus.html#course-learning-objectives",
    "title": "Course Syllabus",
    "section": "",
    "text": "The overarching goal of this course is to take you from a basic familiarity and knowledge of digital design with field gate programmable arrays (FPGAs) and microcontrollers programming and expand your capabilities to design, build, and test embedded systems. In particular, by the end of this course you should be able to:\n\nDesign and implement combinational and sequential circuits on an FPGA.\nUse an ARM-based microcontroller to interface with the real world via sensors and actuators.\nBuild an embedded system project of your own design from the ground up.\nSelect appropriate embedded hardware for a given task and use the appropriate hardware for a given problem.\nEffectively and efficiently debug electrical systems with measurement tools such as an oscilloscope and logic analyzer.\nRead and understand complicated datasheets at a level that enables you to incorporate them into your designs.\nClearly communicate technical results in a professional manner through oral presentations and written reports.\n\nIn broad strokes, MicroPs can be divided into two halves. The first half of the class focuses on giving you fundamental embedded systems concepts in lecture which you learn by experience through seven, hands-on labs. These labs are designed to be loosely structured design projects – you will be given information about the required specifications and some pointers on how to get started, but much of the development process is left open to you. The second half of the class is mainly focused on the project. The project gives you the opportunity to demonstrate independent and creative mastery of embedded system design in teams of two. The specific project task is very open-ended; the only requirement is that the project does something fun or useful and that it meaningfully uses both the FPGA and MCU. In addition to having a series of design review checkpoints, you will give a mid-project presentation to the class and a final presentation of your project when finished. The content of the lectures in the second half of the class focuses on exposing you to more advanced embedded systems concepts and exploring a range of various types of external hardware that may be useful to use in your project."
  },
  {
    "objectID": "admin/syllabus.html#my-teaching-philosophy",
    "href": "admin/syllabus.html#my-teaching-philosophy",
    "title": "Course Syllabus",
    "section": "",
    "text": "I love teaching at Harvey Mudd and having the opportunity to learn alongside all of you in the classroom and lab is one of the best parts of my job. My ultimate goal for this course is to help you to master the material and become skilled embedded systems developers who understand how to build a system from a set of requirements and specifications and to verify that the system meets those specifications. I am continually reading and learning from the literature on effective pedagogy and working to implement best practices in my teaching.\nHere are a few of the main pedagogical concepts that you can expect to see in this course.\n\nTransparent Teaching – you should not have to guess what you are supposed to get out of a given activity or assignment in this class. I strive to be as transparent about why we are doing what we are doing. This is most clearly articulated through explicit learning goals that accompany each lecture, lab, or project. If the purpose of anything we do in this class is ever unclear, please ask me and I will be happy to clarify it.\nPsychological Safety – A psychologically safe environment is one where each person feels able to share their questions, concerns, or mistakes without feeling embarrassed or looked down upon by others. Building a psychologically safe classroom is a joint venture which I expect each of you to join with me in pursuing.\nA Growth Mindset – growth can only happen when you reach the end of what you already know. Each of you coming into this class will have different levels of experience with the types of skills that are useful in this class like working with embedded systems, programming, debugging, design, etc. My goal as an instructor is to take you from wherever you are and bring you as far along in your journey as possible. To do that, I encourage each of you to ask questions and push yourself to the edge of your knowledge. It can be frustrating or embarrassing to have questions that you feel you should already have the answer to. You should take these moments as opportunities to ask questions and fill the gaps in your knowledge. In the end, having a growth mindset is strongly linked with deep curiosity about what you are learning and a realization that while being honest about the limits of your understanding might be challenging, embracing that discomfort allows you to grow and improve quickly.\nFrequent, Low-stakes Testing – Research has shown that having frequent opportunities to assess your knowledge is a powerful way to learn and correct any misconceptions. One way that this will take place is through regular in-class quizzes and activities.\nInterleaving – The scheduling of the material is arranged in such a way that you will return to many similar concepts throughout the semester with some time in between. The goal of this is to have you return to familiar concepts after some time away so that you reinforce the material after working on something else. This has been shown to improve long-term retention of the material (see Small Teaching by James Lang if you are curious in learning more)."
  },
  {
    "objectID": "admin/syllabus.html#schedule",
    "href": "admin/syllabus.html#schedule",
    "title": "Course Syllabus",
    "section": "",
    "text": "Week\nTuesday’s Class\nThursday’s Class\nDue\n\n\n\n\n8/29\nIntro & Analog Behavior of Digital Systems\nCombinational and Sequential Logic\n(Lab Demos)\n\n\n9/5\nVerilog Coding\nSynchronous Design\nLab 1 - Development Board Assembly\n\n\n9/12\nFPGA Documentation\nArchitecture & Assembly Review\nLab 2 - Muxed 7-Segment Display\n\n\n9/19\nAssembly Programming\nC Programming on an MCU\nLab 3 - Keypad\n\n\n9/26\nClock Configuration\nTimers\nLab 4 - ARM Assembly Sort\n\n\n10/3\nSerial Interfaces Overview & SPI\nUART and the IoT\nLab 5 - Digital Audio\n\n\n10/10\nPCB Design\nAdvanced Encryption Standard (AES)\nLab 6 - SPI & The Internet of Things\n\n\n10/17\nHappy Fall Break! No Class\nProject Kickoff\n\n\n\n10/24\nGraphics and Displays\nMotors and Speakers\nLab 7 - AES & Project Proposal\n\n\n10/31\nInterrupts Pt. 1\nInterrupts Pt. 2\nProposal Debriefs\n\n\n11/7\nThe Fast Fourier Transform (FFT)\nDirect Memory Access\n\n\n\n11/14\nIntroduction to Real Time Operating Systems\nProject Status Report and Demo\nProject Status Reports & Demo\n\n\n11/21\nEmerging Topics in Embedded Systems\nHappy Thanksgiving! No class\n\n\n\n11/28\nPresentations\nPresentations\n\n\n\n12/5\nGuest Lecture: Benson Tsai ’06\nInterview Questions & Life Beyond Mudd\nProject Checkoffs, Report, Demo Day"
  },
  {
    "objectID": "admin/syllabus.html#recommended-texts",
    "href": "admin/syllabus.html#recommended-texts",
    "title": "Course Syllabus",
    "section": "",
    "text": "I assume you have a mastery of digital design at the level of E85; review Digital Design and Computer Architecture, ARM Edition (link) if you feel rusty on a topic. We will not be closely following a textbook, but you may find The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors by Joseph Yiu to be a helpful, comprehensive reference for the microcontroller. An electronic version of the book is available through the library (link)."
  },
  {
    "objectID": "admin/syllabus.html#grading",
    "href": "admin/syllabus.html#grading",
    "title": "Course Syllabus",
    "section": "",
    "text": "Item\nPercentage\n\n\n\n\nLabs\n50%\n\n\nFinal Project\n45%\n\n\nParticipation\n5%\n\n\n\n\nYour grade in the class is based on seven labs and a final project. You may have an extension of up to one week on one of your labs except for the final lab; otherwise, late work is not accepted. The last lab must be submitted on time in order to allow you to get started on your project. Your lowest lab score will have half the weight of the others. Labs are done individually. You are welcome to discuss them with other students or the instructor, but only after you have made an effort by yourself. Please list the names of other students you have worked with on your submissions. Although collaboration is strongly encouraged, you must turn in your own work, not work identical to that of another person. It is an honor code violation to simply copy someone else’s work. Solutions to past year’s labs have been handed out. It is also an honor code violation to refer to these solutions while doing your lab. The final project will be done in groups of two.\nThe deliverables for each lab will consist a brief written report which should include the following:\n\nAn overview which must not exceed one page, that provides a summary of the work, context for the other materials, an explanation of major design decisions, and a succinct explanation of whether the lab met requirements or how it deviates.\nSchematics of the circuits constructed for the lab. Use standard symbols for standard components, and be sure the schematic is sufficient for another engineer to reproduce your circuit.\nCode written for the lab.\nFigures that illustrate the output of the circuits or other results of the lab.\n\nThe purpose of these deliverables is to train you in professional, technical communication, so they will be held to high standards. All schematics must feature neat wiring, up to date values for every component, and ports labeled with both the pin and the signal associated with them. Figures must be readable and must include labeled axes and legends. Code should be commented; omit library code that is provided elsewhere. The report should be grammatically correct, succinct, tightly focused and complete. Properly referencing figures will help keep the report brief.\nWe will use Gradescope to collect lab submissions. Each lab should be submitted as a single PDF report including all written documentation.\nLabs are graded on a 7-point scale. 3 points are given for the system meeting its specified requirements and 3 points are given for the report, schematics, and code.\nThe last point for the lab grade is given for answering a fault tolerance question (FTQ). Students occasionally feel stressed about the FTQs, but these are designed to test the depth of your understanding about the concepts explored in the lab and simulate real world experience.\nThe final project will be done in groups of two. More information about the final project will be provided in the middle of the semester, but begin thinking now about who you might want to work with and begin brainstorming projects. You may see the course webpage for a listing of projects from previous years for inspiration. The final project is designed to give you a great deal of flexibility in choosing something you are interested in – the main requirement is that your project uses both the microcontroller and FPGA meaningfully to do something useful or interesting. Using the FPGA meaningfully is often the most difficult part so think about this carefully. You are more than welcome to discuss potential project ideas with me at any time.\nThe participation portion of your grade will be awarded for attending and engaging during class time and for completing various in-class activities. I put significant time and effort into making the most of the lecture periods we have together and hope that you also can bring a positive and enthusiastic attitude as we learn together this semester."
  },
  {
    "objectID": "admin/syllabus.html#lab-kit",
    "href": "admin/syllabus.html#lab-kit",
    "title": "Course Syllabus",
    "section": "",
    "text": "While there is not a textbook to purchase, you will need to buy a lab kit. The fee is $75 in Claremont Cash, and should be paid by filling out the Google Form (link) which authorizes Sydney Torrey in the Engineering office to charge your Claremont Cash account. Once you have paid for your kit via the form, see Sam Abdelmuati in the stockroom to pick up your kit. If you cook your board this semester, you can buy and rebuild a replacement, but ask the instructor for help troubleshooting first. You’ll also check out a large breadboard from the stockroom, and will need to return it at the end of the semester.\nThe kit fee can be waived in cases of financial hardship. To request a waiver fill out the form here (link). Course instructors will not know about waiver requests."
  },
  {
    "objectID": "admin/syllabus.html#lab-access",
    "href": "admin/syllabus.html#lab-access",
    "title": "Course Syllabus",
    "section": "",
    "text": "The Digital Lab (Parson B183) is available for you to use when working on your labs. The current door code will be shared on Slack when it is available. There are Windows PCs available with SEGGER Embedded Studio for ARM and Lattice Radiant installed along with the drivers required to program your board. The lab also has the electronics assembly equipment needed to solder, oscilloscopes and power supplies at the lab stations, and a lab cabinet with various resistors and some of the parts like wires, seven-segment LEDs, and transistors you will need for some of your labs. You are welcome to use these while working on your lab, but please make sure to return the components to the lab cabinet when you are done.\nIn addition, the software we will be using for programming the MCU (SEGGER Embedded Studio for ARM) and FPGA (Lattice Radiant) are free and supported on a variety of platforms if you wish to download them on your personal computer. SEGGER Embedded Studio is supported on Windows, MacOS, and Linux and Lattice Radiant is supported on Windows and Linux. If you are running MacOS, you can download and virtualize Windows using VMWare Fusion Player under a Personal Use License for free. More details and download links can be found here (link)."
  },
  {
    "objectID": "admin/syllabus.html#honor-code-violations",
    "href": "admin/syllabus.html#honor-code-violations",
    "title": "Course Syllabus",
    "section": "",
    "text": "Students in this class are expected to follow the HMC honor code. An honor code policy appears below and prescribes behavior that is considered honorable, so read those maxims and follow them closely. Any honor code violations will be handled through JB."
  },
  {
    "objectID": "admin/syllabus.html#honor-code-policy",
    "href": "admin/syllabus.html#honor-code-policy",
    "title": "Course Syllabus",
    "section": "",
    "text": "All students enrolled in this course are bound by the HMC Honor Code. More information on the HMC Honor Code can be found in the HMC Student Handbook.\nIt is your responsibility to determine whether your actions adhere to the HMC Honor Code. If this document does not clarify the legitimacy of a particular action, you should contact the course instructor and request clarification.\nWork you submit for individual assignments should be your own, and you should complete all assignments based on your own understanding of the underlying material. If you work with, or receive help from, another individual on an assignment, provide a written acknowledgement in complete sentences that includes the person’s name and the nature of the help.\nThis document is not meant to be an exhaustive list of every possible Honor Code violation. Infractions not explicitly mentioned here may still violate the Honor Code.\nBoundaries of Collaboration Verbal collaboration with other students on individual assignments is encouraged AFTER you have given serious thought to each component yourself. However, all submitted written work should be written by yourself individually, and not a collaborative effort or copied from a common source (e.g., a chalkboard). It is NOT acceptable to work on labs in lockstep with another classmate.\nUse of Computer Software The use of graphing calculators and computer software to aid in course work is acceptable, as long as it does not substitute for an understanding of the course material.\nUse of Web Resources The use of Internet resources to aid in course work is acceptable, as long it does not substitute for an understanding of the course material. Plagiarism and direct copying from online (or any other) sources is strictly prohibited.\nUse of Your Own Work from Previous Semesters If you have previously attempted this course, you may resubmit your work from previous semesters as this semester’s coursework, as long as you understand the underlying material.\nUse of Other Course Resources from Previous Semesters You may not reference assignments (labs, problem sets, activities) of this course from previous semesters.\nRetention of Course Resources Assignments and exams from this course may not be committed to dorm repositories or otherwise used to help future students."
  },
  {
    "objectID": "admin/syllabus.html#inclusiveness-and-harassment",
    "href": "admin/syllabus.html#inclusiveness-and-harassment",
    "title": "Course Syllabus",
    "section": "",
    "text": "We do difficult work in this class and everyone should feel comfortable engaging with the material. We explicitly want you to feel safe doing this work, so it is worth stating that the instructors are committed to making the class a safe space for everyone regardless of race, gender, ethnicity, sexual orientation, religion, and academic history. If you feel that you are experiencing a hostile environment, speak to an instructor immediately."
  },
  {
    "objectID": "admin/syllabus.html#educational-accessibility",
    "href": "admin/syllabus.html#educational-accessibility",
    "title": "Course Syllabus",
    "section": "",
    "text": "HMC is committed to providing an inclusive learning environment and support for all students. Students with a disability (including mental health, chronic or temporary medical conditions) who may need some accommodation in order to fully participate in this class are encouraged to contact Educational Accessibility Services at ability@g.hmc.edu to request accommodations. Students from the other Claremont Colleges should contact their home college’s disability resources officer."
  },
  {
    "objectID": "lab/lab6/specs.html",
    "href": "lab/lab6/specs.html",
    "title": "Lab 6 Specifications",
    "section": "",
    "text": "Design uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\n\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/lab6/specs.html#lab-6-specifications",
    "href": "lab/lab6/specs.html#lab-6-specifications",
    "title": "Lab 6 Specifications",
    "section": "",
    "text": "Design uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\n\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/specs/lab1-specs.html",
    "href": "lab/specs/lab1-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nDevelopment board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\nExcellence\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/specs/lab4-specs.html",
    "href": "lab/specs/lab4-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nAssembly program correctly sorts an array of signed bytes.\nBrief description of sort algorithm implemented.\nSEGGER Embedded Studio debugger used to demonstrate that the test array was sorted properly.\nAssembly code includes line-by-line comments\nCode is running on MCU connected to SEGGER Embedded Studio for instructor to verify operation with a test case of their choosing.\n\n\n\nExcellence\n\nReport identifies all possible edge cases for sorting and presents testing results to verify that the design performs correctly for all the edge cases you’ve identified. You can demonstrate this by showing screenshots of the intial (src) and final (dst) arrays in the watch window or memory viewer."
  },
  {
    "objectID": "lab/specs/index.html",
    "href": "lab/specs/index.html",
    "title": "Lab Specifications",
    "section": "",
    "text": "Lab 1 Specs\nLab 2 Specs\nLab 3 Specs\nLab 4 Specs\nLab 5 Specs\nLab 6 Specs"
  },
  {
    "objectID": "lab/specs/lab5-specs.html",
    "href": "lab/specs/lab5-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nDesign plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\nExcellence\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/specs/lab2-specs.html",
    "href": "lab/specs/lab2-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nHDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\nExcellence\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/lab1/index.html",
    "href": "lab/lab1/index.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab you will familiarize yourself with the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards we will be using this semester."
  },
  {
    "objectID": "lab/lab1/index.html#introduction",
    "href": "lab/lab1/index.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab you will familiarize yourself with the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards we will be using this semester."
  },
  {
    "objectID": "lab/lab1/index.html#learning-objectives",
    "href": "lab/lab1/index.html#learning-objectives",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nAssembled your development board for the class and tested out your MCU and FPGA boards.\nWritten a Verilog module to control LEDs and a 7-segment display.\nProgrammed the FPGA with Verilog code.\nGained confidence in building, assembling, testing, and debugging circuits.\nInterfaced a 7-segment display to the board."
  },
  {
    "objectID": "lab/lab1/index.html#requirements",
    "href": "lab/lab1/index.html#requirements",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Requirements",
    "text": "Requirements\nFollow the steps in this guide to test your FPGA and MCU boards. Write some Verilog code to exercise the FPGA using the switches, LEDs, and a 7-segment display to ensure your board is operational. Simulate and synthesize your code, then upload it to the flash memory and re-test the board. Hook up a 7-segment display and demonstrate that it works."
  },
  {
    "objectID": "lab/lab1/index.html#resources",
    "href": "lab/lab1/index.html#resources",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Resources",
    "text": "Resources\n\nStarter Code from GitHub Repo"
  },
  {
    "objectID": "lab/lab1/index.html#lab-1-specifications",
    "href": "lab/lab1/index.html#lab-1-specifications",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Lab 1 Specifications",
    "text": "Lab 1 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nDevelopment board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\nExcellence\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/lab1/index.html#before-you-start",
    "href": "lab/lab1/index.html#before-you-start",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Before You Start",
    "text": "Before You Start\nBefore you start working on this lab, you should familiarize yourself with the documentation for both the UPduino v3.1 and Nucleo-L432KC boards. The website has links for the UPduino v3.1 User Guide and the Nucleo-L432KC User Manuals on the Resources tab. These two documents contain information that will be helpful for answering questions that you may have during the course of this lab."
  },
  {
    "objectID": "lab/lab1/index.html#background",
    "href": "lab/lab1/index.html#background",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Background",
    "text": "Background\nIn the 1980’s and 1990’s, digital design projects were built from a truckload of chips, each containing a few logic gates such as 74xx series logic gates or simple programmable array logic chips (PALs). Such projects involve placing and wiring together dozens of chips on a breadboard. It was easy to make a wiring mistake or burn out a chip and spend hours tracking down the problem. Now you can perform all of your digital logic on a single field-programmable gate array (FPGA) to greatly reduce the necessary wiring and number of chips. Later in the course, you will use the Cortex-M4 microcontroller to write programs in assembly language and C that can interface with external hardware and the FPGA."
  },
  {
    "objectID": "lab/lab1/index.html#nucleo-l432kc-development-board",
    "href": "lab/lab1/index.html#nucleo-l432kc-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Nucleo-L432KC Development Board",
    "text": "Nucleo-L432KC Development Board\nThe Nucleo-L432KC development board provides a convenient platform to test and develop embedded systems applications. The board is focused around an STM32L432KC MCU and provides voltage regulators to provide power to the chip, various breakout headers which allow access to the pins of the microcontroller chip, a reset button and user input button, configuration jumpers, and an embedded ST-LINK programmer/debugger.\n\nProgramming\nThe STM32L432KC has an embedded ST-LINK/V2-1 programmer and debugger as described in the Nucleo-32 User Manual. The main purpose of the ST-LINK is to provide the ability to interface with the serial wire debug (SWD) interface of the MCU via USB.\nThere are a variety of integrated development environments (IDEs) which can be used to interact with the device including PlatformIO, Keil μVision, and SEGGER Embedded Studio. The IDEs provide a helpful wrapper around compiler toolchains such as GNU Compiler Collection (GCC) toolchain to facilitate easy programming and debugging. In this course you are welcome to use any IDE you would like, although instruction and support will be focused around SEGGER Embedded Studio which is based on the GCC toolchain.1"
  },
  {
    "objectID": "lab/lab1/index.html#upduino-v3.1-fpga-development-board",
    "href": "lab/lab1/index.html#upduino-v3.1-fpga-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "UPduino v3.1 FPGA Development Board",
    "text": "UPduino v3.1 FPGA Development Board\nThe UPduino v3.1 is developed by tinyvision.ai and designed around a Lattice Semiconductor UP5K field programmable gate array (FPGA). Section 5.3 of the iCE40 UltraPlus Family Data Sheet (FPGA-DS-02008-2.0) explains the naming of the chip.\n\n\n\n\n\n\nFigure 1: ice40 Part Number Description\n\n\n\nThe Lattice UP5K is very similar to the Cyclone IV architecture that is used to introduce FPGAs in E85. At its root, the FPGA consists of Logic Cells (Lattice’s version of the Intel/Altera Logic Elements you learned about in E85) which can be internally connected within Programmable Logic Blocks (PLBs) within the FPGA to form digital circuits. Each Logic Cell (LC) consists of a 4-input look-up table (LUT) and a programmable D flip-flop, along with additional clock control and carry logic. Figure 3.2 from the FPGA datasheet shows the basic architecture of a PLB and LC.\n\n\n\n\n\n\nFigure 2: ice40 PLB Block Diagram.\n\n\n\nThe UP5K on our UPduino v3.1 board is the 48-pin QFN package. As you can see from the table, it contains 5280 logic cells, 30 Embedded Block Ram (EBR) Memory Blocks of 4 Kbits each, 4 256-bit Single Port synchronous RAM Memory Blocks, and an on-board high-frequency (48 MHz) and low-frequency (10 kHz) oscillator.\n\n\n\n\n\n\nFigure 3: ice40 Resource Table.\n\n\n\n\nDigital Design Synthesis and Programming\nThe FPGA is programmed using the onboard programmer via the synthesis tool Lattice Radiant. After setting up and compiling the Radiant project, Radiant will generate bitstream files which are used to configure the FPGA.\nMore details will be provided later in this lab writeup."
  },
  {
    "objectID": "lab/lab1/index.html#e155-fa22-development-board",
    "href": "lab/lab1/index.html#e155-fa22-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "E155 FA22 Development Board",
    "text": "E155 FA22 Development Board\nIn this lab you will assemble a custom printed circuit board which hosts the MCU and FPGA boards. The board has several features that will be convenient for developing embedded systems such as:\n\nPins which can be directly routed from the MCU to the FPGA via the board\nExtension headers for the mikroBUS and 6-pin PMOD standard\nUser configurable LEDs, pushbuttons, and slider switches.\nHeader to route pins via a ribbon cable to a separate breadboard adapter PCB which can be inserted into a solderless breadboard.\n\n\n\n\n\n\n\nFigure 4: Annotated sections of the development board.\n\n\n\nThe board has several main sections that you should make yourself aware of. They are annotated in the image above.\n\nVoltage Regulators and Power Terminal: A +5 V (NCP1117DT50RKG) and +3.3 V (NCP1117DT33T5G) low-dropout (LDO) voltage regulator which is used to regulate the input provided via the power terminal on VIN. Make sure to check with the schematic to ensure that you put the regulators in their proper places. See Powering the Board for more details.\nFPGA, MCU, mikroBUS, and PMOD sockets: These sockets are populated with female headers for the MCU, FPGA, and other extension sockets to be plugged into.\nReset Push Buttons: The reset pushbuttons are connected to the reset inputs on the MCU and FPGA respectively. The MCU reset button will cause the code to begin execution from the first instruction. The FPGA reset button causes the FPGA to reconfigure itself from the on-board RAM which stores the configuration file for the design you have uploaded.\nConfiguration Jumpers: The configuration jumpers on the board allow you several options to set the power and signal connections for the MCU and FPGA. J2, J3, and J4 control the mikroBUS reset signal and the power for the FPGA and MCU boards respectively. The mikroBUS reset signal can also be connected to MCU pin PA12 to enable the MCU to reset the connected peripheral via software. The configuration jumper J5 is a 2x8 header with MCU pins on the left hand side and FPGA pins on the right hand side. Note that on the 2023 version of the board, J5 has been replaced with an 8-pin DIP switch with the reference designator SW7. The functionality however, remains the same as the jumper. By attaching a jumper between the pins in the same row, the MCU pin on the left side of the jumper can be directly routed to the FPGA pin on the right hand side via traces on the PCB. This allows for convenient and high-fidelity interfaces between the MCU and the FPGA without the need for external wires.\nRibbon Cable Connector: The ribbon cable connector is used to route a subset of the MCU and FPGA pins out to a cable which connects to the breadboard adapter board.\nMCU, FPGA, and Slide Buttons: The push and slide buttons on the board are routed to pins on the MCU and FPGA in order to provide on-board options to toggle GPIO pins on the respective devices. Note that all of these buttons are configured as active low (i.e., closing the switch connects the pin of the device to ground) without any hardware pullup resistors. In order to use them, you must configure the internal pullup resistors on the MCU or FPGA in order to avoid floating logic levels."
  },
  {
    "objectID": "lab/lab1/index.html#assembling-the-board",
    "href": "lab/lab1/index.html#assembling-the-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Assembling the Board",
    "text": "Assembling the Board\nIn this section you will walk through the steps to assemble your board. The PCB has both through hole technology (THT) and surface mount technology (SMT) parts. SMT parts are generally preferred on PCBs since they are more compact and easier for machines to solder although THT parts are typically easier for beginners to solder. If you haven’t done much (or any!) SMT soldering before, don’t worry! One of the points of this lab is to give you a chance to develop this skill!\nAll the parts you need to build your board are provided in your kit bag. Typically, it is easiest to start with the SMT parts before soldering the THT parts since the board will lay flat. So we’ll start by soldering the SMT components."
  },
  {
    "objectID": "lab/lab1/index.html#assembly-tips",
    "href": "lab/lab1/index.html#assembly-tips",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Assembly Tips",
    "text": "Assembly Tips\nSoldering is a skill that you need to practice just like anything else. The most important thing to remember when soldering is that it is roughly 100x easier to solder than to desolder a component. So, whenever possible, make sure that you align the component correctly before soldering all the pins. Often the best way to do this is to solder a single pin on one side and then confirm that the component is correctly aligned before soldering the rest of the pins. If something is misaligned, then this will make it easy to correct since you only will need to reflow a single solder joint. A few additional tips:\n\nSoldering often will make you wish you had another hand or two. Soldering SMT components in particular can be a bit tricky because you need to hold the component with tweezers to align it. A good strategy is to first melt a little bit of solder on one of the pads and then grab the component with tweezers while holding the iron in your other hand to reflow the solder and align it.\nWhen soldering THT headers like those used for the sockets, make sure that the headers are oriented correctly (most of the time perpendicular to the PCB surface). One tip is to insert a strip of male headers into a breadboard and then attach the female headers and set the PCB upside down on top of the male headers to solder them. If you do end up making a mistake and need to desolder a strip of header pins, the plastic shroud can be removed in order to let you pull out individual pins. See this YouTube video for an example. Although in the video he shows the example for a male header pin strip, you can do the same thing with a female strip as well."
  },
  {
    "objectID": "lab/lab1/index.html#suggested-soldering-order",
    "href": "lab/lab1/index.html#suggested-soldering-order",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Suggested Soldering Order",
    "text": "Suggested Soldering Order\nBelow is a recommended soldering order.\n\nSolder the voltage regulators. Put a bit of solder on the big square pad and reflow while bringing the regulator on top in order to solder it. You can apply heat to the pad via the metal edge at the top of the regulator.\n\n\n\n\n\n\n\nFigure 5: Voltage regulator soldering procedure.\n\n\n\n\nPrepare to solder the remaining SMT components (resistors, capacitors, and LEDs) by applying a small amount of solder to one pad of the SMT footprints R1-R11, C1-C4, and D1-D8..\nSolder the decoupling (also known as bypass) capacitors C1-C4 around the regulators. These are used to smooth out any transients and ensure smooth, constant voltages. These capacitors have no polarity, so either way is fine.\nNext, solder the resistors on the board. Pay careful attention to make sure that you solder the correct resistors by referring to the board schematic (available on the course website).\nNext solder the LEDs. The LEDs are polarized, so you’ll need to make sure to solder them the right direction or they won’t work. There is an arrow on the bottom of the package which indicates the direction of the current flow from the anode to the cathode. Again, refer to the schematic for proper alignment. When looking at the PCB with the text facing upright, the cathode should go on the left hand side (connected to its current limiting resistor). There are three different color LEDs. D1 is red (VIN), D2-D5 are green (connected to the MCU), and D6-D8 are blue (connected to the FPGA). After finishing this step, you are finished with all the SMT components!\n\n\n\n\n\n\n\nFigure 6: LED and current limiting resistors.\n\n\n\n\nNow it’s time to tackle the THT components. Put the components into their respective places and solder them in. Pay careful attention to ensure that the female header strips are correctly aligned and perpendicular to the board. You will need to snap off 2- and 3-pin headers from the provided 40-pin header strip in order to populate J2-J4. The easiest way to do this is to use a pair of needle nose pliers to snap off the right number of pins.\nAfter finishing the main development board, follow the same procedure to assemble the breadboard adapter PCB.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Make sure the notches are both pointing the same direction.\n\n\n\n\n\n\n\n\n\n\n\n(b) The triangle on the connector should match with the red wire in the ribbon cable.\n\n\n\n\n\n\n\n\n\n\n\n(c) Crimping alignment.\n\n\n\n\n\n\n\nFigure 7: Ribbon cable alignment procedure.\n\n\n\nUse the included insulation-displacement contact (IDC) ribbon cable connectors and the spool of ribbon cable in the lab to make yourself a short (~6-12”) cable. You have probably done this before in E80, but if you don’t remember how, see the video here. Cut the cable to length with the flush cutters in the toolbox and use either a vise or the cable assembly tool found in the E155 cabinet. Please make sure to put it back after you are finished. If you can’t find it around the lab, ask an instructor.\nFinally, solder the 20-pin male headers and 2x20 pin cable connector onto the breadboard adapter PCB, making sure that the pins are all correctly aligned and perpendicular to the PCB.\nCongratulations, you are now finished assembling your board and ready to test it! The photo below shows an example of what the board should look like when it is finished.\n\n\n\n\n\n\nFigure 8: Fully assembled development board."
  },
  {
    "objectID": "lab/lab1/index.html#powering-the-board",
    "href": "lab/lab1/index.html#powering-the-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Powering the Board",
    "text": "Powering the Board\nThere are three different ways to power the components on the development board: (1) via the VIN power input, (2) via the FPGA’s USB connection, and (3) via the MCU’s USB connection. In this section we will walk through the various ways to power the board to make sure that you are aware of how to properly power the board and avoid any issues which might damage the components on board.\nThe +5 V and +3.3 V voltage regulators provide power for the various components. All logic levels are +3.3 V unless stated otherwise. So, the +3.3 V supply is used to power the various buttons on the board.\n\nPowering through VIN\nTo power through VIN, apply a voltage to the power screw terminal between VIN and GND. The NCP117 series can accept voltages up to +20 V but in most scenarios you will likely want to use a VIN between +6-12 V. Be aware that VIN should always be more than +5 V for both regulators to function properly. When powering via VIN, the jumpers J3 (FPGA_+5V) and J4 (MCU_+5V) should be shorted in order to apply the +5 V output from the regulator to the MCU and FPGA +5 V pin.\n\n\nPowering via USB\nIt is also possible to power the board via a USB connection to either the MCU or FPGA board. Each board has an onboard voltage regulator to create a stabilized +5 V output on the boards respective +5 V pins. Assuming J3 and J4 are shorted, this +5 V output from whichever board is connected to USB power is fed back to the +5 V line (which is also the output of the +5 V regulator) and thus powers the other components connected to that net.\n\nTesting Voltage Regulators: Before connecting your MCU and FPGA boards, check the voltage regulators are on correctly by connecting to a lab DC power supply using the screw terminals and using a multimeter to confirm that the +3.3 V rail is +3.3 V and the +5 V rail is +5 V. If you read +5 V on the +3.3 V or vice versa, you have installed the regulators in the wrong place and need to swap them. If you read a low voltage (less than ~0.1 V), you likely have a bad solder joint on the back pad of the respective regulator and need to reflow the solder joint to make a better connection."
  },
  {
    "objectID": "lab/lab1/index.html#testing-the-boards",
    "href": "lab/lab1/index.html#testing-the-boards",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing the Boards",
    "text": "Testing the Boards\nTo test the boards, you will upload a simple design to the FPGA which toggles an LED on and off and some code on the MCU to read in the toggling GPIO pin and echo is back to the FPGA. This will ensure that the board is working properly and that you have good communication between the two devices.\nTo familiarize yourself with how to program the FPGA using Lattice Radiant, see the Lattice Radiant iCE40 UltraPlus Project Setup tutorial. This tutorial has information about how to create a project in Radiant and how to synthesize and upload designs to your FPGA board.\nAfter working through the tutorial, download the Radiant project file fpga_dev_board_test.zip under the Lab 1 subfolder from the course GitHub (the link on the course website lab page) and use it to program your FPGA. This design toggles pin P25 at about 1 Hz. If you have the switch properly set on SW7, P25 is connected to PA9 and so you will see LED D3 blinking.\nAfter programming your FPGA, the next step is to upload the code to the MCU that will read the value of the toggled LED from the FPGA and echo it back on another pin. See the tutorial titled “Segger Embedded Studio Setup” to familiarize yourself with the process of installing and setting up SEGGER Embedded Studio (SES) for ARM. If you are using a lab computer, SES is already installed. Make sure that you use the ARM version of the program. The lab computers may also have other versions installed.\nAfter working through the tutorial, download the SES solution folder from the course GitHub titled “mcu_dev_board_test.zip”. Then, double click on the .emProject file or use the File → Open Solution option in SES to open the solution. This project contains a simple program that monitors the status of PA9 (which is connected to P25 through the appropriate jumper on J5. Make sure you have the jumper attached to connect PA9 to P25). Build and download the project to your MCU.\nNow, in addition to LED D3 (PA9/P25) blinking, you should see LED D2 (PA10/P23) and LED D7 (P38) blinking as well."
  },
  {
    "objectID": "lab/lab1/index.html#what-to-turn-in",
    "href": "lab/lab1/index.html#what-to-turn-in",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "What to Turn In",
    "text": "What to Turn In\nFor this lab and all subsequent ones you will turn in a lab report. The report should not exceed one page of text, plus schematics, code, and anything else appropriate, such as diagrams, simulation results, or calculations. The report typically has the following sections:\n\nIntroduction: Briefly explain what was done.\nDesign and Testing Methodology: Explain how you approached the design of this assignment from both a software and a hardware standpoint (as appropriate). Include how you tested your design. These tests should convince the reader that the requirements of the assignment have been met.\nTechnical Documentation: Include your Verilog code and schematics of your circuits.\n\nQuality and clarity of your code is important. Make sure it is adequately commented. Succinct code using standard idioms is best.\nSchematics of your breadboarded circuits should be sufficient for another engineer to understand and reconstruct the circuit on the breadboard. Always use standard symbols for standard components such as resistors, switches, transistors, diodes, etc. Give the component name or part number such that the reader could order parts and replicate your circuit, or look up components in a datasheet where necessary. The reader shouldn’t have to open you HDL synthesis program to relate your Verilog code to the schematic, and shouldn’t need to refer to a data sheet to wire external components or understand what the connections are. Don’t assume that the reader has memorized the pinouts of any chips. Therefore, you’ll need to label both the pin number and pin name for each pin you use from the FPGA board or other component (e.g., 7-segment display). There is no need to draw any of the circuitry on the board; just refer to it by the pins number and name.\n\nResults and Discussion: Did you accomplish all of the prescribed tasks? If not, what are the shortcomings? How might you address them given more time? As appropriate, how did the design perform (ex. How fast/accurate/reliable was it?). Is there anything you would do differently if you were to redo the lab? Is there anything else interesting worth mentioning?\nConclusions: Briefly summarize what was done and how it performed.\nHow many hours did you spend working on the lab? Any comments, suggestions, or complaints about the assignment? This will not count toward your grade, but will help refine the lab for the future.\n\nThe report does not need to be long but should be complete. Some individual questions may not apply to this particular lab but are listed to give you a general idea of what is desired. Future reports will follow a similar format and the questions may be more applicable in these instances.\nHave your lab checked off by the instructor. You will need to demonstrate that the board and 7-segment display operate correctly. You will also be asked a question about some part of the lab or your board. You should be thoroughly familiar with all of the lab and the components of your board to be able to answer the question. The oral exam is typically in the form of a “Fault-Tolerance Question.” What would happen if a particular wire is broken or a pin is shorted to Vcc or GND? Be prepared for any other questions about your lab, however."
  },
  {
    "objectID": "lab/lab1/index.html#faq-and-hints",
    "href": "lab/lab1/index.html#faq-and-hints",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "FAQ and Hints",
    "text": "FAQ and Hints\nIf some of you are seeing issues with specific pins on your FPGA there could be a few different reasons and corre- sponding steps to take to troubleshoot.\n\nYou could have an electrical short which is causing some pins to be electrically connected that should not due to solder bridges. Double check to make sure that the pins are isolated and not connected together by checking the resistance between the pins with a multimeter.\nYou are trying to use a pin that is shared between the FPGA and the MCU and the MCU is not leaving that pin floating or it is driving it as an output. You can get around this by wiping the code on the MCU by uploading a file with a blank main function.\nYou should also read through the Nucleo board documentation to see what pins have special functions that are used by default by the MCU. Hint: You likely want to stay away from using the pins that the MCU uses for serial communication by default."
  },
  {
    "objectID": "lab/lab1/index.html#always-very-curious",
    "href": "lab/lab1/index.html#always-very-curious",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Always Very Curious…",
    "text": "Always Very Curious…\nIf you finish the lab and are interested in exploring some additional functionality of your FPGA, consider trying to write HDL to control the RGB LEDs on board the UPduino. Note that this is NOT a required part of the lab and not for credit. It is purely an exercise if you have interest!\nThe UP5K has built in hardware for pulse-width modulation of the LED. To find details on how to use this IP, use the “Lattice Radiant Software Help” guide that is accessible from the Help menu in Radiant. In the window that opens, navigate to the section “Reference Guides &gt; FPGA Libraries Reference Guide &gt; Miscellaneous.” You can also find information about this and other hardware primitives available on the FPGA in the “iCE40 Technology Library” PDF available on the course website. However, note that (annoyingly!) the naming for the modules in this document is for the iCEcube2 software and the syntax has changed for Radiant. You can see the note “Migrating iCEcube2 iCE40 UltraPlus Designs to Lattice Radiant 2.0 Software” for more details."
  },
  {
    "objectID": "lab/lab1/index.html#footnotes",
    "href": "lab/lab1/index.html#footnotes",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn order for the NUCLEO board to be compatible with SEGGER, it is necessary to reflash the ST-LINK programmer with SEGGER J-Link firmware to convert it to a J-Link. This has been already taken care of on the board in your kit, but if you want to use another STM32 board with SEGGER you’ll need to follow the instructions here to do this yourself.↩︎"
  },
  {
    "objectID": "lab/lab3/specs.html",
    "href": "lab/lab3/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Circuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/lab3/specs.html#lab-3-specifications",
    "href": "lab/lab3/specs.html#lab-3-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Circuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/lab7/specs.html",
    "href": "lab/lab7/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "AES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\n\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/lab7/specs.html#lab-7-specifications",
    "href": "lab/lab7/specs.html#lab-7-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "AES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\n\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/lab4/specs.html",
    "href": "lab/lab4/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Assembly program correctly sorts an array of signed bytes.\nBrief description of sort algorithm implemented.\nSEGGER Embedded Studio debugger used to demonstrate that the test array was sorted properly.\nAssembly code includes line-by-line comments\nCode is running on MCU connected to SEGGER Embedded Studio for instructor to verify operation with a test case of their choosing.\n\n\n\n\n\nReport identifies all possible edge cases for sorting and presents testing results to verify that the design performs correctly for all the edge cases you’ve identified. You can demonstrate this by showing screenshots of the intial (src) and final (dst) arrays in the watch window or memory viewer."
  },
  {
    "objectID": "lab/lab4/specs.html#lab-4-specifications",
    "href": "lab/lab4/specs.html#lab-4-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Assembly program correctly sorts an array of signed bytes.\nBrief description of sort algorithm implemented.\nSEGGER Embedded Studio debugger used to demonstrate that the test array was sorted properly.\nAssembly code includes line-by-line comments\nCode is running on MCU connected to SEGGER Embedded Studio for instructor to verify operation with a test case of their choosing.\n\n\n\n\n\nReport identifies all possible edge cases for sorting and presents testing results to verify that the design performs correctly for all the edge cases you’ve identified. You can demonstrate this by showing screenshots of the intial (src) and final (dst) arrays in the watch window or memory viewer."
  },
  {
    "objectID": "lab/lab5/specs.html",
    "href": "lab/lab5/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Design plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\n\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/lab5/specs.html#lab-5-specifications",
    "href": "lab/lab5/specs.html#lab-5-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Design plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\n\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/lab2/specs.html",
    "href": "lab/lab2/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "HDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\n\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/lab2/specs.html#lab-2-specifications",
    "href": "lab/lab2/specs.html#lab-2-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "HDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\n\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/lab2/index.html",
    "href": "lab/lab2/index.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA."
  },
  {
    "objectID": "lab/lab2/index.html#introduction",
    "href": "lab/lab2/index.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA."
  },
  {
    "objectID": "lab/lab2/index.html#learning-objectives",
    "href": "lab/lab2/index.html#learning-objectives",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nImplemented a time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins.\nBuilt a simple transistor circuit to drive large currents from the FPGA pins.\nPracticed your ability to build Verilog systems in a modular way."
  },
  {
    "objectID": "lab/lab2/index.html#requirements",
    "href": "lab/lab2/index.html#requirements",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Requirements",
    "text": "Requirements\nDisplay two independent hexadecimal numbers on your dual seven-segment display. Use a DIP switch and four other input pins (possibly connected to a DIP switch on a breadboard) to provide the data for two hexadecimal numbers. You must use a single seven-segment decoder HDL module to drive the cathodes for both digits on the display, which therefore must be wired for multiplexed operation. Also, display the sum of the numbers on five LEDs. The seven segment display should be oriented to display the numbers upright to the viewer."
  },
  {
    "objectID": "lab/lab2/index.html#lab-2-specifications",
    "href": "lab/lab2/index.html#lab-2-specifications",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Lab 2 Specifications",
    "text": "Lab 2 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nHDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\nExcellence\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/lab2/index.html#discussion",
    "href": "lab/lab2/index.html#discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Discussion",
    "text": "Discussion\nTime-multiplexing is a technique to share a common expensive hardware resource for several purposes at different times. For example, the multicycle processor in E85 multiplexed the memory for both instruction and data access and multiplexed the ALU for data processing instructions, branch calculations, and program counter increments.\nIn this lab, you will time-multiplex your seven-segment decoder module to run both halves of a dual display. A convenient way to control which half is active is to turn ON the common anode of only one display at a time. The anode requires substantial current, more than an FPGA output pin can drive. You can use a transistor to drive the large current. The lab has a stock of 2N3906 PNP transistors suitable for this purpose. Be sure to limit the base current so that you don’t draw too much current from the FPGA pin and choose a suitable switching speed. If you switch too slowly, your eye will notice the flicker. If you switch too fast for the electronics, the two digits will bleed together."
  },
  {
    "objectID": "lab/lab2/index.html#hints",
    "href": "lab/lab2/index.html#hints",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Hints",
    "text": "Hints\nLook at your RTL schematic in your synthesis tool (Tools -&gt; Netlist Analyzer). Understand why your code produces the hardware you see. Be sure your combinational logic doesn’t have any registers. Be sure your logic has no latches or tristate buffers. The oscilloscope is handy for tracking down timing problems."
  },
  {
    "objectID": "lab/lab5/index.html",
    "href": "lab/lab5/index.html",
    "title": "Lab 5: Digital Audio",
    "section": "",
    "text": "In this lab you will use your MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations."
  },
  {
    "objectID": "lab/lab5/index.html#introduction",
    "href": "lab/lab5/index.html#introduction",
    "title": "Lab 5: Digital Audio",
    "section": "",
    "text": "In this lab you will use your MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations."
  },
  {
    "objectID": "lab/lab5/index.html#learning-objectives",
    "href": "lab/lab5/index.html#learning-objectives",
    "title": "Lab 5: Digital Audio",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nBuilt a circuit to enable an I/O pin from your MCU to drive a speaker\nImplemented the timer functionality available on the MCU by reading the datasheet and writing your own library in C from scratch"
  },
  {
    "objectID": "lab/lab5/index.html#requirements",
    "href": "lab/lab5/index.html#requirements",
    "title": "Lab 5: Digital Audio",
    "section": "Requirements",
    "text": "Requirements\nBuild a system to play music on a speaker. Use your MCU, an LM386 audio amplifier, and an 8-ohm speaker. The MCU should read a list of notes specifying the pitch (in Hz) and duration (in ms) of each note. It should generate a corresponding sequence of square waves. A frequency of 0 indicates a rest (silence for the given duration). A duration of 0 indicates the end of the song. Your system should play accurate pitches regardless of the frequency. Test your system on the score of Für Elise, which is provided. Your code should manually define #define macros and register structures for the memory-mapped registers you need to manipulate to help you practice developing your own device drivers from scratch using only the reference manual as a reference. In particular, this means that you are not allowed to use the CMSIS headers for your device."
  },
  {
    "objectID": "lab/lab5/index.html#resources",
    "href": "lab/lab5/index.html#resources",
    "title": "Lab 5: Digital Audio",
    "section": "Resources",
    "text": "Resources\n\nStarter Code from GitHub Repo"
  },
  {
    "objectID": "lab/lab5/index.html#lab-5-specifications",
    "href": "lab/lab5/index.html#lab-5-specifications",
    "title": "Lab 5: Digital Audio",
    "section": "Lab 5 Specifications",
    "text": "Lab 5 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nDesign plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\nExcellence\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/lab5/index.html#discussion",
    "href": "lab/lab5/index.html#discussion",
    "title": "Lab 5: Digital Audio",
    "section": "Discussion",
    "text": "Discussion\nYou can find lab5_starter.c on the class web page with the Für Elise score provided as an array of ordered pairs of pitch frequencies and durations.\nA goal of this lab is for you to learn to interpret a datasheet and figure out how the timer works. Write your own code from scratch to use the system timer.\nThe GPIO pins don’t generate enough output current to play satisfactory music directly on the speaker, so use an LM386 audio amplifier between the MCU and the speaker. Do not connect the MCU directly to the speaker, as the current draw could damage it. The datasheet shows AC coupling from the amplifier to the speaker, but you can leave out the capacitors and resistors and produce an acceptable square wave. Volume control is optional (but recommended for your own sanity and that of your roommates and labmates). There are only a limited number of speakers available in the lab so please leave the speakers in the supply cabinet when you leave the lab. Do not leave them attached to your breadboard when you are done working. If you kill a speaker, throw it away rather than putting it back in the cabinet for your unfortunate classmates."
  },
  {
    "objectID": "lab/lab5/index.html#optional-exercise",
    "href": "lab/lab5/index.html#optional-exercise",
    "title": "Lab 5: Digital Audio",
    "section": "Optional Exercise",
    "text": "Optional Exercise\nIn the past students have enjoyed composing their own tune to play on their MCU. The following information may help if you wish to compose your own piece of music.\nThe duration depends on an arbitrary choice of tempo (speed at which the piece is played). If a whole note is chosen to be 1/2 a second long, other notes follow accordingly:\n\n\n\n\nNote Type\nDuration [s]\n\n\n\n\nWhole\n0.5\n\n\nHalf\n0.25\n\n\nQuarter\n0.125\n\n\nEighth\n0.0625\n\n\nSixteenth\n0.03125\n\n\n\n\nRecall that the A above middle C (called A4) is 440 Hz (at least in the United States) and that an octave spans a factor of 2 in frequency. There are twelve notes in an octave spaced evenly on a geometric scale, so each is separated in frequency by a factor of 21/12.\n\n\n\n\nNote\nFrequency (Hz)\n\n\n\n\nA3\n220\n\n\nA3 sharp / B3 flat\n233.1\n\n\nB3\n246.9\n\n\nC4 (middle C)\n261.6\n\n\nC4 sharp / D4 flat\n277.2\n\n\nD4\n293.7\n\n\nD4 sharp / E4 flat\n311.1\n\n\nE4\n329.6\n\n\nF4\n349.2\n\n\nF4 sharp / G4 flat\n370.0\n\n\nG4\n392.0\n\n\nG4 sharp / A4 flat\n415.3\n\n\nA4\n440\n\n\nA4 sharp / B4 flat\n466.2\n\n\nB4\n493.9\n\n\nC5\n523.3\n\n\nC5 sharp / D5 flat\n554.4\n\n\nD5\n587.3\n\n\nD5 sharp / E5 flat\n622.2\n\n\nE5\n659.2\n\n\nF5\n698.4\n\n\nF5 sharp / G5 flat\n740.9\n\n\nG5\n784.0\n\n\nG5 sharp / A5 flat\n830.6\n\n\nA5\n880"
  },
  {
    "objectID": "lab/lab5/index.html#what-to-turn-in",
    "href": "lab/lab5/index.html#what-to-turn-in",
    "title": "Lab 5: Digital Audio",
    "section": "What to Turn In",
    "text": "What to Turn In\nWhen you are done, have your lab checked off by the instructor. You should thoroughly understand how it works and what would happen if any changes were made. Turn in your lab writeup including the following information:\n\nSchematics of the breadboarded circuit.\nYour source code.\nHow many hours did you spend on this lab? This will not count toward your grade."
  },
  {
    "objectID": "lab/lab5/index.html#credits",
    "href": "lab/lab5/index.html#credits",
    "title": "Lab 5: Digital Audio",
    "section": "Credits",
    "text": "Credits\nThis lab was originally developed in 2015 by Alex Alves ’16, redesigned for the μMudd Mark 5.1 in 2019 by Caleb Norfleet ’21, and redesigned for the μMudd MkVI in Fall 2021 by Prof. Josh Brake."
  },
  {
    "objectID": "lab/lab4/index.html",
    "href": "lab/lab4/index.html",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "",
    "text": "In this lab you will learn how to write ARM assembly code to write a simple sorting algorithm."
  },
  {
    "objectID": "lab/lab4/index.html#introduction",
    "href": "lab/lab4/index.html#introduction",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "",
    "text": "In this lab you will learn how to write ARM assembly code to write a simple sorting algorithm."
  },
  {
    "objectID": "lab/lab4/index.html#learning-objectives",
    "href": "lab/lab4/index.html#learning-objectives",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have:\n\nWritten a simple assembly program to sort an array of signed bytes\nUsed the debugger in SEGGER Embedded Studio to monitor a location in memory."
  },
  {
    "objectID": "lab/lab4/index.html#requirements",
    "href": "lab/lab4/index.html#requirements",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "Requirements",
    "text": "Requirements\nWrite an ARM assembly-language program to sort an array of 12 signed bytes on your MCU."
  },
  {
    "objectID": "lab/lab4/index.html#resources",
    "href": "lab/lab4/index.html#resources",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "Resources",
    "text": "Resources\n\nStarter Code from GitHub Repo"
  },
  {
    "objectID": "lab/lab4/index.html#lab-4-specifications",
    "href": "lab/lab4/index.html#lab-4-specifications",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "Lab 4 Specifications",
    "text": "Lab 4 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nAssembly program correctly sorts an array of signed bytes.\nBrief description of sort algorithm implemented.\nSEGGER Embedded Studio debugger used to demonstrate that the test array was sorted properly.\nAssembly code includes line-by-line comments\nCode is running on MCU connected to SEGGER Embedded Studio for instructor to verify operation with a test case of their choosing.\n\n\n\nExcellence\n\nReport identifies all possible edge cases for sorting and presents testing results to verify that the design performs correctly for all the edge cases you’ve identified. You can demonstrate this by showing screenshots of the intial (src) and final (dst) arrays in the watch window or memory viewer."
  },
  {
    "objectID": "lab/lab4/index.html#instructions",
    "href": "lab/lab4/index.html#instructions",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "Instructions",
    "text": "Instructions\n\nProject Setup\nSet up a project in SEGGER Embedded Studio for your MCU. Once your project is created, download the starter code and put it in your src folder or create a new file inside your src directory titled sort.s and copy in the contents of the starter code.\nFinish writing the assembly language subroutine under label main in sort.S to sort 12 signed bytes (the ones on the .byte … line under arr). Remember that assembly language code is nearly unreadable without line- by-line comments. If needed, use online reference sheets for ARM Thumb2 Assembly language (like the one linked on the course website) or refer to Chapter 6 of Digital Design and Computer Architecture.\n\nNote: If you are running code on your Nucleo while it is connected to the development board, make sure that you remove the UPduino_+5V jumper to avoid powering the FPGA. Also note that you must have the MCU_+5V jumper connected in order to power the voltage regulators and ensure that the MCU reset signal is pulled high.\n\n\n\nRunning and Testing Your Code\nBuild your code and enter a debug session. With the MCU board connected via USB, start a debugging session by going to the debug section of the sidebar and pressing the green arrow in the top of the menu (or by using the keyboard shortcut F5).\nExamine the memory location where the array of signed bytes has been loaded using the memory location viewer. The memory viewer is normally located near the bottom of the program window, but if you can’t find it, you can access it through the “View” menu in the program toolbar.\nYou may also choose to use the “Watch” section of the debugger. For example, if you want to view the contents of the byte array stored in memory, you can enter *(char[12] *) arr as a Watch expression. This tells the watch window to cast the address of the arr label to a pointer to a character and dereference 12 consecutive values from that memory location.\n\n\n\n\n\n\nFigure 1: SEGGER Embedded Studio (SES).\n\n\n\nStep through the operation of your program and see how it changes the values of the array stored in memory.\nTo test your code, try various cases with the array in the .byte... line under the arr label. Rebuild and start a new debug session every time you make changes."
  },
  {
    "objectID": "lab/lab4/index.html#what-to-turn-in",
    "href": "lab/lab4/index.html#what-to-turn-in",
    "title": "Lab 4: ARM Assembly Sort",
    "section": "What to Turn In",
    "text": "What to Turn In\n\nA short writeup of your design approach and the sort algorithm you chose to implement.\nA copy of your assembly code file sort.s.\nA listing of the test cases you used and the output of the tests. Be sure your tests would convince a skeptic that your algorithm works.\nFor your lab checkoff, please have your lab set up and connected to a running debugger session so that the instructor may provide a test case for your code.\nHow many hours did you spend on this lab?"
  },
  {
    "objectID": "lab/lab7/index.html",
    "href": "lab/lab7/index.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "By the end of this lab you will have…\n\nLearned to read and implement a complex specification\nBuilt a nontrivial system on an FPGA that requires thoughtful architecture to fit on the chip\nDesigned and implemented an interface to communicate between the FPGA and microprocessor on your MCU\nLearned how to use a logic analyzer to analyze and debug your system\nGained experience with hardware accelerators"
  },
  {
    "objectID": "lab/lab7/index.html#learning-objectives",
    "href": "lab/lab7/index.html#learning-objectives",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "By the end of this lab you will have…\n\nLearned to read and implement a complex specification\nBuilt a nontrivial system on an FPGA that requires thoughtful architecture to fit on the chip\nDesigned and implemented an interface to communicate between the FPGA and microprocessor on your MCU\nLearned how to use a logic analyzer to analyze and debug your system\nGained experience with hardware accelerators"
  },
  {
    "objectID": "lab/lab7/index.html#requirements",
    "href": "lab/lab7/index.html#requirements",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Requirements",
    "text": "Requirements\nConstruct a hardware accelerator to perform 128-bit AES encryption. Send a plaintext message and key from a micro- processor to the accelerator and verify that the cyphertext received back is correct. Display the SPI communication on the logic analyzer."
  },
  {
    "objectID": "lab/lab7/index.html#resources",
    "href": "lab/lab7/index.html#resources",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Resources",
    "text": "Resources\n\nAES Standard: NIST FIPS 197\nStarter Code from GitHub Repo"
  },
  {
    "objectID": "lab/lab7/index.html#lab-7-specifications",
    "href": "lab/lab7/index.html#lab-7-specifications",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Lab 7 Specifications",
    "text": "Lab 7 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nAES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\nExcellence\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/lab7/index.html#the-advanced-encryption-standard",
    "href": "lab/lab7/index.html#the-advanced-encryption-standard",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "The Advanced Encryption Standard",
    "text": "The Advanced Encryption Standard\nThe Advanced Encryption Standard is described in an unusually succinct and clear standard. Reading the standard carefully will save you time. See Appendix A-1 for an example of the key expansion during each round and Appendix B for an example of the intermediate results during each round.\nA PDF of the standard can be found here.\n\nImplementation\nDownload the starter source code and libraries from the course website. The provided MCU libraries (included in the lib subdirectory of the project) support a number of peripherals on the MCU so that you can directly use them and do not need to write them yourself.\nExamine aes_starter.sv, sbox.txt. aes_starter.sv contains the top-level module, an SPI interface, and two testbenches. The testbench module tests the entire system including the SPI link. The testbench_aes_core module is a separate testbench that tests only the aes_core module without the SPI link. It is suggested that you use testbench_aes_core first to check your core and then test the whole system including the SPI link with the full testbench. These testbenches apply and check the test vector described in Appendix A-1 and B.\nThe starter code also contains the mixcolumns logic that operates on a 128-bit intermediate state. The Galois field arithmetic for mixcolumns is more complicated than for the rest of AES, and the implementation is based on a paper cited in the code. The sbox module and sbox.txt lookup table perform the sbox substitution on a single byte.\nThe MCU code lab7.c sends a key and plaintext message over SPI to the FPGA, then checks that the result is correct. Set up your project to target the FPGA on your board and develop the remaining modules necessary to implement AES. You will need to carefully read the specification to figure out what these are and how to connect them. Starting with a high-level block diagram of the system is a very helpful step to make sure that you are understanding the AES procedure correctly. The MCU starter code can be opened directly in SEGGER Embedded Studio and directly compiled and uploaded to the MCU and does not need any further modification.\nYou will discover that the logic is too large to implement all the rounds as one giant block of combinational logic. Therefore, you will need to perform the rounds sequentially. You will also need to pay careful attention to the timing within each round since you need to allow for the one-cycle latency required to perform the sbox byte substitution which uses the synchronous RAM blocks.\nTurn in the usual report including design approach, block diagram, code, schematics, results, and time spent."
  },
  {
    "objectID": "lab/lab7/index.html#hints",
    "href": "lab/lab7/index.html#hints",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Hints",
    "text": "Hints\nPrevious students have spent a highly variable amount of time on this lab. Here are some suggestions to make it go faster.\n\nStart by thoroughly understanding the specification\nIn prior labs you may have gotten in the habit of thinking in code. Remember to go back to thinking about hardware rather than function calls. Draw a block diagram for your hardware using elements such as registers, multiplexers, FSMs, and blocks of combinational logic. Name all of the signals between blocks. Remember how the E85 multicycle processor had a datapath that required certain control signals such as mux selects, and a controller that generates the control signals at the appropriate times. You’ll find a similar organization helpful. Write idiomatic Verilog code that exactly matches your block diagram.\n\n\nWatch for warnings in synthesis and simulation, and correct these before moving ahead.\nGet your design working in simulation first. When debugging, find the first place you can tell a signal is wrong. Add all the relevant inputs that influence that signal. If one of them is wrong, recursively work backward. When the inputs are good and the output is bad, you’ve isolated the bug and can look for it in that part of the code. Learn to do this systematically so you can find and solve each bug in minutes rather than hours.\nIf the design works in simulation but not on hardware, it is often a wiring error or a discrepancy between how you timed your control signals and what the C code expects. Make sure you’ve read the provided code carefully and are producing signals at the right times. Check that your FPGA and microcontroller are expecting the same polarity and phase for your SPI clock signal. Use the many channels of the logic analyzer to view all of the relevant signals at once and check them against your expectations. If you have a hard bug, it’s helpful to tap out intermediate signals, such as the state of a FSM, onto FPGA pins so you can watch them on the logic analyzer.\nHave fun! This is a sophisticated system and you should feel proud when you have built and debugged it!"
  },
  {
    "objectID": "lab/lab7/index.html#what-to-turn-in",
    "href": "lab/lab7/index.html#what-to-turn-in",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "What to Turn In",
    "text": "What to Turn In\nWhen you are done, have your lab checked off by the instructor. You should thoroughly understand how it works and what would happen if any changes were made. Turn in your lab writeup including the following information:\n\nSchematics of the breadboarded circuit.\nA screen capture (exported from the scope, not a photo captured using a camera) of an example SPI transaction captured on the oscilloscope/logic analyzer.\nYour source code.\nHow many hours did you spend on the lab? This will not count toward your grade."
  },
  {
    "objectID": "lab/lab7/index.html#credits",
    "href": "lab/lab7/index.html#credits",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Credits",
    "text": "Credits\nThis lab was original developed in 2015 by Ben Chasnov ’16, redesigned for the μMudd Mark 5.1 in 2019 by Caleb Norfleet ’21, and revamped for the μMudd Mark 6 in 2021 by Prof. Josh Brake."
  },
  {
    "objectID": "lab/lab3/index.html",
    "href": "lab/lab3/index.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab you will learn how to use an FPGA to scan inputs from a keypad."
  },
  {
    "objectID": "lab/lab3/index.html#introduction",
    "href": "lab/lab3/index.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab you will learn how to use an FPGA to scan inputs from a keypad."
  },
  {
    "objectID": "lab/lab3/index.html#learning-objectives",
    "href": "lab/lab3/index.html#learning-objectives",
    "title": "Lab 3: Keypad Scanner",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nDesigned a circuit interface to read a matrix keypad.\nUnderstood and implemented a solution to deal with switch bouncing.\nImplemented robust digital design strategies to ensure appropriate behavior with a variety of different user inputs."
  },
  {
    "objectID": "lab/lab3/index.html#requirements",
    "href": "lab/lab3/index.html#requirements",
    "title": "Lab 3: Keypad Scanner",
    "section": "Requirements",
    "text": "Requirements\nDesign and construct a circuit on your FPGA to read a 4-by-4 matrix keypad. Display the last two hexadecimal digits pressed on your dual seven-segment display, with the most recent entry appearing at the right. The keypad and your display should be in the same orientation.\nEach key press should be recorded exactly once, at the time the key is pressed, no matter how long or short a time the user holds the key down. If additional keys are pressed while still holding down the first key, these inputs should be ignored. The seven-segment displays should not flicker and should be the same brightness regardless of how many segments are displayed.\nOpen specifications in new tab."
  },
  {
    "objectID": "lab/lab3/index.html#lab-3-specifications",
    "href": "lab/lab3/index.html#lab-3-specifications",
    "title": "Lab 3: Keypad Scanner",
    "section": "Lab 3 Specifications",
    "text": "Lab 3 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nCircuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\nExcellence\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/lab3/index.html#discussion",
    "href": "lab/lab3/index.html#discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Discussion",
    "text": "Discussion\nA matrix keypad has four rows and four columns, connected to 8 pins, as shown below for two different models. When you press a key, the corresponding row and column are connected. Check this with a multimeter to confirm your pinout.\n\n\n\n\n\n\nFigure 1: Pinout of keypads.\n\n\n\nMechanical switches are prone to a phenomenon called switch bounce, where the switch makes and breaks its connection repeatedly on a time scale of microseconds to a few milliseconds. You should design your system in such a way that a single keypress registers only once even if there is some momentary bounce.\nThis is a thinking person’s lab. If you thoroughly understand the problem and design a simple scanner circuit, you can complete the lab fairly efficiently. If you go by trial and error, you may find yourself in lab indefinitely. You will need to generate rather complex stimuli to simulate your keypad scanner. Many students have been tempted to skip simulating and debug on the real hardware. Almost all have regretted it. Similarly, some students have been lured down the path of asynchronous design, at their peril."
  },
  {
    "objectID": "lab/lab3/index.html#what-to-turn-in",
    "href": "lab/lab3/index.html#what-to-turn-in",
    "title": "Lab 3: Keypad Scanner",
    "section": "What to Turn In",
    "text": "What to Turn In\nWhen you are done, have your lab checked off by the instructor. You should thoroughly understand how it works and what would happen if any changes were made. Turn in your lab writeup including the following information:\n\nSchematics of the breadboarded circuit.\nYour Verilog code and simulation results.\nA complete state transition diagram which illustrates the states of your system and the transitions between states. Remember that the transitions from each state should be completely described – in other words, the transitions should cover all possible combinations of the potential inputs.\nHow many hours did you spend on the lab? This will not count toward your grade."
  },
  {
    "objectID": "lab/lab3/index.html#hints",
    "href": "lab/lab3/index.html#hints",
    "title": "Lab 3: Keypad Scanner",
    "section": "Hints",
    "text": "Hints\nLook at your RTL schematic in your synthesis tool (Tools -&gt; Netlist Analyzer). Understand why your code produces the hardware you see. Be sure your combinational logic doesn’t have any registers. Be sure your logic has no latches or tristate buffers. The oscilloscope is handy for tracking down timing problems."
  },
  {
    "objectID": "lab/index.html",
    "href": "lab/index.html",
    "title": "Lab",
    "section": "",
    "text": "A Google Sheet for scheduling lab checkoffs can be found here. (g.hmc credentials required)\nAny code for the labs may be found on the E155 course Github repository.\n\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - ARM Assembly Sort\nLab 5 - Digital Audio\nLab 6 - The Internet of Things and Serial Peripheral Interface\n\nDS1722 Datasheet\nSerial Protocol Decoding on the RIGOL MSO1104z\n\nLab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "lab/lab1/specs.html",
    "href": "lab/lab1/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Development board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\n\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/lab1/specs.html#lab-1-specifications",
    "href": "lab/lab1/specs.html#lab-1-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Development board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\n\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/specs/lab7-specs.html",
    "href": "lab/specs/lab7-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nAES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\nExcellence\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/specs/lab3-specs.html",
    "href": "lab/specs/lab3-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nCircuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\nExcellence\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/specs/lab6-specs.html",
    "href": "lab/specs/lab6-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nDesign uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\nExcellence\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/specs/general-lab-specs.html",
    "href": "lab/specs/general-lab-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nGeneral Schematic Specifications\n\nAll pin names labeled\nAll pin numbers labeled\nCrossing wires clearly identified as junction or unconnected\nNeat layout (e.g., clear organization and spacing)\nAll parts labeled with part number\nAll component values present\n\nBlock Diagram\n\nBlock diagram present with one block per SystemVerilog module\nEach block includes all input and output signals\n\nHDL & Code Specifications\nGeneral Formatting\n\nDescriptive filename (e.g., lab2_jb.sv)\nDescriptive variable names\nNeat formatting (e.g., standard indentation, consistent formatting for variable names (kebab-case/snake_case/camelCase/PascalCase ))\nDescriptive and clear function/module names\n\nComments\n\nComments to indicate the purpose of each function/module\n\nLab Writeup/Summary\n\nBrief (e.g., 3-5 sentence) description of the main goals of the assignment and what was done.\nExplanation of design approach. How did you go about designing and implementing the design?\nExplanation of testing approach. How did you verify your design was behaving as expected?\nStatement of whether the design meets all the requirements. If not, list the shortcomings.\nNumber of hours spent working on the lab are included.\nWriteup contains minimal spelling or grammar issues and any errors do not significantly detract from clarity of the writeup.\n(Optional) List commments or suggestions on what was particularly good about the assignment or what you think needs to change in future versions.\n\n\n\n\nExcellence\nGeneral Schematic Specifications \n\nStandard symbols used for all components where applicable\nSignals “flow” from left to right where possible (e.g., inputs on left hand side, outputs on right hand side)\nTitle block with author name, title, and date\n\nHDL & Code Specifications\nGeneral Formatting\n\nName, email, and date at the top of every file\nComment at the top of each source code file to describe what is in it\nClear and organized hierarchy (e.g., deliniation between top level modules and submodules)\n\nTestbenches\n\nTestbenches written for each individual module to demonstrate proper operation\nTestbench output included in the report\n\nLab Writeup/Summary\n\nWriteup is free of spelling and grammar issues"
  },
  {
    "objectID": "lab/lab6/index.html",
    "href": "lab/lab6/index.html",
    "title": "Lab 6 Specifications",
    "section": "",
    "text": "By the end of this lab you will have…\n\nDesigned and built a simple IoT device\nWritten C libraries using the CMSIS device templates to implement the SPI functionality of the MCU\nInterfaced with a temperature sensor module over an SPI link\nInterfaced the MCU with an ESP8266 module over a UART link\nUse the logic analyze functionality of the scope in the Digital Lab to debug serial communication protocols and export captured signal data.\nWritten a simple HTML page to control and display data from the peripherals connected to your MCU."
  },
  {
    "objectID": "lab/lab6/index.html#learning-objectives",
    "href": "lab/lab6/index.html#learning-objectives",
    "title": "Lab 6 Specifications",
    "section": "",
    "text": "By the end of this lab you will have…\n\nDesigned and built a simple IoT device\nWritten C libraries using the CMSIS device templates to implement the SPI functionality of the MCU\nInterfaced with a temperature sensor module over an SPI link\nInterfaced the MCU with an ESP8266 module over a UART link\nUse the logic analyze functionality of the scope in the Digital Lab to debug serial communication protocols and export captured signal data.\nWritten a simple HTML page to control and display data from the peripherals connected to your MCU."
  },
  {
    "objectID": "lab/lab6/index.html#requirements",
    "href": "lab/lab6/index.html#requirements",
    "title": "Lab 6 Specifications",
    "section": "Requirements",
    "text": "Requirements\nBuild an internet-accessible device to control an onboard LED and measure ambient temperature. Use an ESP8266 with the provided web server code to host the webpage and use the onboard MCU GPIO and SPI peripherals to toggle an LED and to read temperature from a provided sensor chip. An end-user must be able to turn the LED ON and OFF and view the current temperature from the webpage.\nIn addition to the standard deliverables in your report (summary, schematic, etc.), your report also must include an example of a SPI read/write interaction with all pertinent data signals (e.g., CE, SCK, SDO, SDI) captured using the logic analyzer functionality of the oscilloscopes in the Digital Lab.\nAt heart, this lab asks you to consult the MCU documentation to learn how to directly control the SPI memory-mapped peripheral on the MCU, so refrain from consulting any other C device drivers that can be found on the web or elsewhere.\nNote that for this lab your SPI device driver must use the Common Microcontroller Software Interface Standard (CMSIS) device templates included in the stm32l432xx.h device header. See the provided example device drivers on the course GitHub repository for an example. The GPIO driver provides a good example of how to use the information included in the CMSIS headers.\n\nNote: There are only a limited number of ESP8266 boards and DS1722 SPI temperature sensors available for this lab. Please do not remove these devices from the digital lab so that everyone can access these shared resources."
  },
  {
    "objectID": "lab/lab6/index.html#resources",
    "href": "lab/lab6/index.html#resources",
    "title": "Lab 6 Specifications",
    "section": "Resources",
    "text": "Resources\n\nDS1722 Datasheet\nStarter Code from GitHub Repo"
  },
  {
    "objectID": "lab/lab6/index.html#lab-6-specifications",
    "href": "lab/lab6/index.html#lab-6-specifications",
    "title": "Lab 6 Specifications",
    "section": "Lab 6 Specifications",
    "text": "Lab 6 Specifications\n\nLab-specific Specifications\n\n\nProficiency\n\nDesign uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\nExcellence\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/lab6/index.html#esp8266-web-server",
    "href": "lab/lab6/index.html#esp8266-web-server",
    "title": "Lab 6 Specifications",
    "section": "ESP8266 Web Server",
    "text": "ESP8266 Web Server\nBroadly speaking, everything that you see on the internet is the product of one computer presenting text to another. The text is often formatted in a special, internet-specific, way that includes information about how to display it which is referred to as hypertext. (Forgive the early internet engineers for this indulgence; I’m sure it sounded really cool at the time.) Hypertext is specified using a compact programming language called hypertext markup language or HTML. It is transferred over the internet based on a predefined set of agreements between all computers which is referred to as the hypertext transfer protocol or HTTP. The latter most of these acronyms should be familiar: whenever you type http:// into a web browser you are informing your computer that you are attempting to retrieve hypertext from the address that follows.\nThere are two common tools that interact with HTTP: the web browser, which lives on a receiving computer, sends internet requests, and renders the received hypertext; and the web server, which listens for requests from the internet and sends out hypertext in response.\nImplementing an HTTP web server on the ARM microcontroller is a non-trivial task. Instead, you will be using an ESP8266, a small WiFi development board which incorporates a TCP/IP stack as well as onboard WiFi and an integrated antenna. You are provided an Arduino language program which hosts an HTTP web server with an HTML page generated by the MCU."
  },
  {
    "objectID": "lab/lab6/index.html#esp8266-mcu-interface",
    "href": "lab/lab6/index.html#esp8266-mcu-interface",
    "title": "Lab 6 Specifications",
    "section": "ESP8266-MCU Interface",
    "text": "ESP8266-MCU Interface\nDownload the Lab 6 starter code and support files from the class web page. You may use any code we have developed in class to help you write your code.\nESP8266 development boards are available from the E155 supply closet and are pre-programmed with the webserver code. The SSID for the WiFi access points associated with each board is Lab6_ESP_xx where xx is the number listed on each board.\nThe ESP8266 board requires 3.3 V power. However, it has an onboard regulator so you can power the board with between 3-6 V using the V+ and GND pins. If after supplying power to the chip and waiting for it to initialize you do not see the expected WiFi network appear, you may need to reprogram the chip with the provided code.\nThe MCU must supply a webpage to the ESP8266, and must interpret any web browser requests from the ESP8266. The devices interface through a 125000 baud serial UART connection on the MCU and the UART TX and RX lines of the ESP8266. Note that with a UART connection the receive and transmit lines should be crossed. In other words, the TX of the transmitter should be connected to the RX of the receiver and the RX of the transmitter should be connected to the TX of the receiver.\nThe protocol is as follows:\n\nWhen the ESP8266 updates the webpage from the MCU, it sends the most recent request from the client, within /REQ:'...'\\n. For example, a user accessing the page http://&lt;server_address&gt;/ledon would result in the request /REQ:ledonn being sent to the microcontroller. A user accessing the root webpage of the server, http://&lt;server_address&gt;/ would result in the request /REQ:\\n. Note that you must use http:// and not https://.\nThe MCU then transmits the entire web page to the ESP8266. The ESP8266 expects a webpage encoded as an HTML file. Therefore the webpage must start with ‘&lt;!DOCTYPE html&gt;&lt;html&gt;’ and end with ‘&lt;/html&gt;’. The ESP will wait for either &lt;/html&gt; or 200 ms from the last byte sent over serial before terminating the HTTP request and forwarding the content to the web browser.\n\nThe ESP8266 will create a WiFi access point named whatever SSID is labeled on the board. Connect to this WiFi network, and then go to http://192.168.4.1/. Beware that the ESP is slow and it may sometimes take a few attempts to connect."
  },
  {
    "objectID": "lab/lab6/index.html#digital-temperature-sensor",
    "href": "lab/lab6/index.html#digital-temperature-sensor",
    "title": "Lab 6 Specifications",
    "section": "Digital Temperature Sensor",
    "text": "Digital Temperature Sensor\nThe temperature sensor you will interface with for this lab is the DS1722 Digital Thermometer with SPI/3-Wire Interface from Maxim Integrated. This chip is an example of a simple peripheral that supports an SPI interface. You will need to get a DS1722 chip from the E155 stock cabinet mounted on an SOIC-8 breakout board. There are some boards that are already soldered, but if you are unable to find any pre-soldered boards to use, there may also be some chips and extra breakout boards you can solder yourself. After getting a board, consult the DS1722 datasheet to correctly wire up the device. Make sure to thoroughly read the data sheet and refer to the pinout before attempting to interface with the device!\nThe figure below shows the corresponding pinout between the SMT pads and the header pins on the breakout board for your convenience.\n\n\n\n\n\n\nFigure 1: SMT breakout board pinout."
  },
  {
    "objectID": "lab/lab6/index.html#mcu-hardware-and-the-internet-of-things",
    "href": "lab/lab6/index.html#mcu-hardware-and-the-internet-of-things",
    "title": "Lab 6 Specifications",
    "section": "MCU Hardware and the Internet of Things",
    "text": "MCU Hardware and the Internet of Things\nThe last component of this lab is to write a program that parses a request from the ESP8266, toggles the LED state as necessary, reads from the SPI temperature sensor, and uses this data to generate a webpage that is transmitted to the ESP8266. Make sure that the FPGA code on your board does not interfere with any of the pins which you may want to use for your sensors or else you will experience undefined behavior.\nYou will need to write an HTML webpage that displays dynamic temperature data as well as creating requests to change the state of the LED. There are many ways to do this, but we suggest the following resources for information on HTML formatting and interactive elements:\n\nhttp://www.w3schools.com/html/default.asp\nhttp://www.w3schools.com/html/html_forms.asp\n\nThe final product of this lab is a simple example of an emerging class of devices called the Internet of Things. Proponents of these devices argue that everything—from your washing machine to your car to giant factories—should be connected to the internet so that the shared data can be used to optimize and improve societal functions. Internet-controlled lighting, and internet-accessible sensors are two promising domains for the field, and are exemplified in this lab."
  },
  {
    "objectID": "lab/lab6/index.html#hints",
    "href": "lab/lab6/index.html#hints",
    "title": "Lab 6 Specifications",
    "section": "Hints",
    "text": "Hints\nThe time spent on this lab has been highly variable in the past. If SPI doesn’t work on your first try, it can take a long time to debug because there are many different settings, all of which have to be correct. You can increase the chance of SPI working by carefully studying the MCU documentation before coding. Before connecting the peripheral device, look at the SPI outputs on a logic analyzer and make sure that the clock, SDO, and the chip enables are matching your expectations. Fix your code if they do not. Then attach the peripheral and recheck all the signals including SDI."
  },
  {
    "objectID": "lab/lab6/index.html#what-to-turn-in",
    "href": "lab/lab6/index.html#what-to-turn-in",
    "title": "Lab 6 Specifications",
    "section": "What to Turn In",
    "text": "What to Turn In\nWhen you are done, have your lab checked off by the instructor. You should thoroughly understand how it works and what would happen if any changes were made. Turn in your lab writeup including the following information:\n\nSchematics of the breadboarded circuit.\nA screen capture (exported from the scope, not a photo captured using a camera) of an example SPI transaction captured on the oscilloscope/logic analyzer.\nYour source code.\nHow many hours did you spend on the lab? This will not count toward your grade."
  },
  {
    "objectID": "admin/index.html",
    "href": "admin/index.html",
    "title": "Admin",
    "section": "",
    "text": "Syllabus\nThe course syllabus can be found here.\n\n\nIn-Class Activity PDFs\nPDFs for the in-class activities/quizzes can be found in this shared Google Drive folder (g.hmc credentials required).\n\n\nLab Checkoff Schedule\nA Google Sheet for scheduling lab checkoffs can be found here. (g.hmc credentials required)"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html",
    "href": "resources/hdl-coding-guidelines.html",
    "title": "Best Practices for HDL Coding",
    "section": "",
    "text": "Writing HDL code seems similar to writing code that runs on a processor core in a programming language like C or Python. However, this impression is misleading and is the source of a great deal of confusion for many novice digital designers.\nThe number one, most important lesson you need to internalize before you write a line of HDL code is this: you absolutely, 100% must know what hardware you’re trying to imply before you write a line of code. If you just start writing code without having a clear idea of the hardware that you’re hoping to get at the end of the day (e.g., combinational logic blocks and flip-flops), you’re in for a world of hurt.\nThe tips and advice in this document are geared toward helping you become a knowledgeable digital designer."
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#overview",
    "href": "resources/hdl-coding-guidelines.html#overview",
    "title": "Best Practices for HDL Coding",
    "section": "",
    "text": "Writing HDL code seems similar to writing code that runs on a processor core in a programming language like C or Python. However, this impression is misleading and is the source of a great deal of confusion for many novice digital designers.\nThe number one, most important lesson you need to internalize before you write a line of HDL code is this: you absolutely, 100% must know what hardware you’re trying to imply before you write a line of code. If you just start writing code without having a clear idea of the hardware that you’re hoping to get at the end of the day (e.g., combinational logic blocks and flip-flops), you’re in for a world of hurt.\nThe tips and advice in this document are geared toward helping you become a knowledgeable digital designer."
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#before-writing-code",
    "href": "resources/hdl-coding-guidelines.html#before-writing-code",
    "title": "Best Practices for HDL Coding",
    "section": "Before Writing Code",
    "text": "Before Writing Code"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#while-you-are-coding-your-design",
    "href": "resources/hdl-coding-guidelines.html#while-you-are-coding-your-design",
    "title": "Best Practices for HDL Coding",
    "section": "While you are coding your design",
    "text": "While you are coding your design"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#conventions",
    "href": "resources/hdl-coding-guidelines.html#conventions",
    "title": "Best Practices for HDL Coding",
    "section": "Conventions",
    "text": "Conventions\n\nFile Names\n\n\nModule Names\n\n\nSignal Names\n\n\nConstants\n\n\nIndenting\n\n\nCommenting"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#assignment-statements",
    "href": "resources/hdl-coding-guidelines.html#assignment-statements",
    "title": "Best Practices for HDL Coding",
    "section": "Assignment Statements",
    "text": "Assignment Statements"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#general-systemverilog-coding-practices",
    "href": "resources/hdl-coding-guidelines.html#general-systemverilog-coding-practices",
    "title": "Best Practices for HDL Coding",
    "section": "General SystemVerilog Coding Practices",
    "text": "General SystemVerilog Coding Practices"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#resources-for-learning-more",
    "href": "resources/hdl-coding-guidelines.html#resources-for-learning-more",
    "title": "Best Practices for HDL Coding",
    "section": "Resources for Learning More",
    "text": "Resources for Learning More\n\nIEEE SystemVerilog Standards\nBest Practices for HDL Coding from Paul Hummel"
  },
  {
    "objectID": "project/final-project-requirements.html",
    "href": "project/final-project-requirements.html",
    "title": "MicroPs Final Project Requirements",
    "section": "",
    "text": "The E155 Final Project is a chance for you to apply your new skills in digital design to a moderately-sized problem as part of a two- or three-person team. You should begin thinking about a project and teammate right away. Your project has the following deliverables.\n\n\n\n\n\n\n\n\nDate\nDeliverable\nNotes\n\n\n\n\n10/27\nProject Proposal\nDue via Canvas\n\n\n10/31 & 11/2\nProposal Debriefs\nDuring lab checkoff times\n\n\n11/7 & 11/9\nPresentations\nDuring class\n\n\n11/16\nMidpoint Report & Demo\nDuring class time and lab slot\n\n\n12/5 & 12/7\nFinal Checkoffs\nDuring lab checkoff times\n\n\n12/7\nFinal Report Website\nDue by end of day\n\n\n12/8 @ 2 pm\nDemo Day\nPublic event to show off projects"
  },
  {
    "objectID": "project/final-project-requirements.html#overview",
    "href": "project/final-project-requirements.html#overview",
    "title": "MicroPs Final Project Requirements",
    "section": "",
    "text": "The E155 Final Project is a chance for you to apply your new skills in digital design to a moderately-sized problem as part of a two- or three-person team. You should begin thinking about a project and teammate right away. Your project has the following deliverables.\n\n\n\n\n\n\n\n\nDate\nDeliverable\nNotes\n\n\n\n\n10/27\nProject Proposal\nDue via Canvas\n\n\n10/31 & 11/2\nProposal Debriefs\nDuring lab checkoff times\n\n\n11/7 & 11/9\nPresentations\nDuring class\n\n\n11/16\nMidpoint Report & Demo\nDuring class time and lab slot\n\n\n12/5 & 12/7\nFinal Checkoffs\nDuring lab checkoff times\n\n\n12/7\nFinal Report Website\nDue by end of day\n\n\n12/8 @ 2 pm\nDemo Day\nPublic event to show off projects"
  },
  {
    "objectID": "project/final-project-requirements.html#project-scope",
    "href": "project/final-project-requirements.html#project-scope",
    "title": "MicroPs Final Project Requirements",
    "section": "Project Scope",
    "text": "Project Scope\nBe creative when selecting your project. Your project should be bigger than a 1-week lab assignment, but small enough to be doable. If in doubt, err on the side of smaller. You will fail the class if you undertake a project that is too big and produce no completed work.\nA successful project will use both the FPGA and MCU and will perform a function that is useful or interesting. You also must use a new piece of hardware in your final project (various sensors or displays are popular choices). You can find examples of past final projects on the class web page. Examples include games, electromechanical systems, prototypes for a startup company, or elements of a Clinic project (with your advisor’s permission)."
  },
  {
    "objectID": "project/final-project-requirements.html#budget",
    "href": "project/final-project-requirements.html#budget",
    "title": "MicroPs Final Project Requirements",
    "section": "Budget",
    "text": "Budget\nIf your team needs parts that are not available in the stockroom, you may spend up to $50 to purchase them. You will need to save your receipts, fill out a reimbursement form available from the department website, and have me approve the reimbursement (list me as the faculty advisor on the form). You may exceed this budget, but you must pay the remainder out of your own pocket."
  },
  {
    "objectID": "project/final-project-requirements.html#deliverables",
    "href": "project/final-project-requirements.html#deliverables",
    "title": "MicroPs Final Project Requirements",
    "section": "Deliverables",
    "text": "Deliverables\nYour team is responsible for the following deliverables at the dates described above:\n\nProject Proposal\nA 2-page proposal describing what you plan to build. It must be specific enough that I can tell when you demonstrate your project that it meets the specs of the proposal. Do not list stretch goals or wiggle words; simply state what you are committing to deliver. You may need to do some preliminary technical work to gain confidence you can deliver what you promise. Include a bill of materials with the parts you expect to need along with prices for any supplies that are not available in the stock room. Describe the main subsystems of the design and the features of the MCU that you plan to use. Explain the new piece(s) of hardware and show that both the FPGA and MCU are performing nontrivial functions appropriate to each. Include a block diagram showing the components and the interfaces between each.\n\n\nMidpoint Report & Demo\nA 4-page report (plus appendices) documenting your design at the midpoint. Your report should be submitted before your scheduled checkpoint slot. The status report should include:\n\nSchematics of anything on a breadboard,\nBlock diagrams of the logic on your FPGA,\nAn outline of the routines used on the MCU.\n\nYou should include as an appendix either your Verilog code or software that is mostly complete (but do not have to have both ready). You must be ready to demonstrate some working hardware in the lab.\n\n\nPresentations\nYour team will sign up for a 10-minute in-class presentation shortly after your proposal debrief. Your presentation should include a 3-minute overview of your project followed by an in-depth presentation of a specific technical problem your team is working on and has not yet solved. The goal of the presentation is to get input from other students who might have ideas of how to solve your problem so you must explain the problem clearly enough to get meaningful suggestions back.\n\n\nProject Demonstration\nDemonstrate a working project to the instructor in the lab. There will be signups for demonstration periods, during which you will show that you meet your specifications and be asked technical questions about the operation of your design. Come prepared with printouts of your schematics, software and Verilog. If your project is one day late, one letter grade will be deducted.\n\n\nFinal Report\nThe final report for this project will be a portfolio website hosted on Github pages. The website should document your design with all source code in the linked Github repository. Clearly explain how your design works. If you have developed techniques that would be useful for students in the future (e.g., how to interface to an LCD display), document these features well so that future students may build on your work.\nThe website should include:\n\nComplete schematics and block diagrams\nWell-commented and cleanly-formatted code (C and Verilog)\nPhotos of your finished design\nA video (hosted in the provided Google Drive folder) demonstrating your project. Any videos should be titled “&lt;LastName1&gt;&lt;LastName2&gt;&lt;VideoName&gt;” to clearly identify your videos in the folder.\n\nLate projects will not be accepted except in the case of unusual extenuating circumstances. Be careful to choose a project within a scope that you can reasonably expect to finish. If you realize your project is too large, contact me as soon as possible to renegotiate your project proposal. I will not accept revisions to the proposal after the Friday following the in-class presentation."
  },
  {
    "objectID": "project/final-project-requirements.html#grading",
    "href": "project/final-project-requirements.html#grading",
    "title": "MicroPs Final Project Requirements",
    "section": "Grading",
    "text": "Grading\nYour project will be graded according to the policy laid out in the syllabus. For reference, that policy can be found here.\nIf you feel there has been inequality between the work you and your teammate deliver, contact me personally."
  },
  {
    "objectID": "project/index.html",
    "href": "project/index.html",
    "title": "Project",
    "section": "",
    "text": "The requirements for the final project can be found here.\nCheckoffs for the proposal debrief, midpoint demo, and final checkoff can be scheduled on the Google Sheet found here. You should sign up for a slot as a team, not as individuals.\nAll submissions for the project are as a team and should be submitted on Canvas as group submissions."
  },
  {
    "objectID": "project/index.html#final-project-information",
    "href": "project/index.html#final-project-information",
    "title": "Project",
    "section": "",
    "text": "The requirements for the final project can be found here.\nCheckoffs for the proposal debrief, midpoint demo, and final checkoff can be scheduled on the Google Sheet found here. You should sign up for a slot as a team, not as individuals.\nAll submissions for the project are as a team and should be submitted on Canvas as group submissions."
  },
  {
    "objectID": "project/index.html#specs",
    "href": "project/index.html#specs",
    "title": "Project",
    "section": "Specs",
    "text": "Specs\nBelow you can find general rubrics for the different project deliverables. While these rubrics are a good reference, they are subject to changes.\n\nProject Proposal Specs\nDesign Review Presentation Specs\nMidpoint Status Report Specs\nProject Checkoff Specs\nProject Final Report Specs"
  },
  {
    "objectID": "project/index.html#final-projects-from-previous-years-of-e155",
    "href": "project/index.html#final-projects-from-previous-years-of-e155",
    "title": "Project",
    "section": "Final Projects from Previous Years of E155",
    "text": "Final Projects from Previous Years of E155\n\nFall 2023 Project Reports\nFall 2022 Project Reports\nFall 2019 Project Reports\nFall 2017 Project Reports\nFall 2016 Project Reports\nFall 2009 Project Reports\nFall 2006 Project Reports\nFall 2003 Project Reports\nFall 2002 Project Reports\nFall 2000 Project Reports\nFall 1999 Project Reports"
  },
  {
    "objectID": "project/index.html#vendors",
    "href": "project/index.html#vendors",
    "title": "Project",
    "section": "Vendors",
    "text": "Vendors\n\nSparkFun\nAdafruit\nDigikey\nMouser"
  },
  {
    "objectID": "project/reports/2023/index.html",
    "href": "project/reports/2023/index.html",
    "title": "Fall 2023",
    "section": "",
    "text": "Title\nTeam Members\nWebsite URL\n\n\nRhythm Game\nJulia Du, Allison Tsai\nhttps://julia-du.github.io/Rhythm-Game/\n\n\nIron Man Helmet\nJames Woo, Kaito Robson\nhttps://jwoo-20.github.io/E155-Final-Project-Website/\n\n\nSplit-Flap Display\nNithya Yeluri, Javier Perez, Dimitri Avila\nhttps://nyeluri53.github.io/E155-Final-Project-Website/\n\n\nCamera\nKavi Dey, Henry Merrilees, Neil Chulani\nhttps://kavidey.github.io/NeoObscura/\n\n\nSnake on VGA\nDiego Hererra Vicioso, Kate Lucio\nhttps://dherreravicioso.github.io/e155snakevga/\n\n\nDigital synthesizer\nKevin Box, Eli Rejito\nhttps://erejto.github.io/FPGA-Synth-project-portfolio/\n\n\nVolumetric display\nRafael Burger, Tjaard Van Loben Sels\nhttps://rafael-burger.github.io/E155-Final-Project-Website/\n\n\nMaze Game\nLawrence Nelson, Cecilia Li, Martin Susanto\nhttps://martin5009.github.io/amazing_game/design/"
  },
  {
    "objectID": "project/specs/project-midpoint-specs.html",
    "href": "project/specs/project-midpoint-specs.html",
    "title": "Project Midpoint Demo Specs",
    "section": "",
    "text": "Clear and concise written summary of current status\nSchematics of all breadboarded circuits\nBlock diagram of system components and the interfaces between them\nHardware demo functioning (potentailly with some minor bugs)\nMore than 25% of the way to the final deliverable\nClear description of microcontroller routines\nAll external parts ordered"
  },
  {
    "objectID": "project/specs/project-midpoint-specs.html#proficiency",
    "href": "project/specs/project-midpoint-specs.html#proficiency",
    "title": "Project Midpoint Demo Specs",
    "section": "",
    "text": "Clear and concise written summary of current status\nSchematics of all breadboarded circuits\nBlock diagram of system components and the interfaces between them\nHardware demo functioning (potentailly with some minor bugs)\nMore than 25% of the way to the final deliverable\nClear description of microcontroller routines\nAll external parts ordered"
  },
  {
    "objectID": "project/specs/project-midpoint-specs.html#excellence",
    "href": "project/specs/project-midpoint-specs.html#excellence",
    "title": "Project Midpoint Demo Specs",
    "section": "Excellence",
    "text": "Excellence\n\nAll interfaces in the block diagram defined (e.g., SPI, I2C, GPIO)\nHardware demo functioning well\nWriting is well organized\nSolid grammar or spelling issues (no more than a few minor errors which do not detract from the point).\nCompleted riskiest element of the project\nMore than 50% of the way to the final deliverable"
  },
  {
    "objectID": "project/specs/project-proposal-specs.html",
    "href": "project/specs/project-proposal-specs.html",
    "title": "Project Proposal Specs",
    "section": "",
    "text": "The goal of the proposal is to describe what you plan to build and how you plan to build it. The specifications below provide the expectations for the project proposal.\nIt should be no longer than 2-pages worth of text along with any technical documentation needed (i.e., diagrams, tables, or other figures do not count against the 2-page limit). The point is for you to make your description cleard, direct, and concise.\nWhile you are free to organize your proposal in the way that best suits your project, you should be sure to address the following sections:"
  },
  {
    "objectID": "project/specs/project-proposal-specs.html#proficiency",
    "href": "project/specs/project-proposal-specs.html#proficiency",
    "title": "Project Proposal Specs",
    "section": "Proficiency",
    "text": "Proficiency\n\nGeneral\n\nBill of materials included with list of all items needed for the project\nProject lists specifications for design\nIdentifies the riskiest element of the project\n\n\n\nTechnical\n\nDescribes microcontroller use\nProject uses FPGA\nProject uses new hardware\n\n\n\nDocumentation\n\nBlock diagram of system provided showing all elements of the design and their connections."
  },
  {
    "objectID": "project/specs/project-proposal-specs.html#excellence",
    "href": "project/specs/project-proposal-specs.html#excellence",
    "title": "Project Proposal Specs",
    "section": "Excellence",
    "text": "Excellence\n\nGeneral\n\nCompletely clear what the project must do to meet specs.\nRough timeline included which lists the tasks which need to be completed, the order in which they will be pursued, and the time they are expected to take.\nShort explanation of how the project tasks will be divided among the team members.\nWriting is well organized\nNo grammar or spelling issues.\n\n\n\nTechnical\n\nProject uses functionality of microcontroller not previously covered in labs\nProject uses functionality of FPGA not previously covered in labs\nProject uses new non-trivial new hardware (e.g., digital chip with non-trivial interface)\n\n\n\nDocumentation\n\nBill of materials includes part numbers, quantities, and prices for all components. Prices for components available in the stock room should be indicated as “stockroom”.\nBlock diagram of system clearly deliniates all protocols and interfaces.\nBlock diagram is computer drawn and neatly laid out."
  },
  {
    "objectID": "index.html#welcome-to-microps",
    "href": "index.html#welcome-to-microps",
    "title": "E155 FA23",
    "section": "Welcome to MicroPs!",
    "text": "Welcome to MicroPs!\nThis website will be the main location for course material this semester.\nBelow is a listing of some important links:\n\nSyllabus\nLabs Overview\nLecture Slides\nResources"
  },
  {
    "objectID": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html",
    "href": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "",
    "text": "Open Lattice Radiant. If you are prompted for a license file, navigate to it. See the Radiant install instructions if needed.\nCreate a new project and name it “iCE40_demo”. Select the project location in the directory you wish. Make sure that the path does not include spaces since this often leads to errors later in the synthesis process. You do not need to add any existing HDL files to the project.\nIn the “Select Device” menu, select the iCE40UP5K and the SG48 package. On the next page, select Lattice LSE as the synthesis tool.\n\n\n\n\n\n\nFigure 1: New project setup."
  },
  {
    "objectID": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#netlist-analyzer",
    "href": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#netlist-analyzer",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Netlist Analyzer",
    "text": "Netlist Analyzer\nAfter synthesizing your design, it is worth taking a look at the Netlist Analyzer. This tool provides a block diagram view of the design. This is a helpful tool to make sure that the Verilog you wrote is implying the hardware that you intend. Remember that as a digital designer you should always think about the underlying hardware and simply write the Verilog idioms to imply it. Approach HDL like a traditional programming language at your peril!\nIf we look at the Netlist Analyzer (found under “Tools &gt; Netlist Analyzer” or the green and black icon in the toolbar), we will open a window which shows a block diagram. We see that we have implied an adder, a mux to control the value to the registers, the HSOSC module, and a 25-bit-wide register.\n\n\n\n\n\n\nFigure 5: Netlist analyzer window."
  },
  {
    "objectID": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#resource-usage",
    "href": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#resource-usage",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Resource Usage",
    "text": "Resource Usage\nThere is also some useful information in the Reports tab under Project Summary in the Resource Usage section. In particular, this section will show us the number of registers, look-up tables, IO buffers, and embedded RAM blocks (EBRs) that we have implied in our design. For this design, we have 25 registers for storing the current count. An additional 3 logic cells are needed for their LUT4s to provide the additional logic (adder, mux, inverter).\n\n\n\n\n\n\nFigure 6: Resource usage report."
  },
  {
    "objectID": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#device-assignment-device-constraint-editor",
    "href": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#device-assignment-device-constraint-editor",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Device Assignment: Device Constraint Editor",
    "text": "Device Assignment: Device Constraint Editor\nWhen you first synthesize the design, the inputs and outputs of your top-level module will be randomly assigned to I/O pins. Next, you need to set the pin assignments to route the signals to the I/O pins that you desire.\nOpen the Device Constraint Editor and find the signal name and assign it to your desired pin. In this example, we will route the “led” output to GPIO 42. Select the table entry in the “Pin” column associated with the LED signal and enter “42”. You will notice that the currently routed pin is labeled in parentheses, 36 in this example. To update the design to route to our desired GPIO pin, we need to resynthesize the design. Click the green play button again to run the toolchain. When you do this for the first time, you will be asked to save a .pdc (pin device constraint) file. Name and save the file. After synthesis completes, open the Device Constraint Editor and confirm that the desired and routed pins match. In this case you should see “42(42)” in the table entry corresponding to the led output.\n\n\n\n\n\n\nFigure 7: Pinout diagram."
  },
  {
    "objectID": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#device-programming",
    "href": "tutorials/lattice_radiant_ice40_ultraplus_project_setup/index.html#device-programming",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Device Programming",
    "text": "Device Programming\nTo get our design working on our board, we need to program it to the flash memory onboard the UPduino board.\nEach time the FPGA powers up or resets, it reconfigures itself over a serial peripheral interface (SPI) connection from a binary (.bin) configuration file on a flash memory chip.\nTo program the device, we need to set up the programmer to put the .bin file that is generated by our synthesis tool onto the flash chip.\nClick the button in the toolbar to open the programmer (the icon is the chip with a blue arrow pointing downward) or using the menu Tools &gt; Programmer.\nConnect your UPduino board to your computer and click the “Detect Cable” button in the “Cable Setup” sub-window on the right of the Programmer window. You should see a message noting that “INFO - Board with FTDI USB Host Chip detected.” in the output window. If the host chip is not detected, you may need to install FTDI drivers for the device.\nNext we need to correctly configure the programming toolchain to program our device. By default, the UPduino board only enables programming of the flash chip on board and not the onboard compressed random access memory (CRAM) of the FPGA itself. To do this, highlight the device in the list view and open the “Device Properties” window either by using the icon in the toolbar (chip with pencil on top) or by right-clicking on the entry in the table and selecting the “Device Properties” option.\nChange the default entries to the following selections:\n\nSet Target Memory to External SPI Flash Memory\nSet operation to Erase, Program, Verify\nUnder SPI Flash Options set\n\nFamily: SPI Serial Flash\nVendor: WinBond\nDevice: W25Q32JV\nPackage: 208mil 8-pin SOIC\n\n\nAfter configuration, the block diagram should look like this.\n\n\n\n\n\n\nFigure 8: Flash programming setup.\n\n\n\nAfter updating the configuration, you are ready to program the device. (Note: on your first run, you may get a firewall warning that a new program “cableserver” is being run and needs access. Allow access to the program.)\nYou should see a series of outputs printing in the output window as the programmer cycles through the various pieces of the programming process (initialization, enabling, erasing, programming, verifying, etc.). After the programming finishes, you should see a message that the programming operation was successful."
  },
  {
    "objectID": "tutorials/video-tutorials/index.html#rigol-mso1104-logic-analyzer-demo",
    "href": "tutorials/video-tutorials/index.html#rigol-mso1104-logic-analyzer-demo",
    "title": "Video Tutorials",
    "section": "RIGOL MSO1104 Logic Analyzer Demo",
    "text": "RIGOL MSO1104 Logic Analyzer Demo"
  },
  {
    "objectID": "tutorials/video-tutorials/index.html#floating-point-support-for-printf-in-segger-embedded-studio",
    "href": "tutorials/video-tutorials/index.html#floating-point-support-for-printf-in-segger-embedded-studio",
    "title": "Video Tutorials",
    "section": "Floating Point Support for printf() in SEGGER Embedded Studio",
    "text": "Floating Point Support for printf() in SEGGER Embedded Studio"
  },
  {
    "objectID": "tutorials/video-tutorials/index.html#lattice-lse-fsm-automatically-decode-unreachable-states",
    "href": "tutorials/video-tutorials/index.html#lattice-lse-fsm-automatically-decode-unreachable-states",
    "title": "Video Tutorials",
    "section": "Lattice LSE FSM Automatically Decode Unreachable States",
    "text": "Lattice LSE FSM Automatically Decode Unreachable States"
  },
  {
    "objectID": "tutorials/modelsim_simulation_tutorial/index.html",
    "href": "tutorials/modelsim_simulation_tutorial/index.html",
    "title": "ModelSim Simulation Tutorial",
    "section": "",
    "text": "To verify that designs are working, it is useful to simulate them using ModelSim. This document will provide a quick demo of how to perform a simulation in ModelSim and how to include iCE40UP library files in the simulation."
  },
  {
    "objectID": "tutorials/modelsim_simulation_tutorial/index.html#creating-the-testbench",
    "href": "tutorials/modelsim_simulation_tutorial/index.html#creating-the-testbench",
    "title": "ModelSim Simulation Tutorial",
    "section": "Creating the Testbench",
    "text": "Creating the Testbench\nNext, we will create the testbench. Create a new SystemVerilog file “fulladder_tb.sv” and add it to your project. Then, type the following code into the testbench.\n`timescale 1ns/1ns\n`default_nettype none\n`define N_TV 8\n\nmodule fulladder_tb();\n // Set up test signals\n logic clk, reset;\n logic a, b, cin, s, cout, s_expected, cout_expected;\n logic [31:0] vectornum, errors;\n logic [10:0] testvectors[10000:0]; // Vectors of format s[3:0]_seg[6:0]\n\n // Instantiate the device under test\n fulladder dut(.A(a), .B(b), .Cin(cin), .S(s), .Cout(cout));\n\n // Generate clock signal with a period of 10 timesteps.\n always\n   begin\n     clk = 1; #5;\n     clk = 0; #5;\n   end\n  \n // At the start of the simulation:\n //  - Load the testvectors\n //  - Pulse the reset line (if applicable)\n initial\n   begin\n     $readmemb(\"fulladder_testvectors.tv\", testvectors, 0, `N_TV - 1);\n     vectornum = 0; errors = 0;\n     reset = 1; #27; reset = 0;\n   end\n  // Apply test vector on the rising edge of clk\n always @(posedge clk)\n   begin\n       #1; {a, b, cin, s_expected, cout_expected} = testvectors[vectornum];\n   end\n  initial\n begin\n   // Create dumpfile for signals\n   $dumpfile(\"fulladder_tb.vcd\");\n   $dumpvars(0, fulladder_tb);\n end\n  // Check results on the falling edge of clk\n always @(negedge clk)\n   begin\n     if (~reset) // skip during reset\n       begin\n         if (cout != cout_expected || s != s_expected)\n           begin\n             $display(\"Error: inputs: a=%b, b=%b, cin=%b\", a, b, cin);\n             $display(\" outputs: s=%b (%b expected), cout=%b (%b expected)\", s, s_expected, cout, cout_expected);\n             errors = errors + 1;\n           end\n\n      \n       vectornum = vectornum + 1;\n      \n       if (testvectors[vectornum] === 11'bx)\n         begin\n           $display(\"%d tests completed with %d errors.\", vectornum, errors);\n           $finish;\n         end\n     end\n   end\nendmodule\n\nNote: Functions preceded by a dollar sign (e.g., $readmemb, $display, $finish, etc.) are system functions."
  },
  {
    "objectID": "tutorials/modelsim_simulation_tutorial/index.html#the-testvector-.tv-file",
    "href": "tutorials/modelsim_simulation_tutorial/index.html#the-testvector-.tv-file",
    "title": "ModelSim Simulation Tutorial",
    "section": "The Testvector (.tv) File",
    "text": "The Testvector (.tv) File\nThe test vector file is a plaintext file with a single test vector on each line. Typically these are organized in the format &lt;inputs&gt;_&lt;expected_outputs&gt; (underscores are ignored but help to provide visual organization) but the specific format is up to you. You just need to make sure to assign the bits properly in your testbench module.\n// fulladder_testvectors.tv\n// Josh Brake\n// jbrake@hmc.edu\n// 5/26/22\n//\n// 5-bit vectors in binary. \n// underscore is ignored\n// // indicates comment\n// a b cin _ s cout\n000_00\n001_10\n010_10\n011_01\n100_10\n101_01\n110_01\n111_11"
  }
]