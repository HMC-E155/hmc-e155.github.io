[
  {
    "objectID": "project/reports/2023/index.html",
    "href": "project/reports/2023/index.html",
    "title": "Fall 2023",
    "section": "",
    "text": "Title\nTeam Members\nWebsite URL\n\n\nRhythm Game\nJulia Du, Allison Tsai\nhttps://julia-du.github.io/Rhythm-Game/\n\n\nIron Man Helmet\nJames Woo, Kaito Robson\nhttps://jwoo-20.github.io/E155-Final-Project-Website/\n\n\nSplit-Flap Display\nNithya Yeluri, Javier Perez, Dimitri Avila\nhttps://nyeluri53.github.io/E155-Final-Project-Website/\n\n\nCamera\nKavi Dey, Henry Merrilees, Neil Chulani\nhttps://kavidey.github.io/NeoObscura/\n\n\nSnake on VGA\nDiego Hererra Vicioso, Kate Lucio\nhttps://dherreravicioso.github.io/e155snakevga/\n\n\nDigital synthesizer\nKevin Box, Eli Rejito\nhttps://erejto.github.io/FPGA-Synth-project-portfolio/\n\n\nVolumetric display\nRafael Burger, Tjaard Van Loben Sels\nhttps://rafael-burger.github.io/E155-Final-Project-Website/\n\n\nMaze Game\nLawrence Nelson, Cecilia Li, Martin Susanto\nhttps://martin5009.github.io/amazing_game/design/"
  },
  {
    "objectID": "project/index.html",
    "href": "project/index.html",
    "title": "Project",
    "section": "",
    "text": "The requirements for the final project can be found here.\nCheckoffs for the proposal debrief, midpoint demo, and final checkoff can be scheduled on the Google Sheet found here. You should sign up for a slot as a team, not as individuals.\nAll submissions for the project are as a team and should be submitted on Canvas as group submissions."
  },
  {
    "objectID": "project/index.html#final-project-information",
    "href": "project/index.html#final-project-information",
    "title": "Project",
    "section": "",
    "text": "The requirements for the final project can be found here.\nCheckoffs for the proposal debrief, midpoint demo, and final checkoff can be scheduled on the Google Sheet found here. You should sign up for a slot as a team, not as individuals.\nAll submissions for the project are as a team and should be submitted on Canvas as group submissions."
  },
  {
    "objectID": "project/index.html#specs",
    "href": "project/index.html#specs",
    "title": "Project",
    "section": "Specs",
    "text": "Specs\nBelow you can find general rubrics for the different project deliverables. While these rubrics are a good reference, they are subject to changes.\n\nProject Proposal Specs\nDesign Review Presentation Specs\nMidpoint Status Report Specs\nProject Checkoff Specs\nProject Final Report Specs"
  },
  {
    "objectID": "project/index.html#final-projects-from-previous-years-of-e155",
    "href": "project/index.html#final-projects-from-previous-years-of-e155",
    "title": "Project",
    "section": "Final Projects from Previous Years of E155",
    "text": "Final Projects from Previous Years of E155\n\nFall 2023 Project Reports\nFall 2022 Project Reports\nFall 2019 Project Reports\nFall 2017 Project Reports\nFall 2016 Project Reports\nFall 2009 Project Reports\nFall 2006 Project Reports\nFall 2003 Project Reports\nFall 2002 Project Reports\nFall 2000 Project Reports\nFall 1999 Project Reports"
  },
  {
    "objectID": "project/index.html#vendors",
    "href": "project/index.html#vendors",
    "title": "Project",
    "section": "Vendors",
    "text": "Vendors\n\nSparkFun\nAdafruit\nDigikey\nMouser"
  },
  {
    "objectID": "project/storytelling-worksheet.html",
    "href": "project/storytelling-worksheet.html",
    "title": "Storytelling Worksheet",
    "section": "",
    "text": "Now that you’ve done all the hard technical work for your project, it’s time for the fun part: showing it off! As part of you final project website we’ll be creating short videos which showcase your project.\nThink of this like an elevator pitch for your project. You’ll have a minute to introduce your project and highlight the key features."
  },
  {
    "objectID": "project/storytelling-worksheet.html#format",
    "href": "project/storytelling-worksheet.html#format",
    "title": "Storytelling Worksheet",
    "section": "Format",
    "text": "Format\nWe’ll use the classic hero’s arc storytelling framework for making your video sticky.\n\n\n\nThe User’s Journey: Storymapping Projects That People Love, Lichaw, Donna, 2016. New York: Rosenfeld Media"
  },
  {
    "objectID": "project/storytelling-worksheet.html#designing-your-story",
    "href": "project/storytelling-worksheet.html#designing-your-story",
    "title": "Storytelling Worksheet",
    "section": "Designing Your Story",
    "text": "Designing Your Story\n\nCurrent State\nCharacter, what’s good, goals.\n\n\n\nProblem, Trigger, or Call to Action\nWhat’s the core problem your project addresses?\n\n\n\nImpediment(s)\nWhat’s the gap that your project addresses?\n\n\n\nYour Project\nWhat did you build?\n\n\n\nProblem Solved, Experience, or Delight\nHow does it solve it?\n\n\n\nThen what?\nWhat should you do next?\n\n\n\nEnd"
  },
  {
    "objectID": "project/specs/project-design-review-presentation-specs.html",
    "href": "project/specs/project-design-review-presentation-specs.html",
    "title": "Project Design Review Presentation Specs",
    "section": "",
    "text": "The purpose of the design review presentation is to provide you with the opportunity to share the plan for your project with your classmates and solicit their feedback.\nYou are free to structure your presentation however you would like, but most successful presentations include the following components.\nThe specifications below lay out how you will be assessed."
  },
  {
    "objectID": "project/specs/project-design-review-presentation-specs.html#proficiency",
    "href": "project/specs/project-design-review-presentation-specs.html#proficiency",
    "title": "Project Design Review Presentation Specs",
    "section": "Proficiency",
    "text": "Proficiency\n\nPresentation gives overview of the project\nPresentation presents a problem or question for the class\nInput solicited from the class"
  },
  {
    "objectID": "project/specs/project-design-review-presentation-specs.html#excellence",
    "href": "project/specs/project-design-review-presentation-specs.html#excellence",
    "title": "Project Design Review Presentation Specs",
    "section": "Excellence",
    "text": "Excellence\n\nPresentation wraps up on time\nSlides are well formatted with no spelling, grammar, or formatting issues.\nPresentation presents an in-depth technical problem\nProblem or question for the class is technical in nature (e.g., soliciting feedback about tradeoffs for a specific protocol for an interface)."
  },
  {
    "objectID": "project/specs/project-checkoff-specs.html",
    "href": "project/specs/project-checkoff-specs.html",
    "title": "Project Final Checkoff Specs",
    "section": "",
    "text": "Project meets most of of the specifications as laid out in the proposal with explanations for any specifications that weren’t met.\nSystem operates without any major bugs (e.g., doesn’t freeze in operation)\nDocument listing each spec from the proposal along with a short (e.g., 3-5 sentence) summary explaining whether the spec was met or not.\nTechnical documentation (e.g., schematics, code, block diagrams) available for review at checkoff.\nVerilog HDL is functional and cleanly formatted\nMCU C code is functional and cleanly formatted"
  },
  {
    "objectID": "project/specs/project-checkoff-specs.html#proficiency",
    "href": "project/specs/project-checkoff-specs.html#proficiency",
    "title": "Project Final Checkoff Specs",
    "section": "",
    "text": "Project meets most of of the specifications as laid out in the proposal with explanations for any specifications that weren’t met.\nSystem operates without any major bugs (e.g., doesn’t freeze in operation)\nDocument listing each spec from the proposal along with a short (e.g., 3-5 sentence) summary explaining whether the spec was met or not.\nTechnical documentation (e.g., schematics, code, block diagrams) available for review at checkoff.\nVerilog HDL is functional and cleanly formatted\nMCU C code is functional and cleanly formatted"
  },
  {
    "objectID": "project/specs/project-checkoff-specs.html#excellence",
    "href": "project/specs/project-checkoff-specs.html#excellence",
    "title": "Project Final Checkoff Specs",
    "section": "Excellence",
    "text": "Excellence\n\nProject meets all the specifications as laid out in the proposal.\nProject is polished (e.g., wires are hidden, any physical interfaces are well-designed and reliable, clean user interface)\nVerilog code is efficient and demonstrates best coding practices (e.g., modularity, testbenches were appropriate, etc.)\nC code is efficient and well organized (e.g., code encapsulated in functions and custom libraries as appropriate)"
  },
  {
    "objectID": "index.html#welcome-to-microps",
    "href": "index.html#welcome-to-microps",
    "title": "E155",
    "section": "Welcome to MicroPs!",
    "text": "Welcome to MicroPs!\nThis website will be the main location for course material this semester.\nBelow is a listing of some important links:\n\nSyllabus\nLabs Overview\nLecture Slides\nResources"
  },
  {
    "objectID": "lab/lab7/specs.html",
    "href": "lab/lab7/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "AES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\n\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/lab7/specs.html#lab-7-specifications",
    "href": "lab/lab7/specs.html#lab-7-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "AES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\n\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/lab6/specs.html",
    "href": "lab/lab6/specs.html",
    "title": "Lab 6 Specifications",
    "section": "",
    "text": "Design uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\n\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/lab6/specs.html#lab-6-specifications",
    "href": "lab/lab6/specs.html#lab-6-specifications",
    "title": "Lab 6 Specifications",
    "section": "",
    "text": "Design uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\n\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/lab2/specs.html",
    "href": "lab/lab2/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "HDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\n\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/lab2/specs.html#lab-2-specifications",
    "href": "lab/lab2/specs.html#lab-2-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "HDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\n\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/lab4/specs.html",
    "href": "lab/lab4/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Design plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\n\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/lab4/specs.html#lab-4-specifications",
    "href": "lab/lab4/specs.html#lab-4-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Design plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\n\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/lab3/specs.html",
    "href": "lab/lab3/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Circuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/lab3/specs.html#lab-3-specifications",
    "href": "lab/lab3/specs.html#lab-3-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Circuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/index.html",
    "href": "lab/index.html",
    "title": "Lab",
    "section": "",
    "text": "A Google Sheet for scheduling lab checkoffs can be found here. (g.hmc credentials required)\nAny code for the labs may be found on the E155 course Github repository.\n\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - ARM Assembly Sort\nLab 5 - Digital Audio\nLab 6 - The Internet of Things and Serial Peripheral Interface\n\nDS1722 Datasheet\nSerial Protocol Decoding on the RIGOL MSO1104z\n\nLab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "lab/specs/lab4-specs.html",
    "href": "lab/specs/lab4-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nDesign plays Für Elise from provided starter code\nNote durations match the durations specified in the starter code for Für Elise (i.e., the tune plays at the correct tempo)\nIndividual pitches are accurate to within 1% across the frequency range (of 220-1000 Hz) (calculations should be provided in the report to verify this)\nAll rests (pauses with no sound) are played properly\nCode uses #define macros for memory-mapped registers\n\n\n\nExcellence\n\nReport contains accurate calculations for minimum duration supported\nReport contains accurate calculations for maximum duration supported\nReport contains accurate calculations for minimum frequency supported\nReport contains accurate calculations for maximum frequency supported\nReport provides documentation and calculations to show that the durations and pitches are correct based on the timer configuration.\nDesign contains potentiometer to control the output volume.\nDesign plays an extra composition of your choice. You need not compose the tune from scratch, it is acceptable to transpose an existing tune."
  },
  {
    "objectID": "lab/specs/index.html",
    "href": "lab/specs/index.html",
    "title": "Lab Specifications",
    "section": "",
    "text": "Lab 1 Specs\nLab 2 Specs\nLab 3 Specs\nLab 4 Specs\nLab 5 Specs\nLab 6 Specs\nLab 7 Specs"
  },
  {
    "objectID": "lab/specs/lab2-specs.html",
    "href": "lab/specs/lab2-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nHDL design includes only a single seven-segment decoder module.\nSum of the numbers on the two displays is correctly displayed for all inputs\nSeven segment displays are same brightness regardless of how many segments are lit.\n\n\n\nExcellence\n\nNo noticeable bleeding of the digits between displays\nNo flickering on the individual digits\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\nDigits on the seven-segment display are upright to the viewer."
  },
  {
    "objectID": "lab/specs/lab7-specs.html",
    "href": "lab/specs/lab7-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nAES core simulation testbench passes\nAES SPI simulation testbench passes\n\n\n\nExcellence\n\nDesign fits on FPGA hardware\nSPI communication is displayed on logic analyzer\nSystem fully operational (sends data from MCU to FPGA and FPGA sends the correct data back again)."
  },
  {
    "objectID": "lab/lab1/specs.html",
    "href": "lab/lab1/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Development board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\n\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/lab1/specs.html#lab-1-specifications",
    "href": "lab/lab1/specs.html#lab-1-specifications",
    "title": "HMC E155",
    "section": "",
    "text": "Development board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\n\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/lab1/ai-prototype.html",
    "href": "lab/lab1/ai-prototype.html",
    "title": "Lab 1 AI Prototype",
    "section": "",
    "text": "The goal of this prototype is to experiment with using AI as a coding assistant to generate HDL. By the end of this experiment you should be able to:\n\nDemonstrate how an LLM can be used as a coding partner.\nAnalyze the quality of the LLM-generated code.\nDocument specific tips on how to use the LLM effectively."
  },
  {
    "objectID": "lab/lab1/ai-prototype.html#learning-goals",
    "href": "lab/lab1/ai-prototype.html#learning-goals",
    "title": "Lab 1 AI Prototype",
    "section": "",
    "text": "The goal of this prototype is to experiment with using AI as a coding assistant to generate HDL. By the end of this experiment you should be able to:\n\nDemonstrate how an LLM can be used as a coding partner.\nAnalyze the quality of the LLM-generated code.\nDocument specific tips on how to use the LLM effectively."
  },
  {
    "objectID": "lab/lab1/ai-prototype.html#prototype",
    "href": "lab/lab1/ai-prototype.html#prototype",
    "title": "Lab 1 AI Prototype",
    "section": "Prototype",
    "text": "Prototype\nFire up your favorite LLM. ChatGPT is a good place to start, but you may consider using other LLMs as well like Claude or Gemini. Enter the prompt below.\n\n\n\n\n\n\nLLM Prompt\n\n\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\nCreate a new Radiant project, type the code generated by the LLM in and analyze the results. If the synthesis fails, type the error message back into the LLM to see what suggestions it generates."
  },
  {
    "objectID": "lab/lab1/ai-prototype.html#reflect",
    "href": "lab/lab1/ai-prototype.html#reflect",
    "title": "Lab 1 AI Prototype",
    "section": "Reflect",
    "text": "Reflect\nWrite up a few paragraphs reflecting on your experience using the LLM to help you code. Feel free to make full use of screenshots, code snippets, and other media as you write your reflections.\nHere are a few ideas of on what you might comment on:\n\nHow would you rate the quality of the output and why?\nWhat SystemVerilog constructs/syntax did the LLM generated that were new to you?\nDid the LLM-generated code synthesize the first time around? If not, what were the issues?\nWhat error or warning messages did Radiant output?\nWhat would you do differently the next time you use an LLM in your workflow?"
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/specs.html",
    "href": "tutorials/quarto-portfolio-setup/specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Matches required folder structure with no extraneous pages (e.g., delete the about.qmd page that was created by default and will be unused)\nNavbar includes, at minimum, links to Home, Labs, Resources, and Blog pages. (Additional pages are fine.)\n.gitignore file with appropriate entries to prevent Quarto render files from being committed to version control (e.g., ignore .quarto/ and _site).\nHome page contains headshot\nHome page contains short bio\nHome page contains link to other web presence (LinkedIn and Github at minimum)\nLabs page contains a list of the labs for the semester along with titles (e.g., Lab 1: FPGA and MCU Setup and Testing) as h2 headings (i.e., put a ## in front of the text in your .qmd file)\nResources page contains link to the course website\nBlog page contains an initial reflections post (topic is up to you, but you might consider sharing some of your goals for the semester in MicroPs) (autopopulated from file in posts/ folder)\n\n\n\n\n\nSite is published and live on the web\nSite is checked into version control and pushed to repository on Github"
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/specs.html#quarto-portfolio-specs",
    "href": "tutorials/quarto-portfolio-setup/specs.html#quarto-portfolio-specs",
    "title": "HMC E155",
    "section": "",
    "text": "Matches required folder structure with no extraneous pages (e.g., delete the about.qmd page that was created by default and will be unused)\nNavbar includes, at minimum, links to Home, Labs, Resources, and Blog pages. (Additional pages are fine.)\n.gitignore file with appropriate entries to prevent Quarto render files from being committed to version control (e.g., ignore .quarto/ and _site).\nHome page contains headshot\nHome page contains short bio\nHome page contains link to other web presence (LinkedIn and Github at minimum)\nLabs page contains a list of the labs for the semester along with titles (e.g., Lab 1: FPGA and MCU Setup and Testing) as h2 headings (i.e., put a ## in front of the text in your .qmd file)\nResources page contains link to the course website\nBlog page contains an initial reflections post (topic is up to you, but you might consider sharing some of your goals for the semester in MicroPs) (autopopulated from file in posts/ folder)\n\n\n\n\n\nSite is published and live on the web\nSite is checked into version control and pushed to repository on Github"
  },
  {
    "objectID": "tutorials/git-setup/index.html",
    "href": "tutorials/git-setup/index.html",
    "title": "Git Setup",
    "section": "",
    "text": "The goal of this tutorial is to teach you how to use Git. There are tons of great tutorials on Git on the web, but I’ve linked one short, 15-minute video that will teach you the basics.\nAfter you watch the video, complete the first four levels in the Introduction Sequence at Learn Git Branching.\n\nIntroduction to Git Commits\nBranching in Git\nMerging in Git\nRebase Introduction\n\nYou can also find a few written resources in the Resources section below along with a few E155-specific tips."
  },
  {
    "objectID": "tutorials/git-setup/index.html#introduction",
    "href": "tutorials/git-setup/index.html#introduction",
    "title": "Git Setup",
    "section": "",
    "text": "The goal of this tutorial is to teach you how to use Git. There are tons of great tutorials on Git on the web, but I’ve linked one short, 15-minute video that will teach you the basics.\nAfter you watch the video, complete the first four levels in the Introduction Sequence at Learn Git Branching.\n\nIntroduction to Git Commits\nBranching in Git\nMerging in Git\nRebase Introduction\n\nYou can also find a few written resources in the Resources section below along with a few E155-specific tips."
  },
  {
    "objectID": "tutorials/git-setup/index.html#tutorial-video",
    "href": "tutorials/git-setup/index.html#tutorial-video",
    "title": "Git Setup",
    "section": "Tutorial Video",
    "text": "Tutorial Video\nWatch the 15-minute video below for a quick tour of the basics of Git."
  },
  {
    "objectID": "tutorials/git-setup/index.html#resources",
    "href": "tutorials/git-setup/index.html#resources",
    "title": "Git Setup",
    "section": "Resources",
    "text": "Resources\n\nDownloads\n\nGit\nGitHub Desktop\n\n\n\nTutorials\n\nIntroduction to Git: Companion notes to the video linked above.\nGit Tutorial from Adam Taylor: This excellent tutorial from Adam Taylor walks you through an introduction to Git with a view specific to using it for embedded systems development.\nPro Git Book: An excellent resources to learn about the inner workings of Git.\nLearn Git Branching: A highly-recommended game-like tutorial to help you get comfortable with branching."
  },
  {
    "objectID": "tutorials/git-setup/index.html#using-git",
    "href": "tutorials/git-setup/index.html#using-git",
    "title": "Git Setup",
    "section": "Using Git",
    "text": "Using Git\nThere are a variety of ways that you can interact with Git and you are welcome to use whatever interface is most comfortable for you. I typically recommend (and use) Github Desktop for most of my work and drop into the command line interface (CLI) when I need to do something a bit more complicated. VS Code also has built-in Git support if you’d like to use it, although I find it a bit less intuitive than the Github Desktop GUI."
  },
  {
    "objectID": "tutorials/git-setup/index.html#git-advice",
    "href": "tutorials/git-setup/index.html#git-advice",
    "title": "Git Setup",
    "section": "Git Advice",
    "text": "Git Advice\nWe’ll be leaning on Git heavily throughout E155. You’ll be required to use it to manage all the source code you write this semester and it will also be the foundation for your portfolio website. Despite the steep initial learning curve and some occasional bumps along the way, Git is relatively simple to use once you get into the flow. After you get over the learning curve, you’ll wonder how you ever coded anything beyond the simplest project without using version control.\nHere are a few general guidelines that you should follow when using Git throughout the semester.\n\nCreate a new Git repository for each project or lab you are working on.\nThis helps to keep things clean and organized.\n\n\nBranch frequently.\nGetting comfortable branching frequently will be a huge help as you work. Once you get past the most trivial designs, it is unbelievably easy to get tangled up in your own edits. This can cost you a lot of time!\nOnce you create the initial commit of the template code or project, create a branch to start working on your other edits. This will allow you to easily jump back and forth between various features you’re developing and also allow you to return to a working stable version of your code without losing anything.\nThe poor person’s solution is to comment out chunks of code to toggle between different versions but this will come back to bite you. Use branches instead!\n\n\nWhen you make a mistake, don’t freak out.\nYou will make mistakes, especially as you are getting familiar with Git. When that happens, don’t fret. Be aware when your actions might result in permanent loss of files and don’t hesitate to ask an instructor, grutor, or knowledgeable peer for help.\n\n\nAdd a new git command to help you delete branches when you merge them\nIt’s good practice to delete head branches once you merge them. You can configure your Github repository to do this automatically on the remote when you merge a pull request, but this won’t do anything to the branch on your local.\nOne easy way to help you do this is to create a new git alias, git gone, that will look for local branches that no longer exist on the remote and automatically remove them for you.\nTo do this, you can add the following line to the bottom of your .gitconfig file. Open your .gitconfig file (normally located at ~/.gitconfig) and add the following lines at the bottom of the file.\n[alias]\n  gone = ! \"git fetch -p && git for-each-ref --format '%(refname:short) %(upstream:track)' | awk '$2 == \\\"[gone]\\\" {print $1}' | xargs -r git branch -D\"\nThis command will fetch your repository from the remote, check if there are any branches on your local that have been deleted from the remote, and then remove your local copies. It’s a helpful one-liner to run after you merge a pull request on the remote to make sure that you keep your local repos clean."
  },
  {
    "objectID": "tutorials/git-setup/index.html#a-library-of-some-common-git-commands",
    "href": "tutorials/git-setup/index.html#a-library-of-some-common-git-commands",
    "title": "Git Setup",
    "section": "A Library of Some Common Git Commands",
    "text": "A Library of Some Common Git Commands\n\nBasic Git Commands\nAs you use Git, the commands below are some of the most common that you’ll encounter.\n\nCommit\nCommitting creates a new checkpoint and takes a snapshot of the current state of your repository.\n\n\nUndo Last Commit\nIf you make a mistake in your most recent commit, you can easily undo it. This is completed using the Undo Commit option in Github Desktop or by running git reset HEAD~1 which will move the branch pointer to one commit behind the current tip of the branch (i.e., the HEAD)\n\n\nAmend Last Commit\nIf you want to undo a commit but you’ve already pushed to the remote, you won’t see the option to undo your last commit in Github Desktop. Instead, you’ll need to select Amend Commit. This will allow you to add additional changes to the previous commit and/or update the commit message. Once you complete the amend, the commit will include all the operations.\nAfter you amend a commit that’s already been pushed to a remote, you’ll need to do a force push. This will force the commit history on the remote to match the local commit history and is needed since the commit on your local machine no longer matches the one on the remote.\nIt’s relatively painless to do this sort of commit wrangling when you are working alone on a repository, but it gets more complicated if you are collaborating with someone else because modifying the commit history will directly impact their downstream changes.\n\n\nPush\nThe Git push command send your local copy of the git repository to the remote server (e.g., on Github). Once you finish working on your changes locally, you’ll want to push them to the remote so that you can pull them down on another computer (e.g., if you are writing code on your personal computer but then want to download and continue editing the code on the computers in the lab).\n\n\nFetch/Pull\nThe Git fetch command is the opposite of Git push. It downloads the current state of the repository to your local machine. Once you download it you can choose to combine those changes with your local branch using a merge or rebase.\nGit pull combines the fetch and merge/rebase operations and is what you’ll use in most cases.\n\n\nStash\nIf you have uncommitted changes in your working directory and want to merge changes or switch branches, you’ll need to either commit the changes or stash them. Stashing changes allows you to set the changes aside without committing them if you still are not at the point you want to commit yet.\nGithub Desktop or the Git command line interface will throw an error if you try to checkout a different branch without committing or stashing any changes in your working directory.\n\n\n\nMore Advanced Git Commands\nAs you work longer with Git you’ll also get familiar with some more advanced Git operations listed below.\n\nBranching\nBranches are one of the most powerful features in Git. You should branch early and often.\nAs a starting point, read and adopt the GitHub flow workflow.\nIn short, the Github flow includes the following steps:\n\nCreate a branch\nMake changes\nCreate a pull request\nAddress review comments\nMerge your pull request\nDelete your branch\n\nEven if you are only working on a project by yourself, I still recommend getting in the habit of creating pull requests to be able to easily track the more significant developments in your project.\n\n\nMerge and Rebase\nWhen you finish working on a branch, you’ll need to combine your work with the existing commit history on main. To combine the two commit trajectories, you’ll need to choose to either merge or rebase your work.\nExecuting a merge in Git creates a new special commit with two parent commits. Rebasing will allow you to interactively apply all the changes from the commits that have occurred in main onto your branch. Therefore, when you merge your branch it will look as if your work was built linearly on top of main instead of separating and merging back in. It is often cleanest to rebase before merging so that you maintain a linear commit history (i.e., no merge commits).\nRebasing and merging is one of the more challenging Git operations to visualize and the tutorial at Learn Git Branching is very helpful to see what’s going on!\n\n\nPull Request\nA pull request is a mechanism to ask collaborators for feedback before merging your work into the main branch. You can read the page here which has information on how to create a pull request. It is pretty straightforward either from Github Desktop or the web interface."
  },
  {
    "objectID": "tutorials/git-setup/index.html#share-your-feedback",
    "href": "tutorials/git-setup/index.html#share-your-feedback",
    "title": "Git Setup",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "tutorials/modelsim-simulation-tutorial/index.html",
    "href": "tutorials/modelsim-simulation-tutorial/index.html",
    "title": "QuestaSim/ModelSim Simulation Tutorial",
    "section": "",
    "text": "QuestaSim is ModelSim\n\n\n\nModelsim was renamed to Questasim as part of Mentor Graphics’ (now Siemens EDA) strategy to unify and rebrand their simulation tools under the “Questa” umbrella. Across the web and on this website you may see references to both QuestaSim and ModelSim, but both names refer to the same software tool."
  },
  {
    "objectID": "tutorials/modelsim-simulation-tutorial/index.html#introduction",
    "href": "tutorials/modelsim-simulation-tutorial/index.html#introduction",
    "title": "QuestaSim/ModelSim Simulation Tutorial",
    "section": "Introduction",
    "text": "Introduction\nTo verify that designs are working, it is useful to simulate them using ModelSim. This document will provide a quick demo of how to perform a simulation in ModelSim and how to include iCE40UP library files in the simulation."
  },
  {
    "objectID": "tutorials/modelsim-simulation-tutorial/index.html#simple-simulations-by-forcing-signals",
    "href": "tutorials/modelsim-simulation-tutorial/index.html#simple-simulations-by-forcing-signals",
    "title": "QuestaSim/ModelSim Simulation Tutorial",
    "section": "Simple Simulations by Forcing Signals",
    "text": "Simple Simulations by Forcing Signals\nIf you have a simple design and want to quickly test it out to see that it is working, you can use the force function in the ModelSim command window to apply test inputs and measure the outputs.\nWe will use a full adder circuit as a demonstration.\n\n\n\n\n\n\nFigure 1: Full adder schematic.\n\n\n\nTo code up the full adder, first, open ModelSim and create a new ModelSim project titled ModelSim_Tutorial and save it in a location where the path name has no spaces. Then create a new file named fulladder.sv, making sure the file type is SystemVerilog. You should now have a blank file. Add the Verilog code below to create a structural Verilog model of the full adder circuit show above.\n\n\n\n\n\n\nFigure 2: Create new project.\n\n\n\n// fulladder.sv\n// Structural Verilog full adder\n// 5/26/22\n// Josh Brake\n// jbrake@hmc.edu\n\nmodule fulladder(\n input   logic A, B, Cin,\n output  logic S, Cout\n);\n\n logic n1, n2, n3;\n\n xor g1(n1, A, B);\n xor g2(S, n1, Cin);\n\n and g3(n2, n1, Cin);\n and g4(n3, A, B);\n\n or  g5(Cout, n2, n3);\n\nendmodule\nNext, we will simulate the file. First, compile your file via the Compile menu. Then, start the simulation using “Simulate &gt; Start Simulation…”. You will see the GUI change and open up the Objects and Wave panes. You can always toggle windows on or off as desired using the View toolbar menu.\nNext, add the selected symbols by selecting them in the Objects pane and adding them to the Wave pane either by using the right-click menu or dragging them. Next, to run the simulation, we need to initialize the input values which are floating (HiZ) to begin. We can do this by typing the command force &lt;Signal Name&gt; &lt;Signal Value&gt; in the Transcript pane. Force A, B, and Cin to some desired values of your choosing and then run the simulation for 10 time units by typing run 10. When you run the simulation, you will see the waves window advance the appropriate number of time points, displaying the values of the signals.\n\n\n\n\n\n\nFigure 3: Running simulation by forcing signals.\n\n\n\nFill out a truth table for a full adder by evaluating the circuit schematic shown above for all combinations of A, B, and Cin and verify a few values by forcing them to get the hang of it."
  },
  {
    "objectID": "tutorials/modelsim-simulation-tutorial/index.html#testbench-simulation",
    "href": "tutorials/modelsim-simulation-tutorial/index.html#testbench-simulation",
    "title": "QuestaSim/ModelSim Simulation Tutorial",
    "section": "Testbench Simulation",
    "text": "Testbench Simulation\nAfter testing about only two different inputs by manually forcing values you are probably already frustrated with the tediousness of running a simulation this way. Luckily, there is a much more efficient way to run simulations using testbenches.\nA testbench is a separate module which generates simulated inputs and enables the generated output signals to be traced versus time. You’ve likely seen testbenches before (e.g., in E85) but you may have never written one from scratch by yourself before. While this is a bit daunting at first, the basic architecture of a testbench is straightforward. Before you proceed, you should review the HDL testbench section in Digital Design and Computer Architecture (Section 4.9 in the ARM edition) which covers several different styles of testbenches.\nNote that testbenches include Verilog statements that are non-synthesizable (in other words, they cannot be mapped onto hardware). One example is the initial block, which runs only once at the start of a simulation. In this sense, testbenches use SystemVerilog a bit like a scripting language to enable designs to be easily tested and verified.\nIn this example we will create a testbench with automatic checking against a test vector file. This is the most powerful type of testbench and will be a good foundation for all the testbenches you will write for this class.\nA testbench is composed of the following elements:\n\nCreate and initialize the signals for the inputs, outputs, and internal signals of your modules.\nInstantiate the device under test (DUT)\nGenerate a simulated clock signal. Even if your module is purely combinational, you will need this clock signal to control when the input test vectors are applied and the outputs checked.\nLoad the test vectors and initialize the signals for the simulation (e.g., pulsing the reset line)\nApply the inputs and check the resulting outputs using the test vectors. One simple way to do this is to apply the test vector on the rising edge of the clock and then check the outputs against the expect outputs on the negative edge of the clock.\n\nEvery HDL module that you write should have a testbench to accompany it. While this will cost you some time up front, it will save you loads of time and potential head injuries from banging your head against the wall wondering why your circuit is not working as you expect.\n\nCreating the Testbench\nNext, we will create the testbench. Create a new SystemVerilog file fulladder_tb.sv and add it to your project. Then, type the following code into the testbench.\n`timescale 1ns/1ns\n`default_nettype none\n`define N_TV 8\n\nmodule fulladder_tb();\n // Set up test signals\n logic clk, reset;\n logic a, b, cin, s, cout, s_expected, cout_expected;\n logic [31:0] vectornum, errors;\n logic [10:0] testvectors[10000:0]; // Vectors of format s[3:0]_seg[6:0]\n\n // Instantiate the device under test\n fulladder dut(.A(a), .B(b), .Cin(cin), .S(s), .Cout(cout));\n\n // Generate clock signal with a period of 10 timesteps.\n always\n   begin\n     clk = 1; #5;\n     clk = 0; #5;\n   end\n  \n // At the start of the simulation:\n //  - Load the testvectors\n //  - Pulse the reset line (if applicable)\n initial\n   begin\n     $readmemb(\"fulladder_testvectors.tv\", testvectors, 0, `N_TV - 1);\n     vectornum = 0; errors = 0;\n     reset = 1; #27; reset = 0;\n   end\n  // Apply test vector on the rising edge of clk\n always @(posedge clk)\n   begin\n       #1; {a, b, cin, s_expected, cout_expected} = testvectors[vectornum];\n   end\n  initial\n begin\n   // Create dumpfile for signals\n   $dumpfile(\"fulladder_tb.vcd\");\n   $dumpvars(0, fulladder_tb);\n end\n  // Check results on the falling edge of clk\n always @(negedge clk)\n   begin\n     if (~reset) // skip during reset\n       begin\n         if (cout != cout_expected || s != s_expected)\n           begin\n             $display(\"Error: inputs: a=%b, b=%b, cin=%b\", a, b, cin);\n             $display(\" outputs: s=%b (%b expected), cout=%b (%b expected)\", s, s_expected, cout, cout_expected);\n             errors = errors + 1;\n           end\n\n      \n       vectornum = vectornum + 1;\n      \n       if (testvectors[vectornum] === 11'bx)\n         begin\n           $display(\"%d tests completed with %d errors.\", vectornum, errors);\n           $finish;\n         end\n     end\n   end\nendmodule\n\nNote: Functions preceded by a dollar sign (e.g., $readmemb, $display, $finish, etc.) are system functions.\n\n\n\nThe Testvector (.tv) File\nThe test vector file is a plaintext file with a single test vector on each line. Typically these are organized in the format &lt;inputs&gt;_&lt;expected_outputs&gt; (underscores are ignored but help to provide visual organization) but the specific format is up to you. You just need to make sure to assign the bits properly in your testbench module.\n// fulladder_testvectors.tv\n// Josh Brake\n// jbrake@hmc.edu\n// 5/26/22\n//\n// 5-bit vectors in binary. \n// underscore is ignored\n// // indicates comment\n// a b cin _ s cout\n000_00\n001_10\n010_10\n011_01\n100_10\n101_01\n110_01\n111_11\n\n\nPreventing Optimization\nWhen we simulate a testbench, we need to disable some of the default optimization. If you don’t, QuestaSim will eliminate many of your testbench signals because they are not directly linked to inputs or outputs of the modules.\nTo prevent optimization, change the optimization settings when you click the Start Simulation option from the Simulate menu. Click Optimization Settings and then select the option to “Apply full visibility to all modules (full debug mode)”.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: QuestaSim optimization settings for preserving testbench signals."
  },
  {
    "objectID": "tutorials/modelsim-simulation-tutorial/index.html#libraries",
    "href": "tutorials/modelsim-simulation-tutorial/index.html#libraries",
    "title": "QuestaSim/ModelSim Simulation Tutorial",
    "section": "Libraries",
    "text": "Libraries\nIn many instances we want to leverage the iCE40 Technology Library. However, when we go to simulate these designs, we need to make sure to include the appropriate libraries so that ModelSim can find the correct design units when it goes to do the simulation.\nWhen you install Lattice Radiant with ModelSim Lattice FPGA Edition, it comes with a set of installed libraries. For our purposes, we are most interested in the iCE40UP library and will need to include this in our simulation.\nTo do this, start the simulation by clicking Simulate &gt; Start Simulation. Then navigate to the Libraries tab and add iCE40UP to the Search Libraries window using the “Add…” button.\n\n\n\n\n\n\nFigure 5: ice40 Technology Library.\n\n\n\n\n\n\n\n\n\nFigure 6: Add ice40 Technology Library.\n\n\n\n\n\n\n\n\n\nFigure 7: Start sim with loaded library.\n\n\n\nThen navigate to the “Design” tab, select the top module and then click OK. Your simulation should now start and open up the Wave window.\n\n\n\n\n\n\nFigure 8: Start sim of top module.\n\n\n\nNote that you can also achieve the steps above by running vsim work.top -L iCE40UP in the command window."
  },
  {
    "objectID": "tutorials/modelsim-simulation-tutorial/index.html#share-your-feedback",
    "href": "tutorials/modelsim-simulation-tutorial/index.html#share-your-feedback",
    "title": "QuestaSim/ModelSim Simulation Tutorial",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "tutorials/tutorial-videos/index.html#creating-and-initializing-your-git-repo",
    "href": "tutorials/tutorial-videos/index.html#creating-and-initializing-your-git-repo",
    "title": "Tutorial Videos",
    "section": "Creating and Initializing Your Git Repo",
    "text": "Creating and Initializing Your Git Repo"
  },
  {
    "objectID": "tutorials/tutorial-videos/index.html#monitoring-memory-mapped-registers-in-segger-embedded-studio",
    "href": "tutorials/tutorial-videos/index.html#monitoring-memory-mapped-registers-in-segger-embedded-studio",
    "title": "Tutorial Videos",
    "section": "Monitoring Memory-mapped Registers in SEGGER Embedded Studio",
    "text": "Monitoring Memory-mapped Registers in SEGGER Embedded Studio"
  },
  {
    "objectID": "tutorials/tutorial-videos/index.html#rigol-mso1104-logic-analyzer-demo",
    "href": "tutorials/tutorial-videos/index.html#rigol-mso1104-logic-analyzer-demo",
    "title": "Tutorial Videos",
    "section": "RIGOL MSO1104 Logic Analyzer Demo",
    "text": "RIGOL MSO1104 Logic Analyzer Demo"
  },
  {
    "objectID": "tutorials/tutorial-videos/index.html#floating-point-support-for-printf-in-segger-embedded-studio",
    "href": "tutorials/tutorial-videos/index.html#floating-point-support-for-printf-in-segger-embedded-studio",
    "title": "Tutorial Videos",
    "section": "Floating Point Support for printf() in SEGGER Embedded Studio",
    "text": "Floating Point Support for printf() in SEGGER Embedded Studio"
  },
  {
    "objectID": "tutorials/tutorial-videos/index.html#lattice-lse-fsm-automatically-decode-unreachable-states",
    "href": "tutorials/tutorial-videos/index.html#lattice-lse-fsm-automatically-decode-unreachable-states",
    "title": "Tutorial Videos",
    "section": "Lattice LSE FSM Automatically Decode Unreachable States",
    "text": "Lattice LSE FSM Automatically Decode Unreachable States"
  },
  {
    "objectID": "tutorials/tutorial-videos/index.html#share-your-feedback",
    "href": "tutorials/tutorial-videos/index.html#share-your-feedback",
    "title": "Tutorial Videos",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "syllabus/index.html",
    "href": "syllabus/index.html",
    "title": "E155 Course Syllabus",
    "section": "",
    "text": "Item\nInformation\n\n\n\n\nInstructors:\nProf. Josh Brake\n\n\nLab Assistant(s):\nKavi Dey, Neil Chulani, Henry Merilees\n\n\nWeb page:\nhttps://hmc-e155.github.io/\n\n\nLab Checkoff Sheet:\nSheet Link\n\n\nEmail list:\neng-155 [at] g.hmc.edu\n\n\nDiscord Server:\nSee email for invite\n\n\n\nBe sure to join the class Discord and check it regularly as it will be the main source of course-related communication for this semester."
  },
  {
    "objectID": "syllabus/index.html#contact-information",
    "href": "syllabus/index.html#contact-information",
    "title": "E155 Course Syllabus",
    "section": "",
    "text": "Item\nInformation\n\n\n\n\nInstructors:\nProf. Josh Brake\n\n\nLab Assistant(s):\nKavi Dey, Neil Chulani, Henry Merilees\n\n\nWeb page:\nhttps://hmc-e155.github.io/\n\n\nLab Checkoff Sheet:\nSheet Link\n\n\nEmail list:\neng-155 [at] g.hmc.edu\n\n\nDiscord Server:\nSee email for invite\n\n\n\nBe sure to join the class Discord and check it regularly as it will be the main source of course-related communication for this semester."
  },
  {
    "objectID": "syllabus/index.html#course-schedule",
    "href": "syllabus/index.html#course-schedule",
    "title": "E155 Course Syllabus",
    "section": "Course Schedule",
    "text": "Course Schedule\n\n\n\nName\nInfo\n\n\n\n\nLecture\nTR 1:15 - 2:30 pm\n\n\nLab Checkoff\nTR afternoons by signup in the Digital Lab (PA B183)\n\n\nOffice Hours\nTBD\n\n\n\nYou will be working on labs on your own time and it is not required that you attend the entire scheduled lab period. Instead, sign up for a time to get your lab checked off. Please sign up for a time during your lab section. If you are unable to find a spot that works for you, see if you can swap with one of your classmates. If you are still having trouble finding a time that works for you, reach out and let me know.\n“Office hours” is code for “come hang out.” You are encouraged to attend office hours to ask questions, get help with your labs, talk about careers and graduate school, or chat about something on your mind (whether it is related to this class, academics, or anything else). In addition to things related to Engineering, embedded systems, digital electronics, and microcontrollers, a short (but not comprehensive!) list of things I enjoy talking about are sports (MLB: NY Mets; NFL: Tennessee Titans), running/biking/hiking, life design, time management, or books/essays I’m reading. I am available more often than not, so try dropping me a line via Discord or email if you are having a problem with your lab or want to set up a time. You may also contact the lab assistant(s) for questions when I am not available.\nIn broad strokes, MicroPs can be divided into two halves. The first half of the class focuses on giving you fundamental embedded systems concepts in lecture which you learn by experience through seven, hands-on labs. These labs are designed to be loosely structured design projects – you will be given information about the required specifications and some pointers on how to get started, but much of the development process is left open to you. The second half of the class is mainly focused on the project. The project gives you the opportunity to demonstrate independent and creative mastery of embedded system design in teams of two. The specific project task is very open-ended; the only requirement is that the project does something fun or useful and that it meaningfully uses both the FPGA and MCU. In addition to having a series of design review checkpoints, you will give a mid-project presentation to the class and a final presentation of your project when finished. The content of the lectures in the second half of the class focuses on exposing you to more advanced embedded systems concepts and exploring a range of various types of external hardware that may be useful to use in your project.\n\n\n\nWeek #\nMonday Date\nTuesday’s Class\nThursday’s Class\nDue\n\n\n\n\n1\n8/26\nIntro & Analog Behavior of Digital Systems\nCombinational and Sequential Logic\nGit & Quarto Portfolio Setup\n\n\n2\n9/2\nVerilog Coding\nSynchronous Design\nLab 1\n\n\n3\n9/9\nFPGA Documentation\nC Programming on an MCU\nLab 2\n\n\n4\n9/16\nClock Configuration\nTimers\nLab 3\n\n\n5\n9/23\nInterrupts\nSerial Interfaces Overview & SPI\nLab 4\n\n\n6\n9/30\nTBD\nTBD\n\n\n\n7\n10/7\nProject Kickoff\nUART and the IoT\nLab 5\n\n\n8\n10/14\nHappy Fall Break! No Class\nProposal Debriefs\nProject Proposal\n\n\n9\n10/21\nAdvanced Encryption Standard (AES)\nGraphics and Displays\nLab 6\n\n\n10\n10/28\nMotors and Speakers\nDirect Memory Access\nLab 7\n\n\n11\n11/4\nDesign Review Presentations\nDesign Review Presentations\nDesign Review Presentation & Memo\n\n\n12\n11/11\nIntroduction to Real Time Operating Systems\nProject Status Report and Demo\nProject Status Reports & Demo\n\n\n13\n11/18\nThe Fast Fourier Transform (FFT)\nConnectors\n\n\n\n14\n11/25\nEmerging Topics in Embedded Systems\nHappy Thanksgiving! No class\n\n\n\n15\n12/2\nGuest Lecture: Ben Chelf\nTBD\nProject Checkoffs, Report, Demo Day"
  },
  {
    "objectID": "syllabus/index.html#course-learning-objectives",
    "href": "syllabus/index.html#course-learning-objectives",
    "title": "E155 Course Syllabus",
    "section": "Course Learning Objectives",
    "text": "Course Learning Objectives\nThe overarching goal of this course is to take you from a basic familiarity and knowledge of digital design with field gate programmable arrays (FPGAs) and microcontrollers programming and expand your capabilities to design, build, and test embedded systems.\nThe learning goals for the course are divided into two main categories: technical and professional. The technical learning goals describe the technical skills you will acquire as you complete the course. The professional learning goals articulate how this course will help you to grow as a person and develop the character traits that will help you to thrive as you take the skills you learn in this class beyond the walls of Harvey Mudd.\n\nTechnical Learning Goals\nBy the end of this course you should be able to:\n\nDesign and implement combinational and sequential circuits on an FPGA.\nUse an ARM-based microcontroller to interface with the real world via sensors and actuators.\nBuild an embedded system project of your own design from the ground up.\nSelect appropriate embedded hardware for a given design challenge.\nEffectively and efficiently debug electrical systems with measurement tools such as an oscilloscope and logic analyzer.\nRead and understand complicated datasheets at a level that enables you to incorporate them into your designs.\n\n\n\nProfessional Learning Goals\nBy the end of this course you should be able to:\n\nCommunicate technical results with clarity and in a professional manner through oral presentations and written reports.\nCommunicate your work with a wide variety of audiences, including technical experts, your peers, and the general public.\nArticulate how you have developed character strengths throughout the semester."
  },
  {
    "objectID": "syllabus/index.html#teaching-philosophy",
    "href": "syllabus/index.html#teaching-philosophy",
    "title": "E155 Course Syllabus",
    "section": "Teaching Philosophy",
    "text": "Teaching Philosophy\nThe ultimate goal for this course is to help you to master the material and become skilled embedded systems developers who understand how to build a system from a set of requirements and specifications and to verify that the system meets those specifications.\nHere are a few of the main pedagogical concepts that you can expect to see in this course.\n\nTransparent Teaching – you should not have to guess what you are supposed to get out of a given activity or assignment in this class. I strive to be as transparent about why we are doing what we are doing. This is most clearly articulated through explicit learning goals that accompany each lecture, lab, or project. If the purpose of anything we do in this class is ever unclear, please ask me and I will be happy to clarify it.\nPsychological Safety – A psychologically safe environment is one where each person feels able to share their questions, concerns, or mistakes without feeling embarrassed or looked down upon by others. Building a psychologically safe classroom is a joint venture which I expect each of you to join with me in pursuing.\nA Growth Mindset – growth can only happen when you reach the end of what you already know. Each of you coming into this class will have different levels of experience with the types of skills that are useful in this class like working with embedded systems, programming, debugging, design, etc. My goal as an instructor is to take you from wherever you are and bring you as far along in your journey as possible. To do that, I encourage each of you to ask questions and push yourself to the edge of your knowledge. It can be frustrating or embarrassing to have questions that you feel you should already have the answer to. You should take these moments as opportunities to ask questions and fill the gaps in your knowledge. In the end, having a growth mindset is strongly linked with deep curiosity about what you are learning and a realization that while being honest about the limits of your understanding might be challenging, embracing that discomfort allows you to grow and improve quickly.\nFrequent, Low-stakes Testing – Research has shown that having frequent opportunities to assess your knowledge is a powerful way to learn and correct any misconceptions. One way that this will take place is through regular in-class quizzes and activities.\nInterleaving – The scheduling of the material is arranged in such a way that you will return to many similar concepts throughout the semester with some time in between. The goal of this is to have you return to familiar concepts after some time away so that you reinforce the material after working on something else. This has been shown to improve long-term retention of the material (see Small Teaching by James Lang if you are curious in learning more)."
  },
  {
    "objectID": "syllabus/index.html#recommended-texts",
    "href": "syllabus/index.html#recommended-texts",
    "title": "E155 Course Syllabus",
    "section": "Recommended Texts",
    "text": "Recommended Texts\nI assume you have a solid grasp of digital design at the level of E85; review Digital Design and Computer Architecture, ARM Edition (link) if you feel rusty on a topic. We will not be closely following a textbook, but you may find The Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors by Joseph Yiu to be a helpful, comprehensive reference for the microcontroller. An electronic version of the book is available through the library (link)."
  },
  {
    "objectID": "syllabus/index.html#lab-kit",
    "href": "syllabus/index.html#lab-kit",
    "title": "E155 Course Syllabus",
    "section": "Lab Kit",
    "text": "Lab Kit\nWhile there is not a textbook to purchase, you will need to buy a lab kit. The fee is $75 in Claremont Cash, and should be paid by filling out the Google Form (link) which authorizes Sydney Torrey in the Engineering office to charge your Claremont Cash account. Once you have paid for your kit via the form, see Sam Abdelmuati in the stockroom to pick up your kit. If you cook your board this semester, you can buy and rebuild a replacement, but ask the instructor for help troubleshooting first. You’ll also check out a large breadboard from the stockroom, and will need to return it at the end of the semester.\nThe kit fee can be waived in cases of financial hardship. To request a waiver fill out the form here (link). Course instructors will not know about waiver requests."
  },
  {
    "objectID": "syllabus/index.html#lab-access",
    "href": "syllabus/index.html#lab-access",
    "title": "E155 Course Syllabus",
    "section": "Lab Access",
    "text": "Lab Access\nThe Digital Lab (Parson B183) is available for you to use when working on your labs. The current door code will be shared privately. There are Windows PCs available with SEGGER Embedded Studio and Lattice Radiant installed along with the drivers required to program your board. The lab also has the electronics assembly equipment needed to solder, oscilloscopes and power supplies at the lab stations, and a lab cabinet with various resistors and some of the parts like wires, seven-segment LEDs, and transistors you will need for some of your labs. You are welcome to use these while working on your lab, but please make sure to return the components to the lab cabinet when you are done.\nIn addition, the software we will be using for programming the MCU (SEGGER Embedded Studio for ARM) and FPGA (Lattice Radiant) are free and supported on a variety of platforms if you wish to download them on your personal computer. SEGGER Embedded Studio is supported on Windows, MacOS, and Linux and Lattice Radiant is supported on Windows and Linux. If you are running MacOS, you can download and virtualize Windows using VMWare Fusion Pro under a Personal Use License for free. More details and download links can be found here (link)."
  },
  {
    "objectID": "syllabus/index.html#grading",
    "href": "syllabus/index.html#grading",
    "title": "E155 Course Syllabus",
    "section": "Grading",
    "text": "Grading\nThe grading for this class is based on a variation of specifications-grading and may be a bit different than what you have seen in other classes. The grade you earn in the class will be determined based the number of deliverables you successfully complete and the level of polish to which you complete them across three different bundles:\n\nLabs\nProject\nIn-class reflections\n\nEach assignment will contain a list of specifications (or specs) for two levels of completeness: proficiency and excellence. The list of specifications are designed to be aligned with the learning goals for the assignment. The proficiency specifications will indicate the level of completeness that demonstrates that you have achieved a level of comfort with the material in the assignment such that you would be able to implement the learning outcomes in a different setting. Excellence specs are above and beyond proficiency specs. Meeting the excellence specs for an assignment indicates that you have not only achieved the basic level of expected knowledge of the material, but have truly understood and are able to apply the techniques with deftness.\nThe table below describes the levels that you need to meet in each bundle (i.e., column) in order to earn the grade in the respective row. To earn the grade in a given row, you must meet all the criteria in that row. In other words, to get a B, you must complete the following:\n\nAll 7 labs to the proficiency specs and 5 of those labs must meet the excellence specs.\nAll 5 project elements must meet proficiency specs and 4 of them must meet the excellence specs.\n\n\n\n\nGrade\nLabs\nProject\n\n\n\n\nF\nP &lt; 5\nP &lt; 4\n\n\nD\nP \\(\\geq\\) 5, E \\(\\geq\\) 1\nP \\(\\geq\\) 4\n\n\nC\nP \\(\\geq\\) 6, E \\(\\geq\\) 2\nP \\(\\geq\\) 4, E \\(\\geq\\) 2\n\n\nB\nP = 7, E \\(\\geq\\) 5\nP = 5, E \\(\\geq\\) 4\n\n\nA\nP = 7, E = 7\nP = 5, E = 5\n\n\n\nPerformance on the labs and project is weighted equally. +/- grades will be assigned for situations in which your performance falls between the conditions for each row.\nIn addition to the labs and projects, you will also write short (2-3 paragraph) reflections each week as a way of helping you to catalog your growth in the class. These informal reflections are designed to be published as blog posts on your portfolio website and along with your in-class participation on short quizzes can help to boost your grade in the class by up to half a letter grade (e.g., from a B- to a B or B+ to an A-). A list of some ideas for potential blog topics can be found here. As one example, if you meet the requirements for an A in the labs bundle but the requirements for a B in the project bundle, you can expect to earn either a B+ or A-. In these situations, your in-class participation is a contributing factor to split the difference between the - of the higher tier and the + of the lower tier."
  },
  {
    "objectID": "syllabus/index.html#course-policies-honor-code",
    "href": "syllabus/index.html#course-policies-honor-code",
    "title": "E155 Course Syllabus",
    "section": "Course Policies & Honor Code",
    "text": "Course Policies & Honor Code\nThis section articulates a number of policies for the course. The goal of theses policies is to create the most effective learning experience for you in this course. If you have questions about any of these policies or the motivation behind them, I would be glad to discuss more with you. Please find me sometime after class or in office hours!\n\nCommunication Policy\nPlease note that I do not always respond immediately to messages. In particular I typically do not check email or Discord between 6:00 pm and 6:00 am on weeknights, and I typically do not check these at all on weekends. In addition, Friday is my off-campus consulting day which means that I may be slow to respond to messages then.\nThat said, I do my best to do meet the following:\n\nMessages sent on a weekday other than Friday (i.e., Monday-Thursday) before 4:00 pm PT will get a response the same day.\nMessages sent after 4:00 pm PT Sunday-Wednesday will get a response the next day.\nMessages sent after 4:00 pm PT on Fridays or on the weekend will get a response the following Monday.\n\n\n\nCollaboration Policy\nYour peers are an excellent source of support and can be a great help as you complete MicroPs. With that said, it is important that each student in the class do the work for themselves to develop their own expertise. The collaboration policy for MicroPs is as follows:\n\n\n\n\n\n\nCollaboration Policy\n\n\n\nYou should:\n\nDiscuss high level questions about the approach to the lab after you have spent time developing your own initial approach.\nAsk for feedback on your Verilog code after both you and the person you are asking to review your code have made a significant attempt on your own.\nList on your lab writeup any people that have reviewed your work or for whom you have reviewed work.\nAsk the instructor any question you think might be inappropriate to discuss with a peer.\n\nYou may not:\n\nPair program.\nUse code that you have not personally typed (e.g., do not copy-paste code from any source). Note that this policy does not apply to the portions of your lab where you are encouraged to use AI.\nDirectly copy code from any other person.\nUse any source code in your project without citation (e.g., if you use a module from a textbook or another online source, be sure to cite it in the comments of your code.).\n\n\n\n\n\nAI Policy\nAI tools like ChatGPT are an emerging and active area of research and development. The generative AI tools available today are significantly better than those available even six months ago. Although there are no guarantees in life, it is reasonable to assume that they will continue to improve as they are further refined, even as laws of diminishing returns inevitably come into play.\nExperiencing this rapidly evolving field in real time is exciting, but it also presents some challenges for teaching and learning. Some have argued that generative AI democratizes expertise, but in truth what it democratizes is the appearance of expertise, not the expertise itself. As we think about generative AI tools like large language models (LLMs) and their place in education, we need to be careful to keep our principles and values clearly in view at all times. What is the goal of the work we are doing together?\nFrom a practical point of view, it is prudent to ask the question about how the continued development of AI will impact the value of this knowledge and skill. It is hard to believe that AI will not significantly change the nature of work in the course of your careers. It is highly likely that there is a future where some of the skills you learn today are no longer relevant, in the same way that we no longer use slide rules to make calculations. For example, it has become clear that LLMs can be a significant aid when programming.\nWhile we look toward the future and anticipate many changes, we must be careful not to discard the foundational skills and knowledge that will allow us to leverage the capabilities of whatever innovation is on the horizon. Not only that, but we must also not forget that our knowledge and skill is built on the foundation of our character; those things that define who we are as people and shape our deepest values for who we want to be and the world we want to be a part of.\nOn the question of how to engage generative AI, I encourage us all to embrace a posture of curiosity and critical exploration. To turn a blind eye to an innovation of such magnitude is to surrender one’s agency to shape its trajectory. How to engage AI wisely through this lens will vary based on the situation. For example, some of your classes and professors will urge you to avoid using generative AI tools altogether. Instead of responding with an attitude of suspicion or assuming that they have made this decision out of fear, I would urge you to engage with a posture of humility and curiosity, seeking to understand the reasons behind their policy and how the decision aligns with the goals they are trying to guide you and your classmates toward.\nOther professors may have a more or less welcoming approach to these new tools, encouraging or even requiring that you experiment with them in their classes. Once again, I would encourage you to engage with curiosity and seek to understand the values that motivate their decision.\nFollowing the public release of ChatGPT in late 2022, large language models (LLMs) hit the mainstream and have been the subject of robust conversations about how educators and students should approach these tools. AI tools, whether in the form of an LLM or something else, are likely to have an impact on your career and work as an engineer. In this class, we will be approaching AI tools with a posture of cautious engagement. The guiding principle for the use of AI tools is that these tools must be used in the spirit of the assignment.\n\n\n\n\n\n\nUsing AI in MicroPs\n\n\n\nIn MicroPs this fall we will adopt the following policies for generative AI use:\nYou should:\n\nUse AI on the AI prototypes throughout the course. Each lab this fall will include a section describing a generative AI experiment. For the tasks in these sections you are required to leverage generative AI. As you embrace AI, I would encourage you to reflect on your experience using it and on its impact on your skill development. Your reflections on these AI experiments each week are a great topic to discuss in your weekly reflections.\n\nYou should not:\n\nUse generative AI to directly generate any code on the main lab design challenges. Learning how to write Verilog and C code is a core learning objective in this class. The best way to learn how to evaluate the quality of LLM-generated code is by first writing a large quantity of it for yourself.\nUse generative AI to generate any of your technical documentation. Thinking is writing, and learning how to articulate what you’ve done and what it means matters. Outsourcing this task to an LLM will not help you to better understand the work you are doing. As noted above, you may use spellcheckers, but you must not use tools which will rewrite sentences for you or generate text (e.g., Google’s “Help Me Write” feature)\n\n\n\nOnce the labs finish, we will revisit this policy for the project phase of the class to decide collectively how we may want to revise our approach to generative AI. The results of your weekly AI prototypes and reflections about them will provide a healthy foundation from which we can discuss!\n\n\nHonor Code Violations\nStudents in this class are expected to follow the HMC honor code. An honor code policy appears below and prescribes behavior that is considered honorable, so read those maxims and follow them closely. Any honor code violations will be handled through JB.\nIf you believe you have violated the honor code in any way, please take the initiative to self report so that we can come up with a fair and just path forward together.\n\n\nHonor Code Policy\n\nAll students enrolled in this course are bound by the HMC Honor Code. More information on the HMC Honor Code can be found in the HMC Student Handbook.\nIt is your responsibility to determine whether your actions adhere to the HMC Honor Code. If this document does not clarify the legitimacy of a particular action, you should contact the course instructor and request clarification.\nWork you submit for individual assignments should be your own, and you should complete all assignments based on your own understanding of the underlying material. If you work with, or receive help from, another individual on an assignment, provide a written acknowledgement in complete sentences that includes the person’s name and the nature of the help.\nThis document is not meant to be an exhaustive list of every possible Honor Code violation. Infractions not explicitly mentioned here may still violate the Honor Code.\nBoundaries of Collaboration. Verbal collaboration with other students on individual assignments is encouraged after you have given serious thought to each component yourself. However, all submitted written work should be written by yourself individually, and not a collaborative effort or copied from a common source (e.g., a chalkboard). It is not acceptable to work on labs in lockstep with another classmate.\nUse of Computer Software. The use of graphing calculators and computer software to aid in course work is acceptable, as long as it does not substitute for an understanding of the course material.\nUse of Web Resources. The use of Internet resources to aid in course work is acceptable, as long it does not substitute for an understanding of the course material. Plagiarism and direct copying from online (or any other) sources is strictly prohibited.\nUse of Your Own Work from Previous Semesters. If you have previously attempted this course, you may resubmit your work from previous semesters as this semester’s coursework, as long as you understand the underlying material.\nUse of Other Course Resources from Previous Semesters. You may not reference assignments (labs, problem sets, activities) of this course from previous semesters.\nRetention of Course Resources. Assignments and exams from this course may not be committed to dorm repositories or otherwise used to help future students."
  },
  {
    "objectID": "syllabus/index.html#inclusiveness-and-harassment",
    "href": "syllabus/index.html#inclusiveness-and-harassment",
    "title": "E155 Course Syllabus",
    "section": "Inclusiveness and Harassment",
    "text": "Inclusiveness and Harassment\nWe do difficult work in this class and everyone should feel comfortable engaging with the material. We explicitly want you to feel safe doing this work, so it is worth stating that the instructors are committed to making the class a safe space for everyone regardless of race, gender, ethnicity, sexual orientation, religion, and academic history. If you feel that you are experiencing a hostile environment, speak to an instructor immediately."
  },
  {
    "objectID": "syllabus/index.html#educational-accessibility",
    "href": "syllabus/index.html#educational-accessibility",
    "title": "E155 Course Syllabus",
    "section": "Educational Accessibility",
    "text": "Educational Accessibility\nHMC is committed to providing an inclusive learning environment and support for all students. Students with a disability (including mental health, chronic or temporary medical conditions) who may need some accommodation in order to fully participate in this class are encouraged to contact Educational Accessibility Services at ability@g.hmc.edu to request accommodations. Students from the other Claremont Colleges should contact their home college’s disability resources officer."
  },
  {
    "objectID": "resources/blog-reflection-ideas.html",
    "href": "resources/blog-reflection-ideas.html",
    "title": "Blog Reflection Ideas",
    "section": "",
    "text": "The blog on your Quarto portfolio is a space for you to write weekly reflections on what you’re learning in MicroPs. The list below is a non-exhaustive list of ideas of things you could write about if you’re struggling to come up with ideas.\n\nWhat is something interesting you learned recently in lab or lecture?\nHow do you feel like the course is helping you to grow as a person? Reflect on the character traits you listed at the beginning of the course for ideas about specific areas of growth to reflect on.\nWhat did you think about a recent AI prototype? How did your use of AI shape your thinking about what role these tools might play in the future of digital hardware design?\nSearch the Internet for a recent article related to embedded systems. Reflect on those systems through the lens of what you’re learning in MicroPs.\nWhat are some ideas you’re thinking about exploring in your project and why?"
  },
  {
    "objectID": "resources/github-issue-footer.html",
    "href": "resources/github-issue-footer.html",
    "title": "HMC E155",
    "section": "",
    "text": "Share Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "resources/github-issue-footer.html#share-your-feedback",
    "href": "resources/github-issue-footer.html#share-your-feedback",
    "title": "HMC E155",
    "section": "",
    "text": "Share Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html",
    "href": "resources/hdl-coding-guidelines.html",
    "title": "Best Practices for HDL Coding",
    "section": "",
    "text": "Writing HDL code seems similar to writing code that runs on a processor core in a programming language like C or Python. However, this impression is misleading and is the source of a great deal of confusion for many novice digital designers.\nThe number one, most important lesson you need to internalize before you write a line of HDL code is this: you absolutely, 100% must know what hardware you’re trying to imply before you write a line of code. If you just start writing code without having a clear idea of the hardware that you’re hoping to get at the end of the day (e.g., combinational logic blocks and flip-flops), you’re in for a world of hurt.\nThe tips and advice in this document are geared toward helping you become a knowledgeable digital designer."
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#overview",
    "href": "resources/hdl-coding-guidelines.html#overview",
    "title": "Best Practices for HDL Coding",
    "section": "",
    "text": "Writing HDL code seems similar to writing code that runs on a processor core in a programming language like C or Python. However, this impression is misleading and is the source of a great deal of confusion for many novice digital designers.\nThe number one, most important lesson you need to internalize before you write a line of HDL code is this: you absolutely, 100% must know what hardware you’re trying to imply before you write a line of code. If you just start writing code without having a clear idea of the hardware that you’re hoping to get at the end of the day (e.g., combinational logic blocks and flip-flops), you’re in for a world of hurt.\nThe tips and advice in this document are geared toward helping you become a knowledgeable digital designer."
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#before-writing-code",
    "href": "resources/hdl-coding-guidelines.html#before-writing-code",
    "title": "Best Practices for HDL Coding",
    "section": "Before Writing Code",
    "text": "Before Writing Code"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#while-you-are-coding-your-design",
    "href": "resources/hdl-coding-guidelines.html#while-you-are-coding-your-design",
    "title": "Best Practices for HDL Coding",
    "section": "While you are coding your design",
    "text": "While you are coding your design"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#conventions",
    "href": "resources/hdl-coding-guidelines.html#conventions",
    "title": "Best Practices for HDL Coding",
    "section": "Conventions",
    "text": "Conventions\n\nFile Names\n\n\nModule Names\n\n\nSignal Names\n\n\nConstants\n\n\nIndenting\n\n\nCommenting"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#assignment-statements",
    "href": "resources/hdl-coding-guidelines.html#assignment-statements",
    "title": "Best Practices for HDL Coding",
    "section": "Assignment Statements",
    "text": "Assignment Statements"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#general-systemverilog-coding-practices",
    "href": "resources/hdl-coding-guidelines.html#general-systemverilog-coding-practices",
    "title": "Best Practices for HDL Coding",
    "section": "General SystemVerilog Coding Practices",
    "text": "General SystemVerilog Coding Practices"
  },
  {
    "objectID": "resources/hdl-coding-guidelines.html#resources-for-learning-more",
    "href": "resources/hdl-coding-guidelines.html#resources-for-learning-more",
    "title": "Best Practices for HDL Coding",
    "section": "Resources for Learning More",
    "text": "Resources for Learning More\n\nIEEE SystemVerilog Standards\nBest Practices for HDL Coding from Paul Hummel"
  },
  {
    "objectID": "resources/how-to-create-a-github-issue.html",
    "href": "resources/how-to-create-a-github-issue.html",
    "title": "How to Create a Github Issue",
    "section": "",
    "text": "Github issues are an excellent feature to create a suggestion for a correction or to make a suggestion for a feature request."
  },
  {
    "objectID": "resources/how-to-create-a-github-issue.html#introduction",
    "href": "resources/how-to-create-a-github-issue.html#introduction",
    "title": "How to Create a Github Issue",
    "section": "",
    "text": "Github issues are an excellent feature to create a suggestion for a correction or to make a suggestion for a feature request."
  },
  {
    "objectID": "resources/how-to-create-a-github-issue.html#creating-an-issue",
    "href": "resources/how-to-create-a-github-issue.html#creating-an-issue",
    "title": "How to Create a Github Issue",
    "section": "Creating an Issue",
    "text": "Creating an Issue\nTo create a Github issue, navigate to the Github repository.\n\nGeneral Issue\nIf you need to create a general issue, navigate to the Issues tab and follow the instructions. Do your best to give the issue a descriptive title and succinctly explain the feedback in the description. You should also give the issue an appropriate label.\n\n\nSpecific Issue\nIf you are raising an issue about a specific line of code in the code base, you should reference it in your issue. The easiest way to do this is to navigate to the specific source code file in the repository and click on the line number. This will give you a button with three dots. If you click the button, a menu will open with options including the ability to copy a permalink to that line or to directly create a new issue referencing that line.\n\n\n\n\n\n\nFigure 1: Creating an issue from a specific line of code."
  },
  {
    "objectID": "resources/index.html",
    "href": "resources/index.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Development Board Schematic\nE155 Breadboard Adapter Schematic\nE155 Development Board BOM"
  },
  {
    "objectID": "resources/index.html#e155-development-board",
    "href": "resources/index.html#e155-development-board",
    "title": "Resources",
    "section": "",
    "text": "E155 Development Board Schematic\nE155 Breadboard Adapter Schematic\nE155 Development Board BOM"
  },
  {
    "objectID": "resources/index.html#nucleo-stm32-documentation",
    "href": "resources/index.html#nucleo-stm32-documentation",
    "title": "Resources",
    "section": "Nucleo & STM32 Documentation",
    "text": "Nucleo & STM32 Documentation\n\nSTM32L432KC Datasheet\nSTM32L432KC Reference Manual\nSTM32L432KC Programming Manual\nSTM32 Nucleo-32 User Manual\nCortex-M4 Technical Reference Manual\nARMv7-M Architecture Reference Manual"
  },
  {
    "objectID": "resources/index.html#upduino-v3.1-ice40-up5k-documentation",
    "href": "resources/index.html#upduino-v3.1-ice40-up5k-documentation",
    "title": "Resources",
    "section": "UPduino v3.1 & iCE40 UP5K Documentation",
    "text": "UPduino v3.1 & iCE40 UP5K Documentation\n\niCE40 UltraPlus Family Data Sheet\niCE40 Oscillator Usage Guide\niCE40 SPRAM Usage Guide\niCE40 Technology Library\n\nNote on translating from iCEcube2 naming to Radiant\n\nUPduino Documentation\n\nUPduino v3.1 Pinout\nUPduino v3.1 Schematic\n\n\n\nOpen Source Toolchain for iCE40\n\napio\nProject IceStorm\nOSS CAD Suite\nShawn Hymel Introduction to FPGA YouTube Series"
  },
  {
    "objectID": "resources/index.html#embedded-systems-related-newsletters",
    "href": "resources/index.html#embedded-systems-related-newsletters",
    "title": "Resources",
    "section": "Embedded Systems Related Newsletters",
    "text": "Embedded Systems Related Newsletters\n\nThe Embedded Muse\nEmbedded Systems Weekly"
  },
  {
    "objectID": "resources/index.html#systemverilog-resources",
    "href": "resources/index.html#systemverilog-resources",
    "title": "Resources",
    "section": "SystemVerilog Resources",
    "text": "SystemVerilog Resources\n\nSynthesizing SystemVerilog: Busting the Myth that SystemVerilog is only for Verification\nIEEE Standard for SystemVerilog (IEEE Std 1800-2017)"
  },
  {
    "objectID": "resources/index.html#c-programming",
    "href": "resources/index.html#c-programming",
    "title": "Resources",
    "section": "C Programming",
    "text": "C Programming\n\nAppendix C from Digital Design and Computer Architecture: ARM Edition"
  },
  {
    "objectID": "resources/index.html#arm-assembly-quick-reference-cards",
    "href": "resources/index.html#arm-assembly-quick-reference-cards",
    "title": "Resources",
    "section": "ARM Assembly Quick Reference Cards",
    "text": "ARM Assembly Quick Reference Cards\n\nARM® and Thumb®-2 Instruction Set Quick Reference Card\nThumb® 16-bit Instruction Set Quick Reference Card"
  },
  {
    "objectID": "resources/index.html#textbook-resources",
    "href": "resources/index.html#textbook-resources",
    "title": "Resources",
    "section": "Textbook Resources",
    "text": "Textbook Resources\n\nDDCA ARMed: Ch 9. I/O Systems"
  },
  {
    "objectID": "resources/index.html#general-resources",
    "href": "resources/index.html#general-resources",
    "title": "Resources",
    "section": "General Resources",
    "text": "General Resources\n\nBlog Reflection Ideas\nAdafruit Guide to Excellent Soldering\nGuidelines for Drawing Schematics"
  },
  {
    "objectID": "resources/index.html#part-datasheets",
    "href": "resources/index.html#part-datasheets",
    "title": "Resources",
    "section": "Part Datasheets",
    "text": "Part Datasheets\n\nUnderstanding and Interpreting Standard-Logic Data Sheets is a helpful Application Report from Texas Instruments which provides explanations about the information on a standard logic chip data sheet.\nLM386 Datasheet\n\nMCP4801 Datasheet\n2N3906 PNP Transistor Datasheet\nMAN6410 Common Anode Seven-segment Display Datasheet\nAdafruit 3x4 Keypad Pinout"
  },
  {
    "objectID": "resources/index.html#helpful-web-links",
    "href": "resources/index.html#helpful-web-links",
    "title": "Resources",
    "section": "Helpful Web Links",
    "text": "Helpful Web Links\n\nPast versions of E155\n\nFA19\nFA20\nFA21\nFA22"
  },
  {
    "objectID": "resources/index.html#textbook-links",
    "href": "resources/index.html#textbook-links",
    "title": "Resources",
    "section": "Textbook Links",
    "text": "Textbook Links\n\nDigital Design and Computer Architecture\nThe Definitive Guide to ARM® Cortex®-M3 and Cortex®-M4 Processors\nO’Reilly Safari Learning Platform: Academic edition\n\nExpert C Programming"
  },
  {
    "objectID": "resources/index.html#vendors",
    "href": "resources/index.html#vendors",
    "title": "Resources",
    "section": "Vendors",
    "text": "Vendors\n\nSparkFun\nAdafruit\nDigikey\nMouser"
  },
  {
    "objectID": "admin/index.html",
    "href": "admin/index.html",
    "title": "Admin",
    "section": "",
    "text": "Syllabus\nThe course syllabus can be found here.\n\n\nIn-Class Activity PDFs\nPDFs for the in-class activities/quizzes can be found in this shared Google Drive folder (g.hmc credentials required).\n\n\nLab Checkoff Schedule\nA Google Sheet for scheduling lab checkoffs can be found here. (g.hmc credentials required)"
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html",
    "href": "tutorials/lattice-radiant-installation/index.html",
    "title": "Lattice Radiant Installation Instructions",
    "section": "",
    "text": "Lattice Radiant is the synthesis tool provided by Lattice Semiconductor for targeting their FPGA devices."
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#introduction",
    "href": "tutorials/lattice-radiant-installation/index.html#introduction",
    "title": "Lattice Radiant Installation Instructions",
    "section": "",
    "text": "Lattice Radiant is the synthesis tool provided by Lattice Semiconductor for targeting their FPGA devices."
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#download",
    "href": "tutorials/lattice-radiant-installation/index.html#download",
    "title": "Lattice Radiant Installation Instructions",
    "section": "Download",
    "text": "Download\nDownload the software installer from Lattice’s website for your operating system from this link Lattice Radiant Software. (Windows and Linux only. You will need to use virtualization to use Radiant on Mac.). You will also need to create an account to access the download."
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#working-with-the-upduino-v3.1-on-macos",
    "href": "tutorials/lattice-radiant-installation/index.html#working-with-the-upduino-v3.1-on-macos",
    "title": "Lattice Radiant Installation Instructions",
    "section": "Working with the UPduino v3.1 on macOS",
    "text": "Working with the UPduino v3.1 on macOS\nI use the Windows version in a Parallels Windows 11 Virtual Machine. The synthesis and simulation works without a hitch but the programming is finicky. I suspect it has something to do with some wonkiness with the USB drivers and the Virtual Machine. To work around this, you can use the openFPGALoader project which is universal utility for programming FPGAs. Instructions for installation and use can be found here.\nThe easiest way is to directly install it as a Homebrew formula:\nbrew install openfpgaloader\nAfter installation, to program our UPduino v3.1 board, use the command:\nopenFPGALoader -b ice40_generic -c ft232  -f &lt;path_to_.bin_file&gt;"
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#installing-ftdi-drivers",
    "href": "tutorials/lattice-radiant-installation/index.html#installing-ftdi-drivers",
    "title": "Lattice Radiant Installation Instructions",
    "section": "Installing FTDI Drivers",
    "text": "Installing FTDI Drivers\nTo program the UPduino on Windows, you’ll need to install FTDI drivers if they’re not already installed. To do so, go to the Virtual COM Port (VCP) drivers page and download the appropriate drivers for your system.\n\n\n\n\n\n\nCorrect VCP Drivers for M-series Macs\n\n\n\nFor M-series Macs virtualizing Windows, you will need to download the files for an ARM architecture since your installation of Windows is likely using the native ARM architecture instead of virtualizing an x64 instruction set."
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#installation",
    "href": "tutorials/lattice-radiant-installation/index.html#installation",
    "title": "Lattice Radiant Installation Instructions",
    "section": "Installation",
    "text": "Installation\nAs part of the installation, make sure to select the iCE40 UltraPlus family device support package along with the Programmer and Mentor QuestaSim Lattice Edition. After this menu, click through to finish the installation process.\n\n\n\n\n\n\nFigure 1: Installation components to select."
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#licensing",
    "href": "tutorials/lattice-radiant-installation/index.html#licensing",
    "title": "Lattice Radiant Installation Instructions",
    "section": "Licensing",
    "text": "Licensing\nTo run Radiant you will need to also request and install a license for the software. Navigate here and request a node-locked license. This license is designed to be run on a single computer.\nTo download the license you will need to find your Host Network Interface Card (NIC) address. To find the NIC address, follow the steps below.\nFor Windows, from an MS-DOS window (command prompt), use the ipconfig /all command\nFor Linux, from the command prompt, use the ifconfig -a command\n\n\n\n\n\n\nFigure 2: Finding NIC physical address.\n\n\n\nEnter your Host NIC address (without dashes) and click the required checkbox. You do not need to select any of the optional Radiant Free IP. Then click the “Generate License” button.\nAfter receiving the license file (license.dat), follow the instructions in the email about how to install the license. You must: 1. Copy the license.dat file to the location specified in the email (&lt;sw_install&gt;\\license\\license.dat on Windows). &lt;sw_install&gt; is probably C:\\lscc\\radiant\\2024.1 or similar if you installed it in the default location). When you open Radiant for the first time, you’ll probably be prompted to select this license location in the FlexNet License Finder window. 2. Create a new LATTICE_LICENSE_FILE system environment variable pointing to the path of your license file &lt;sw_install&gt;\\license\\license.dat (instructions). 3. Create a new LM_LICENSE_FILE system environment variable pointing to the path of your license file.\n\n\n\n\n\n\nQuestaSim Licensing\n\n\n\nAlthough the step to create the LM_LICENSE_FILE isn’t listed in the installation instructions in the email, it seems to be required to successfully license QuestaSim. The instructions to create this variable are listed in the Licensing User Guide for Windows.\n\n\nThis should ensure that both Radiant and QuestaSim are properly licensed and the files are correctly linked.\n\n\n\n\n\n\nFigure 3: FlexNet License Finder dialog.\n\n\n\nYou can also check the license paths afterwards by using the License Debug Tool under the Help menu."
  },
  {
    "objectID": "tutorials/lattice-radiant-installation/index.html#share-your-feedback",
    "href": "tutorials/lattice-radiant-installation/index.html#share-your-feedback",
    "title": "Lattice Radiant Installation Instructions",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "tutorials/segger-embedded-studio-setup/index.html",
    "href": "tutorials/segger-embedded-studio-setup/index.html",
    "title": "SEGGER Embedded Studio Setup",
    "section": "",
    "text": "If you have not yet installed SEGGER Embedded Studio, first see and follow the instructions in Appendix A: Install SEGGER Embedded Studio & Support Packages.\nIn this section we will use the SEGGER Embedded Studio to create, build, and upload a simple program to blink the LED on your board.\nSEGGER studio development projects are grouped into projects and solutions.\n\nA project contains and organizes everything you need to create a single application or a library.\nA solution is a collection of projects and configurations.\n\nIn most cases, you will be designing a single application and the most straightforward organization is to have a single project within a solution.\nTo start, create a new project by navigating to “File &gt; New Project”. Select create the project in a new solution.\nScroll down and select “A C/C++ executable for STMicroelectronics STM32L4xx” and name the project “blink_demo.”\n\n\n\n\n\n\nFigure 1: New project template.\n\n\n\nSelect the proper Target processor (STM32L432KCUx).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Setting up the target processor.\n\n\n\nOn the next page, leave all the options checked and allow both configurations on the next page. Click finish to close the wizard.\n\n\n\n\n\n\nFigure 3: Project configuration.\n\n\n\nIf you click the arrows to expand the tree of files in the project you will see a main.c file in the source directory and the supporting basic system files and device drivers.\n\n\n\n\n\n\nFigure 4: Project files in default projects.\n\n\n\nNext, open up main.c and edit it to include the following code. This code toggles the GPIO pin PB3 on and off, blinking the on-board LED. A for loop that counts to a set value using a dummy variable serves to create a simple delay so that the LED blinks slow enough to easily see it.\n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : LED blink demo\n\n*/\n\n#include &lt;stm32l432xx.h&gt;\n#include &lt;stdint.h&gt;\n\nint main(void) {\n\n// Initialization code\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN;\n\nGPIOB-&gt;MODER |= GPIO_MODER_MODE3_0;\nGPIOB-&gt;MODER &= ~GPIO_MODER_MODE3_1;\n\nwhile(1) {\n for(volatile int i = 0; i &lt; 20000; i++);\n GPIOB-&gt;ODR ^= (1 &lt;&lt; 3);\n }\n}\n/*************************** End of file ****************************/\nAfter writing the code, build it by running “Build blink_led” from the Build menu or by using the keyboard shortcut F7. If you get any error messages, use the information printed in the output window to locate the error (double clicking on the error message should bring you to the appropriate section of code) and correct the bug. Note that frequently the line previous to the line identified as containing the bug is where the actual problem lies. After successfully resolving any compilation errors you are ready to move on to uploading and debugging your code."
  },
  {
    "objectID": "tutorials/segger-embedded-studio-setup/index.html#create-new-test-project",
    "href": "tutorials/segger-embedded-studio-setup/index.html#create-new-test-project",
    "title": "SEGGER Embedded Studio Setup",
    "section": "",
    "text": "If you have not yet installed SEGGER Embedded Studio, first see and follow the instructions in Appendix A: Install SEGGER Embedded Studio & Support Packages.\nIn this section we will use the SEGGER Embedded Studio to create, build, and upload a simple program to blink the LED on your board.\nSEGGER studio development projects are grouped into projects and solutions.\n\nA project contains and organizes everything you need to create a single application or a library.\nA solution is a collection of projects and configurations.\n\nIn most cases, you will be designing a single application and the most straightforward organization is to have a single project within a solution.\nTo start, create a new project by navigating to “File &gt; New Project”. Select create the project in a new solution.\nScroll down and select “A C/C++ executable for STMicroelectronics STM32L4xx” and name the project “blink_demo.”\n\n\n\n\n\n\nFigure 1: New project template.\n\n\n\nSelect the proper Target processor (STM32L432KCUx).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Setting up the target processor.\n\n\n\nOn the next page, leave all the options checked and allow both configurations on the next page. Click finish to close the wizard.\n\n\n\n\n\n\nFigure 3: Project configuration.\n\n\n\nIf you click the arrows to expand the tree of files in the project you will see a main.c file in the source directory and the supporting basic system files and device drivers.\n\n\n\n\n\n\nFigure 4: Project files in default projects.\n\n\n\nNext, open up main.c and edit it to include the following code. This code toggles the GPIO pin PB3 on and off, blinking the on-board LED. A for loop that counts to a set value using a dummy variable serves to create a simple delay so that the LED blinks slow enough to easily see it.\n/*********************************************************************\n*                    SEGGER Microcontroller GmbH                     *\n*                        The Embedded Experts                        *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\n\nFile    : main.c\nPurpose : LED blink demo\n\n*/\n\n#include &lt;stm32l432xx.h&gt;\n#include &lt;stdint.h&gt;\n\nint main(void) {\n\n// Initialization code\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOBEN;\n\nGPIOB-&gt;MODER |= GPIO_MODER_MODE3_0;\nGPIOB-&gt;MODER &= ~GPIO_MODER_MODE3_1;\n\nwhile(1) {\n for(volatile int i = 0; i &lt; 20000; i++);\n GPIOB-&gt;ODR ^= (1 &lt;&lt; 3);\n }\n}\n/*************************** End of file ****************************/\nAfter writing the code, build it by running “Build blink_led” from the Build menu or by using the keyboard shortcut F7. If you get any error messages, use the information printed in the output window to locate the error (double clicking on the error message should bring you to the appropriate section of code) and correct the bug. Note that frequently the line previous to the line identified as containing the bug is where the actual problem lies. After successfully resolving any compilation errors you are ready to move on to uploading and debugging your code."
  },
  {
    "objectID": "tutorials/segger-embedded-studio-setup/index.html#uploading-the-code",
    "href": "tutorials/segger-embedded-studio-setup/index.html#uploading-the-code",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Uploading the Code",
    "text": "Uploading the Code\nTo upload your compiled code, use the Target menu and select “Connect J-Link”. If you get any errors check that your board is properly connected. If you are still having issues, contact the instructor as you might need to upgrade the firmware on your board from ST-LINK to J-Link.\nAfter connecting the J-Link, download the compiled code to the board by selecting Target &gt; Download blink_led from the menu. If everything is working correctly, you should see a message in the Output window that the download was successful and the green user LED (LD3) on your Nucleo board should start blinking.\nCongratulations, you have successfully built your first project on your microcontroller!"
  },
  {
    "objectID": "tutorials/segger-embedded-studio-setup/index.html#appendix-a-install-segger-embedded-studio-and-support-packages",
    "href": "tutorials/segger-embedded-studio-setup/index.html#appendix-a-install-segger-embedded-studio-and-support-packages",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Appendix A: Install SEGGER Embedded Studio and Support Packages",
    "text": "Appendix A: Install SEGGER Embedded Studio and Support Packages\nDownload Segger Embedded Studio. The current version as of this writing is 7.32. There are versions of the program available for Windows, Linux, and Mac. Make sure to choose the appropriate installer for your computer hardware. You may find the SEGGER Embedded Studio User Guide helpful for answering questions about how to navigate the program.\nYou will also need to download and install the J-Link Drivers for your operating system from here.\nBefore you create your project, you will need to download a few support packages for the CPU on our board. Download the following support packages in SEGGER Embedded Studio (tick the option in package manager gear icon in top right to show all downloaded packages, not just those that aren’t installed yet)\n\nSTM32L4xx CPU Support Package\nCMSIS 5 CMSIS-CORE Support Package\nCMSIS 5 Documentation Package"
  },
  {
    "objectID": "tutorials/segger-embedded-studio-setup/index.html#appendix-b-st-link-to-j-link-firmware-upgrade",
    "href": "tutorials/segger-embedded-studio-setup/index.html#appendix-b-st-link-to-j-link-firmware-upgrade",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Appendix B: ST-LINK to J-Link Firmware Upgrade",
    "text": "Appendix B: ST-LINK to J-Link Firmware Upgrade\nYour STM32 Nucleo boards come with an on-board debugger ST-LINK debugger. This debugger is not compatible out of the box with the SEGGER tools and the firmware needs to be updated to connect to SEGGER Embedded Studio. The boards in your kits should have already been updated so that they are ready to go, but if for some reason your computer is not recognizing the board, you may need to download and perform the firmware upgrade yourself. Instructions on how to do so can be found here. Note that this upgrade process can only be completed on Windows."
  },
  {
    "objectID": "tutorials/segger-embedded-studio-setup/index.html#share-your-feedback",
    "href": "tutorials/segger-embedded-studio-setup/index.html#share-your-feedback",
    "title": "SEGGER Embedded Studio Setup",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html",
    "href": "tutorials/quarto-portfolio-setup/index.html",
    "title": "How to Build a Quarto Portfolio",
    "section": "",
    "text": "By the end of this tutorial you will have created a Quarto website that will serve as your online portfolio for MicroPs this semester."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html#introduction",
    "href": "tutorials/quarto-portfolio-setup/index.html#introduction",
    "title": "How to Build a Quarto Portfolio",
    "section": "",
    "text": "By the end of this tutorial you will have created a Quarto website that will serve as your online portfolio for MicroPs this semester."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html#installing-quarto",
    "href": "tutorials/quarto-portfolio-setup/index.html#installing-quarto",
    "title": "How to Build a Quarto Portfolio",
    "section": "Installing Quarto",
    "text": "Installing Quarto\nThe first step to building your site is to download and install Quarto on your machine. Go to the Quarto website and download the most recent version of the Quarto CLI here.\nYou’ll also need to decide what tool you’ll like to use to write your Quarto code. There are lots of options here, but this tutorial will focus on Visual Studio Code. If you don’t have VS Code installed, install it by downloading the latest version here. Then follow the instructions here to set it up by installing the Quarto VS Code Extension. While you are there, read the full page to understand the basic workflow of using Quarto with VS Code."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html#creating-your-first-quarto-project",
    "href": "tutorials/quarto-portfolio-setup/index.html#creating-your-first-quarto-project",
    "title": "How to Build a Quarto Portfolio",
    "section": "Creating Your First Quarto Project",
    "text": "Creating Your First Quarto Project\nOnce you’ve got Quarto installed, it’s time to get writing. Before we get too much further, let’s have a brief chat about the Quarto workflow.\n\nThe Quarto Workflow\nThe process of going from start to finish with Quarto is normally a four step process. Two of the steps are not strictly required, but strongly recommended. The are:\n\nWrite\nPreview: quarto preview\nRender: quarto render\nPublish: quarto publish\n\n\n\nCreating Your Project\nFirst you need to create a Quarto project. To do so, open up VS Code and then open up the integrated terminal (also fine to use a separate terminal of course if that’s your style).\nThen, navigate to the location where you’d like to create your Quarto project. Normally you’ll need at least a bit of command line knowledge to navigate. If you’re not super familiar, Google is your friend.\nOnce you’re in the location that you want to your project to live in, create a new folder named hmc-e155-portfolio to house your project (Quarto will not create a folder for the files it creates). Then navigate into that folder and run the command quarto create. This will walk you through a series of prompts. Make the following selections.\n? Create › project\n? Type › website\n? Directory › /\n? Title (/) › E155 Portfolio\nThis will create a new project with a few files.\n\n_quarto.yml: This is the Quarto configuration file. It contains project-wide configuration options.\nindex.qmd: This is the home page for your project. Every website project must have an index.qmd file (or to be more specific, a file that renders to index.html)\nabout.qmd: An example About page\nstyles.css: A template cascaded style sheet (CSS) file that can be used to apply custom web styling.\n\n\n\nHello Quarto\nNow that you’ve got your site configured, you can preview it to see what it looks like. To do so, run the command quarto preview in the terminal. This will render the files in your project and open a new browser window displaying your site.\nIf you do this with the default files we’ve created so far you’ll see something that looks like this.\n\n\n\nMaking Your First Edit\n\nAdding a Bio\nNow we’ll make our first edit to the site. Open up your index.qmd page and add a short blurb about who you are. Put your text underneath the section at the top that starts and ends with three dashes (---). This section is called the frontmatter and we’ll talk about what it’s for and how to edit it in a minute.\nAfter you write your text, save the file. Once you do this, you should notice your browser window pointed to the preview refresh and your changes appear. (If not, you may need to manually refresh the page.)\nHere’s the code for mine.\nJosh Brake is an Assistant Professor of Engineering at [Harvey Mudd College](https://hmc.edu).\nPrior to joining the faculty at Harvey Mudd, he completed a Ph.D. and M.S. in Electrical Engineering at the California Institute of Technology and an M.S. and B.S. in Engineering with an Electrical concentration at LeTourneau University. \nHis teaching interests are in the field of engineering, with a particular focus on digital electronics, embedded systems, and optics.\nHe directs the Harvey Mudd Biophotonics Lab where he and a group of talented undergraduate students leverage optics to build tools for biomedicine and optics education. He is the recipient of several external awards, including an NSF CAREER and NSF Engineering Research Initiation award. \nWhen he is not in the classroom, next to the optics table, or spending time with his family, you can find him behind the keyboard typing his latest manifesto on technology, education, and human flourishing for his weekly Substack newsletter, *The Absent-Minded Professor*, which you can find at [joshbrake.substack.com](https://joshbrake.substack.com).\n\n\n\n\n\n\nNote\n\n\n\nThe file extension .qmd stands for Quarto Markdown. If you’re not already familiar with it, Markdown is a lightweight formatting language. Quarto supports Markdown formatting and is super handy for including information like hyperlinks. You can find more information about Markdown formatting here.\n\n\n\n\nAdding Headshot and Links\nNext, we’ll add a headshot and a link to your other professional presence on the web. To do this, we’ll first need to learn how to include images on our site.\nFirst, create a subfolder in your project to hold all the images and name it images. Then put a headshot image of yourself in the folder and name it headshot.jpg. The exact filename and extension is not critical as long as you modify the code that follows to match your situation.\nTo include the image in your page, use the following code.\n![](images/headshot.jpeg)\nSave your file and check out the preview. You should see an image in the middle of your page. If not, double check that your paths are correct and that Quarto can find the image.\n\n\n\n\n\n\nFigure 1: Initial headshot image\n\n\n\nYou can also add a link to your Github using Markdown syntax.\nFor example, you could write something like:\n[Link to Github](https://github.com/joshbrake)\nGreat, if we wanted to make this look all nice we could do some additional work with it to style it with CSS to get the image centered and scaled, but instead we’ll use a handy feature in Quarto called templates to make it look nice.\n\n\nMaking Your Home Page Pretty with Quarto Templates\nTo use a Quarto template, we’ll need to modify the front matter of the .qmd file. As mentioned earlier, this is the part of the document at the top of the document that starts and ends with a line with three dashes (---). In particular, we’ll modify it to take advantage of Quarto About Pages.\nRight now, your front matter just has a single key-value pair to set the title. We’ll modify this to give Quarto some additional instructions for how we’d like the page formatted.\nTo do this, we’ll add a a few new entries to the front matter.\n\nA new key image where the value is a link to our headshot image\nA new key about with two values which themselves are keys, template and links. These keys will have values themselves where the values for links are a list of items.\n\nModify your front matter to match the text in the image below, changing the link to the image and the hyperlinks to Github and LinkedIn to match yours.\n\n\n\n\n\n\nFigure 2: Modifying home page frontmatter.\n\n\n\nOnce you complete this step, your new home page should look like the following.\n\n\n\n\n\n\nFigure 3: About page using Quarto template.\n\n\n\n\n\n\nCreating Your Blog\n\nSetup\nQuarto also supports blogging. You can read more in the docs here. You’ll create a blog this semester with short weekly posts to reflect on and share your work and reflect on your learning.\nTo set up your blog, create a new folder titled posts/ and a new file titled blog.qmd in the root directory of the Quarto project.\nModify the frontmatter at the top of your blog.qmd file to match the following. This will set up your blog to list the entries contained in posts in descending order from most recent.\n---\ntitle: \"E155 Blog\"\nlisting:\n  contents: posts\n  sort: \"date desc\"\n  type: default\n  categories: false\n---\nNext create your first post by creating a new file in the posts/ folder titled first-post.qmd.\nAdd the following frontmatter and add a sentence of placeholder text for now.\n---\ntitle: \"Hello Quarto\"\ndescription: \"Welcome to my Quarto portfolio\"\nauthor: \"Josh Brake\"\ndate: \"8/23/24\"\ncategories:\n  - reflection\n  - labreport\ndraft: false\n---\n\n\n\n\n\n\nNote\n\n\n\nIf you want to create draft posts you can use the draft key in the frontmatter of the files in your posts folder. This will allow you to see the files when you preview your side, but not when you publish it.\n\n\n\n\nLinking the Blog to Your Navbar\nYou’ll notice if you navigate back to the home of your site, you’ll be unable to easily find your way back to the blog page without manually typing the address in your browser’s navigation bar. To fix this, we’ll add a link to the navbar.\nOpen up your quarto.yml file and add a new entry to the list located under the keys website -&gt; navbar -&gt; left. The new list item should have the following key-value pairs:\nhref: blog.qmd\ntext: Blog\nOnce you do this, preview your site and you should see a new entry on the navbar. Click it to make sure it brings you to the appropriate page."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html#your-turn",
    "href": "tutorials/quarto-portfolio-setup/index.html#your-turn",
    "title": "How to Build a Quarto Portfolio",
    "section": "Your Turn",
    "text": "Your Turn\nNow that you’ve got the ropes, it’s your turn to make some more modifications. Using the instructions below and the list of specifications found here or linked in the sidebar. The goal of this list is to give you a feel for how the specification grading scheme will work in E155 this fall.\nSpecs\n\nModifying Folder Structure\nModify your site to have the following folder structure and pages.\n.\n├── _quarto.yml\n├── _site/\n├── images/\n│   └── headshot.jpeg\n├── labs/\n│   └── lab1/\n|       ├── images/\n│       └── lab1.qmd\n│   └── lab2/\n|       ├── ...\n│   └── ...\n├── posts/\n├── blog.qmd\n├── index.qmd\n└── styles.css\n\n\nCustomizing Your Site\nTo get your site to look like the file structure above, you’ll need to delete the about.qmd page that got created by default when we created our project. Once you delete the file, reload your site with quarto preview and you’ll notice that there is now a broken link on your navbar.\nTo fix this, we’ll need to modify the navigation bar of the site.\n\n\n\n\n\n\nFigure 4: Navbar with broken link.\n\n\n\nTo do that, go to your _quarto.yml file. This file is what’s known as a yaml file, a human-readable file format commonly used for configuration files. It’s used to configure project-wide settings for our project and is exhibits a dictionary data structure with key-value pairs.\nIn this file, delete the list entry for about.qmd which is listed underneath website -&gt; navbar -&gt; left.\n\n\n\n\n\n\nFigure 5: Removing navbar from page.\n\n\n\nOnce you delete this line, reload your website to see the changes to your navbar. You should see the entry disappear.\n\n\nTracking Your Work With Git\nIf you haven’t yet set up Git on your machine or are not familiar with it, complete the Git Tutorial before continuing. You’ll need to have Git set up before you move to the next step to publish your site.\n\nInitialize Git Repo\nInitialize a Git repository in the directory of your Quarto project and add a README.md.\n\n\nConfigure .gitignore\nWhen you configure the repository for your site, make sure to ignore the Quarto rendered output. If you don’t it will make your diffs much more complicated.\nThe rendered materials lives in two folders in your Quarto project, /.quarto/ and /_site/. Create a .gitignore file in the root of your project directory and add these two lines. You may also want to add a few additional items that should not be included in your repository including system files like .DS_Store (Mac) and Thumbs.db. You should pay careful attention to the changed files in your changed files and add any necessary extensions to your .gitignore file before you commit anything.\nOnce you commit a file into a repo, it can be challenging to go back and remove it.\n\n\nCommit and Push\nReview the changed files and commit your changes. Then push to the remote.\n\n\n\nPublishing\nOnce you finish editing your site locally, setting up git, and checking that everything looks good using the preview command, it’s time to publish.\nThere are a number of ways that you can publish your work with Quarto. The simplest way is to directly copy the contents _site directory where Quarto puts all the files for your website when you run quarto render to a web server.\nBut Quarto also offers a few additional built-in solutions using the quarto publish command that make it easy to get your work live on the web. You can read the documentation here for more information, but for this class we’ll recommend Github Pages.\nGithub pages allows you to publish content based on source code managed within a Github repository. Follow the instructions in the Quarto docs to configure your project to be published. Make sure that you follow all the steps in the instructions to properly configure your git repository to use gh-pages as the source branch.\n\n\n\n\n\n\nWarning\n\n\n\nBefore you follow the instructions make sure you’ve got all your changes committed. If you don’t, when you run git reset --hard you’ll discard all your changes!\n\n\nHere is a short Loom video to walk you through the process of publishing your Quarto portfolio as a Github Pages site."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html#wrapup",
    "href": "tutorials/quarto-portfolio-setup/index.html#wrapup",
    "title": "How to Build a Quarto Portfolio",
    "section": "Wrapup",
    "text": "Wrapup\nCongratulations! You now have your portfolio website for E155 set up and published to the web."
  },
  {
    "objectID": "tutorials/quarto-portfolio-setup/index.html#share-your-feedback",
    "href": "tutorials/quarto-portfolio-setup/index.html#share-your-feedback",
    "title": "How to Build a Quarto Portfolio",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html",
    "href": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "",
    "text": "Open Lattice Radiant. If you are prompted for a license file, navigate to it. See the Radiant install instructions if needed.\nCreate a new project and name it “iCE40_demo”. Select the project location in the directory you wish. Make sure that the path does not include spaces since this often leads to errors later in the synthesis process. You do not need to add any existing HDL files to the project.\nIn the “Select Device” menu, select the iCE40UP5K and the SG48 package. On the next page, select Lattice LSE as the synthesis tool.\n\n\n\n\n\n\nFigure 1: New project setup."
  },
  {
    "objectID": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#netlist-analyzer",
    "href": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#netlist-analyzer",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Netlist Analyzer",
    "text": "Netlist Analyzer\nAfter synthesizing your design, it is worth taking a look at the Netlist Analyzer. This tool provides a block diagram view of the design. This is a helpful tool to make sure that the Verilog you wrote is implying the hardware that you intend. Remember that as a digital designer you should always think about the underlying hardware and simply write the Verilog idioms to imply it. Approach HDL like a traditional programming language at your peril!\nIf we look at the Netlist Analyzer (found under “Tools &gt; Netlist Analyzer” or the green and black icon in the toolbar), we will open a window which shows a block diagram. We see that we have implied an adder, a mux to control the value to the registers, the HSOSC module, and a 25-bit-wide register.\n\n\n\n\n\n\nFigure 5: Netlist analyzer window."
  },
  {
    "objectID": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#resource-usage",
    "href": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#resource-usage",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Resource Usage",
    "text": "Resource Usage\nThere is also some useful information in the Reports tab under Project Summary in the Resource Usage section. In particular, this section will show us the number of registers, look-up tables, IO buffers, and embedded RAM blocks (EBRs) that we have implied in our design. For this design, we have 25 registers for storing the current count. An additional 3 logic cells are needed for their LUT4s to provide the additional logic (adder, mux, inverter).\n\n\n\n\n\n\nFigure 6: Resource usage report."
  },
  {
    "objectID": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#device-assignment-device-constraint-editor",
    "href": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#device-assignment-device-constraint-editor",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Device Assignment: Device Constraint Editor",
    "text": "Device Assignment: Device Constraint Editor\nWhen you first synthesize the design, the inputs and outputs of your top-level module will be randomly assigned to I/O pins. Next, you need to set the pin assignments to route the signals to the I/O pins that you desire.\nOpen the Device Constraint Editor and find the signal name and assign it to your desired pin. In this example, we will route the “led” output to GPIO 42. Select the table entry in the “Pin” column associated with the LED signal and enter “42”. You will notice that the currently routed pin is labeled in parentheses, 36 in this example. To update the design to route to our desired GPIO pin, we need to resynthesize the design. Click the green play button again to run the toolchain. When you do this for the first time, you will be asked to save a .pdc (pin device constraint) file. Name and save the file. After synthesis completes, open the Device Constraint Editor and confirm that the desired and routed pins match. In this case you should see “42(42)” in the table entry corresponding to the led output.\n\n\n\n\n\n\nFigure 7: Pinout diagram."
  },
  {
    "objectID": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#device-programming",
    "href": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#device-programming",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Device Programming",
    "text": "Device Programming\nTo get our design working on our board, we need to program it to the flash memory onboard the UPduino board.\nEach time the FPGA powers up or resets, it reconfigures itself over a serial peripheral interface (SPI) connection from a binary (.bin) configuration file on a flash memory chip.\nTo program the device, we need to set up the programmer to put the .bin file that is generated by our synthesis tool onto the flash chip.\nClick the button in the toolbar to open the programmer (the icon is the chip with a blue arrow pointing downward) or using the menu Tools &gt; Programmer.\nConnect your UPduino board to your computer and click the “Detect Cable” button in the “Cable Setup” sub-window on the right of the Programmer window. You should see a message noting that “INFO - Board with FTDI USB Host Chip detected.” in the output window. If the host chip is not detected, you may need to install FTDI drivers for the device.\nNext we need to correctly configure the programming toolchain to program our device. By default, the UPduino board only enables programming of the flash chip on board and not the onboard compressed random access memory (CRAM) of the FPGA itself. To do this, highlight the device in the list view and open the “Device Properties” window either by using the icon in the toolbar (chip with pencil on top) or by right-clicking on the entry in the table and selecting the “Device Properties” option.\nChange the default entries to the following selections:\n\nSet Target Memory to External SPI Flash Memory\nSet operation to Erase, Program, Verify\nUnder SPI Flash Options set\n\nFamily: SPI Serial Flash\nVendor: WinBond\nDevice: W25Q32JV\nPackage: 208mil 8-pin SOIC\n\n\nAfter configuration, the block diagram should look like this.\n\n\n\n\n\n\nFigure 8: Flash programming setup.\n\n\n\nAfter updating the configuration, you are ready to program the device. (Note: on your first run, you may get a firewall warning that a new program “cableserver” is being run and needs access. Allow access to the program.)\nYou should see a series of outputs printing in the output window as the programmer cycles through the various pieces of the programming process (initialization, enabling, erasing, programming, verifying, etc.). After the programming finishes, you should see a message that the programming operation was successful."
  },
  {
    "objectID": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#share-your-feedback",
    "href": "tutorials/lattice-radiant-ice40-ultraplus-project-setup/index.html#share-your-feedback",
    "title": "Lattice Radiant iCE40 UltraPlus Project Setup",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lab/lab1/index.html",
    "href": "lab/lab1/index.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab you will familiarize yourself with the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards we will be using this semester."
  },
  {
    "objectID": "lab/lab1/index.html#introduction",
    "href": "lab/lab1/index.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab you will familiarize yourself with the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards we will be using this semester."
  },
  {
    "objectID": "lab/lab1/index.html#learning-objectives",
    "href": "lab/lab1/index.html#learning-objectives",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nAssembled your development board for the class and tested out your MCU and FPGA boards.\nWritten a Verilog module to control LEDs and a 7-segment display.\nProgrammed the FPGA with Verilog code.\nGained confidence in building, assembling, testing, and debugging circuits.\nInterfaced a 7-segment display to the board."
  },
  {
    "objectID": "lab/lab1/index.html#requirements",
    "href": "lab/lab1/index.html#requirements",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Requirements",
    "text": "Requirements\nFollow the steps in this guide to test your FPGA and MCU boards. Write some Verilog code to exercise the FPGA using the switches, LEDs, and a 7-segment display to ensure your board is operational. Simulate and synthesize your code, then upload it to the flash memory and re-test the board. Hook up a 7-segment display and demonstrate that it works."
  },
  {
    "objectID": "lab/lab1/index.html#before-you-start",
    "href": "lab/lab1/index.html#before-you-start",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Before You Start",
    "text": "Before You Start\nBefore you start working on this lab, you should familiarize yourself with the documentation for both the UPduino v3.1 and Nucleo-L432KC boards. The website has links for the UPduino v3.1 User Guide and the Nucleo-L432KC User Manuals on the Resources tab. These two documents contain information that will be helpful for answering questions that you may have during the course of this lab."
  },
  {
    "objectID": "lab/lab1/index.html#background",
    "href": "lab/lab1/index.html#background",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Background",
    "text": "Background\nIn the 1980’s and 1990’s, digital design projects were built from a truckload of chips, each containing a few logic gates such as 74xx series logic gates or simple programmable array logic chips (PALs). Such projects involve placing and wiring together dozens of chips on a breadboard. It was easy to make a wiring mistake or burn out a chip and spend hours tracking down the problem. Now you can perform all of your digital logic on a single field-programmable gate array (FPGA) to greatly reduce the necessary wiring and number of chips. Later in the course, you will use the Cortex-M4 microcontroller to write programs in assembly language and C that can interface with external hardware and the FPGA."
  },
  {
    "objectID": "lab/lab1/index.html#nucleo-l432kc-development-board",
    "href": "lab/lab1/index.html#nucleo-l432kc-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Nucleo-L432KC Development Board",
    "text": "Nucleo-L432KC Development Board\nThe Nucleo-L432KC development board provides a convenient platform to test and develop embedded systems applications. The board is focused around an STM32L432KC MCU and provides voltage regulators to provide power to the chip, various breakout headers which allow access to the pins of the microcontroller chip, a reset button and user input button, configuration jumpers, and an embedded ST-LINK programmer/debugger.\n\nProgramming\nThe STM32L432KC has an embedded ST-LINK/V2-1 programmer and debugger as described in the Nucleo-32 User Manual. The main purpose of the ST-LINK is to provide the ability to interface with the serial wire debug (SWD) interface of the MCU via USB.\nThere are a variety of integrated development environments (IDEs) which can be used to interact with the device including PlatformIO, Keil μVision, and SEGGER Embedded Studio. The IDEs provide a helpful wrapper around compiler toolchains such as GNU Compiler Collection (GCC) toolchain to facilitate easy programming and debugging. In this course you are welcome to use any IDE you would like, although instruction and support will be focused around SEGGER Embedded Studio which is based on the GCC toolchain.1"
  },
  {
    "objectID": "lab/lab1/index.html#upduino-v3.1-fpga-development-board",
    "href": "lab/lab1/index.html#upduino-v3.1-fpga-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "UPduino v3.1 FPGA Development Board",
    "text": "UPduino v3.1 FPGA Development Board\nThe UPduino v3.1 is developed by tinyvision.ai and designed around a Lattice Semiconductor UP5K field programmable gate array (FPGA). Section 5.3 of the iCE40 UltraPlus Family Data Sheet (FPGA-DS-02008-2.0) explains the naming of the chip.\n\n\n\n\n\n\nFigure 1: ice40 Part Number Description\n\n\n\nThe Lattice UP5K is very similar to the Cyclone IV architecture that is used to introduce FPGAs in E85. At its root, the FPGA consists of Logic Cells (Lattice’s version of the Intel/Altera Logic Elements you learned about in E85) which can be internally connected within Programmable Logic Blocks (PLBs) within the FPGA to form digital circuits. Each Logic Cell (LC) consists of a 4-input look-up table (LUT) and a programmable D flip-flop, along with additional clock control and carry logic. Figure 3.2 from the FPGA datasheet shows the basic architecture of a PLB and LC.\n\n\n\n\n\n\nFigure 2: ice40 PLB Block Diagram.\n\n\n\nThe UP5K on our UPduino v3.1 board is the 48-pin QFN package. As you can see from the table, it contains 5280 logic cells, 30 Embedded Block Ram (EBR) Memory Blocks of 4 Kbits each, 4 256-bit Single Port synchronous RAM Memory Blocks, and an on-board high-frequency (48 MHz) and low-frequency (10 kHz) oscillator.\n\n\n\n\n\n\nFigure 3: ice40 Resource Table.\n\n\n\n\nDigital Design Synthesis and Programming\nThe FPGA is programmed using the onboard programmer via the synthesis tool Lattice Radiant. After setting up and compiling the Radiant project, Radiant will generate bitstream files which are used to configure the FPGA.\nMore details will be provided later in this lab writeup."
  },
  {
    "objectID": "lab/lab1/index.html#e155-development-board",
    "href": "lab/lab1/index.html#e155-development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "E155 Development Board",
    "text": "E155 Development Board\nIn this lab you will assemble a custom printed circuit board which hosts the MCU and FPGA boards. The board has several features that will be convenient for developing embedded systems such as:\n\nPins which can be directly routed from the MCU to the FPGA via the board\nExtension headers for the mikroBUS and 6-pin PMOD standard\nUser configurable LEDs, pushbuttons, and slider switches.\nHeader to route pins via a ribbon cable to a separate breadboard adapter PCB which can be inserted into a solderless breadboard.\n\n\n\n\n\n\n\nFigure 4: Annotated sections of the development board.\n\n\n\nThe board has several main sections that you should make yourself aware of. They are annotated in the image above.\n\nVoltage Regulators and Power Terminal: A +5 V (NCP1117DT50RKG) and +3.3 V (NCP1117DT33T5G) low-dropout (LDO) voltage regulator which is used to regulate the input provided via the power terminal on VIN. Make sure to check with the schematic to ensure that you put the regulators in their proper places. See Powering the Board for more details.\nFPGA, MCU, mikroBUS, and PMOD sockets: These sockets are populated with female headers for the MCU, FPGA, and other extension sockets to be plugged into.\nReset Push Buttons: The reset pushbuttons are connected to the reset inputs on the MCU and FPGA respectively. The MCU reset button will cause the code to begin execution from the first instruction. The FPGA reset button causes the FPGA to reconfigure itself from the on-board RAM which stores the configuration file for the design you have uploaded.\nConfiguration Jumpers: The configuration jumpers on the board allow you several options to set the power and signal connections for the MCU and FPGA. J2, J3, and J4 control the mikroBUS reset signal and the power for the FPGA and MCU boards respectively. The mikroBUS reset signal can also be connected to MCU pin PA12 to enable the MCU to reset the connected peripheral via software. The configuration jumper J5 is a 2x8 header with MCU pins on the left hand side and FPGA pins on the right hand side. Note that on version v4 of the board, J5 has been replaced with an 8-pin DIP switch with the reference designator SW7. The functionality however, remains the same as the jumper. By attaching a jumper between the pins in the same row, the MCU pin on the left side of the jumper can be directly routed to the FPGA pin on the right hand side via traces on the PCB. This allows for convenient and high-fidelity interfaces between the MCU and the FPGA without the need for external wires.\nRibbon Cable Connector: The ribbon cable connector is used to route a subset of the MCU and FPGA pins out to a cable which connects to the breadboard adapter board.\nMCU, FPGA, and Slide Buttons: The push and slide buttons on the board are routed to pins on the MCU and FPGA in order to provide on-board options to toggle GPIO pins on the respective devices. Note that all of these buttons are configured as active low (i.e., closing the switch connects the pin of the device to ground) without any hardware pullup resistors. In order to use them, you must configure the internal pullup resistors on the MCU or FPGA in order to avoid floating logic levels."
  },
  {
    "objectID": "lab/lab1/index.html#assembling-the-board",
    "href": "lab/lab1/index.html#assembling-the-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Assembling the Board",
    "text": "Assembling the Board\nIn this section you will walk through the steps to assemble your board. The PCB has both through hole technology (THT) and surface mount technology (SMT) parts. SMT parts are generally preferred on PCBs since they are more compact and easier for machines to solder although THT parts are typically easier for beginners to solder. If you haven’t done much (or any!) SMT soldering before, don’t worry! One of the points of this lab is to give you a chance to develop this skill!\nAll the parts you need to build your board are provided in your kit bag. Typically, it is easiest to start with the SMT parts before soldering the THT parts since the board will lay flat. So we’ll start by soldering the SMT components."
  },
  {
    "objectID": "lab/lab1/index.html#assembly-tips",
    "href": "lab/lab1/index.html#assembly-tips",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Assembly Tips",
    "text": "Assembly Tips\nSoldering is a skill that you need to practice just like anything else. The most important thing to remember when soldering is that it is roughly 100x easier to solder than to desolder a component. So, whenever possible, make sure that you align the component correctly before soldering all the pins. Often the best way to do this is to solder a single pin on one side and then confirm that the component is correctly aligned before soldering the rest of the pins. If something is misaligned, then this will make it easy to correct since you only will need to reflow a single solder joint. A few additional tips:\n\nSoldering often will make you wish you had another hand or two. Soldering SMT components in particular can be a bit tricky because you need to hold the component with tweezers to align it. A good strategy is to first melt a little bit of solder on one of the pads and then grab the component with tweezers while holding the iron in your other hand to reflow the solder and align it.\nWhen soldering THT headers like those used for the sockets, make sure that the headers are oriented correctly (most of the time perpendicular to the PCB surface). One tip is to insert a strip of male headers into a breadboard and then attach the female headers and set the PCB upside down on top of the male headers to solder them. If you do end up making a mistake and need to desolder a strip of header pins, the plastic shroud can be removed in order to let you pull out individual pins. See this YouTube video for an example. Although in the video he shows the example for a male header pin strip, you can do the same thing with a female strip as well."
  },
  {
    "objectID": "lab/lab1/index.html#suggested-soldering-order",
    "href": "lab/lab1/index.html#suggested-soldering-order",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Suggested Soldering Order",
    "text": "Suggested Soldering Order\nBelow is a recommended soldering order.\n\nSolder the voltage regulators. Put a bit of solder on the big square pad and reflow while bringing the regulator on top in order to solder it. You can apply heat to the pad via the metal edge at the top of the regulator.\n\n\n\n\n\n\n\nFigure 5: Voltage regulator soldering procedure.\n\n\n\n\nPrepare to solder the remaining SMT components (resistors, capacitors, and LEDs) by applying a small amount of solder to one pad of the SMT footprints R1-R11, C1-C4, and D1-D8..\nSolder the decoupling (also known as bypass) capacitors C1-C4 around the regulators. These are used to smooth out any transients and ensure smooth, constant voltages. These capacitors have no polarity, so either way is fine.\nNext, solder the resistors on the board. Pay careful attention to make sure that you solder the correct resistors by referring to the board schematic (available on the course website).\nNext solder the LEDs. The LEDs are polarized, so you’ll need to make sure to solder them the right direction or they won’t work. There is an arrow on the bottom of the package which indicates the direction of the current flow from the anode to the cathode. Again, refer to the schematic for proper alignment. When looking at the PCB with the text facing upright, the cathode should go on the left hand side (connected to its current limiting resistor). There are three different color LEDs. D1 is red (VIN), D2-D5 are green (connected to the MCU), and D6-D8 are blue (connected to the FPGA). After finishing this step, you are finished with all the SMT components!\n\n\n\n\n\n\n\nFigure 6: LED and current limiting resistors.\n\n\n\n\nNow it’s time to tackle the THT components. Put the components into their respective places and solder them in. Pay careful attention to ensure that the female header strips are correctly aligned and perpendicular to the board. You will need to snap off 2- and 3-pin headers from the provided 40-pin header strip in order to populate J2-J4. The easiest way to do this is to use a pair of needle nose pliers to snap off the right number of pins.\nAfter finishing the main development board, follow the same procedure to assemble the breadboard adapter PCB.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Make sure the notches are both pointing the same direction.\n\n\n\n\n\n\n\n\n\n\n\n(b) The triangle on the connector should match with the red wire in the ribbon cable.\n\n\n\n\n\n\n\n\n\n\n\n(c) Crimping alignment.\n\n\n\n\n\n\n\nFigure 7: Ribbon cable alignment procedure.\n\n\n\nUse the included insulation-displacement contact (IDC) ribbon cable connectors and the spool of ribbon cable in the lab to make yourself a short (~6-12”) cable. You have probably done this before in E80, but if you don’t remember how, see the video here. Cut the cable to length with the flush cutters in the toolbox and use either a vise or the cable assembly tool found in the E155 cabinet. Please make sure to put it back after you are finished. If you can’t find it around the lab, ask an instructor.\nFinally, solder the 20-pin male headers and 2x20 pin cable connector onto the breadboard adapter PCB, making sure that the pins are all correctly aligned and perpendicular to the PCB.\nCongratulations, you are now finished assembling your board and ready to test it! The photo below shows an example of what the board should look like when it is finished.\n\n\n\n\n\n\nFigure 8: Fully assembled development board."
  },
  {
    "objectID": "lab/lab1/index.html#powering-the-board",
    "href": "lab/lab1/index.html#powering-the-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Powering the Board",
    "text": "Powering the Board\nThere are three different ways to power the components on the development board: (1) via the VIN power input, (2) via the FPGA’s USB connection, and (3) via the MCU’s USB connection. In this section we will walk through the various ways to power the board to make sure that you are aware of how to properly power the board and avoid any issues which might damage the components on board.\nThe +5 V and +3.3 V voltage regulators provide power for the various components. All logic levels are +3.3 V unless stated otherwise. So, the +3.3 V supply is used to power the various buttons on the board.\n\nPowering through VIN\nTo power through VIN, apply a voltage to the power screw terminal between VIN and GND. The NCP117 series can accept voltages up to +20 V but in most scenarios you will likely want to use a VIN between +6-12 V. Be aware that VIN should always be more than +5 V for both regulators to function properly. When powering via VIN, the jumpers J3 (FPGA_+5V) and J4 (MCU_+5V) should be shorted in order to apply the +5 V output from the regulator to the MCU and FPGA +5 V pin.\n\n\nPowering via USB\nIt is also possible to power the board via a USB connection to either the MCU or FPGA board. Each board has an onboard voltage regulator to create a stabilized +5 V output on the boards respective +5 V pins. Assuming J3 and J4 are shorted, this +5 V output from whichever board is connected to USB power is fed back to the +5 V line (which is also the output of the +5 V regulator) and thus powers the other components connected to that net.\n\n\n\n\n\n\nTesting Voltage Regulators\n\n\n\nBefore connecting your MCU and FPGA boards, check the voltage regulators are on correctly by connecting to a lab DC power supply using the screw terminals and using a multimeter to confirm that the +3.3 V rail is +3.3 V and the +5 V rail is +5 V. If you read +5 V on the +3.3 V or vice versa, you have installed the regulators in the wrong place and need to swap them. If you read a low voltage (less than ~0.1 V), you likely have a bad solder joint on the back pad of the respective regulator and need to reflow the solder joint to make a better connection."
  },
  {
    "objectID": "lab/lab1/index.html#testing-the-boards",
    "href": "lab/lab1/index.html#testing-the-boards",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing the Boards",
    "text": "Testing the Boards\nTo test the boards, you will upload a simple design to the FPGA which toggles an LED on and off and some code on the MCU to read in the toggling GPIO pin and echo is back to the FPGA. This will ensure that the board is working properly and that you have good communication between the two devices.\nTo familiarize yourself with how to program the FPGA using Lattice Radiant, see the Lattice Radiant iCE40 UltraPlus Project Setup tutorial. This tutorial has information about how to create a project in Radiant and how to synthesize and upload designs to your FPGA board.\nAfter working through the tutorial, download the Radiant project file fpga_dev_board_test.zip under the Lab 1 subfolder from the course GitHub and use it to program your FPGA. This design toggles pin P25 at about 1 Hz. If you have the switch properly set on SW7, P25 is connected to PA9 and so you will see LED D3 blinking.\nAfter programming your FPGA, the next step is to upload the code to the MCU that will read the value of the toggled LED from the FPGA and echo it back on another pin. See the tutorial titled “Segger Embedded Studio Setup” to familiarize yourself with the process of installing and setting up SEGGER Embedded Studio (SES). If you are using a lab computer, SES is already installed. The lab computers may also have other versions installed.\nAfter working through the tutorial, download the SES solution folder from the course GitHub titled mcu_dev_board_test.zip. Then, double click on the .emProject file or use the File → Open Solution option in SES to open the solution. This project contains a simple program that monitors the status of PA9 (which is connected to P25 through the appropriate jumper on J5. Make sure you have the jumper attached to connect PA9 to P25). Build and download the project to your MCU.\nNow, in addition to LED D3 (PA9/P25) blinking, you should see LED D2 (PA10/P23) and LED D7 (P38) blinking as well."
  },
  {
    "objectID": "lab/lab1/index.html#fpga-design",
    "href": "lab/lab1/index.html#fpga-design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "FPGA Design",
    "text": "FPGA Design\nNow it’s your turn to take the wheel and create your own design and dust off your digital design chops! Your goal is to write some Verilog modules to further test the hardware on your board and operate a 7-segment display. The system should have the following inputs and outputs:\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nthe four DIP switches (on the board, SW6)\n\n\nled[2:0]\noutput\n3 LEDs (you may use the on-board LEDs)\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThe following tables define the relationship of the LEDs to the switches and clock.\n\n\n\n\nS1\nS0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\n\n\nS3\nS2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\n\n\n\n\n\nled[2]\n\n\n\n\nBlink at 2.4 Hz\n\n\n\n\n\n\n\n\n\n\nClock Generation\n\n\n\nTo generate the clock for your design, use the onboard high-speed oscillator. This is the same strategy as in the FPGA testing source code you downloaded earlier to test the board. If you look at that Verilog code, you’ll notice an instantiated module called HSOSC (for High-Speed OSCillator). This module is part of the iCE40 Technology Library (see the iCE40 Technology Library document linked on the course website) and is a built-in module included with Lattice Radiant designed for controlling the internal oscillator on the iCE40 chip. You can simply copy the line from the testing program and use it in your project.\n\n\n\nCreate Your Git Repository\nThe first step before you begin writing any code is to create a Git repository. Follow the following steps to get started with your project.\n\nCreate a new folder for your project. Here is a suggested template folder structure to use. Add a few sentences to your README to describe the contents of the repository. For example, for this lab you might say something about holding code to verify that your FPGA and MCU are working properly.\n\n/\n├── fpga\n│   ├── src\n│   ├── sim\n│   ├── radiant_project\n│   ├── .gitignore\n├── mcu\n│   ├── src\n│   ├── segger_project\n│   ├── .gitignore\n├── README.md\n\nPopulate your .gitignore files. This file tells git which files and folders should not be tracked. It’s best practice to ignore many of the miscellaneous configuration files that Radiant and SEGGER Embedded Studio generate. Sample .gitignore files are included below. Paste the contents of these files into the .gitignore files you created.\n\n\nSample Radiant .gitignore\n# Lattice Radiant files\n*.html\nimpl*/\n*.xml\n.build_status\n.run_manager.ini\n.recovery\n.spread_sheet.ini\n.spreadsheet_view.ini\n*.dir/\n*.log\n*.tcl\n*.ccl\n*.srp\n*.dmp\n._Real_._Math_.vhd\n\n\nSample SEGGER Embedded Studio .gitignore\n# Segger Embedded Studio\n**/Output/\n**/Debug/\n*.emSession\n*.jlink\n\n\nInitialize your git repository using git init.\nAdd the existing files in your folder using git add .. (Note: the . means to add all the contents of the current directory, so you’ll need to make sure you’re at the root).\nMake an initial commit with the folder structure above by typing git commit -m \"Initializing Lab 1 repository\".\nOpen the Github web interface and create a new repository on Github (link). Name your repository something descriptive like e155-lab1. Optionally add a short description.\nLink your local git repository to the new remote repository by adding a new remote. This will look something like git remote set-url origin git@github.com:&lt;username&gt;/&lt;repo&gt;.git where you’ll need to replace &lt;username&gt; and &lt;repo&gt; with your specific information. For my example, this command is `git remote set-url origin git@github.com:joshbrake/e155-lab1.git\nPush your local commit to the remote using git push origin main. If git complains that it doesn’t know what main is, then your branch might be named master. In this case, run git branch -m master main and run the push command again.\nNavigate to your repository page on Github and you should see your folder structure there.\n\nHere’s a video walking through the steps above as well.\n\n\n\n\n\n\nDesign and Synthesis in Radiant\nThe 7-segment display should display a single hexadecimal digit specified by s[3:0]. Be sure each digit can be distinguished from other digits (e.g., b and 8 should look different). Remember that you will be using a common anode display. The anode (positive terminal) of all of the LEDs is tied to 3.3 V through a single (“common”) pin. Each segment’s cathode (negative terminal) is connected to a pin. Therefore, you will need 7 separate control signals. Remember that a logic 0 applied to the cathode will turn on the segment. The segments are defined as shown below. Let seg[0] be A and seg[6] be G.\n\n\n\n\n\n\nSeven-segment display segment mapping\n\n\n\n\nFigure 9: Seven-segment display pin map\n\n\n\nLaunch Lattice Radiant and start the New Project Wizard from the File or startup menu. Setup a new project for the UP5K chip following the instructions in the Lattice Radiant Tutorial on the E155 website.\nChoose File → New and create a SystemVerilog HDL file. Save the file as lab1_xx.sv in your project directory and check the box to add the file to the current project. Create modules to perform the functions described above. The 7-segment display decoder should be combinational logic. Use a reasonable amount of hierarchy. Name the top-level module lab1_xx. The 7-segment display code, for example, will be reused in future labs, so it should be a module of its own (for the sake of reusability you may want to put this in a separate SystemVerilog file but this is not required). Every module should begin with a comment section that includes your name and email address, the date of creation, and a brief summary of its purpose, so that somebody else can understand what the module does and get a hold of you if they need help with it. Comment the modules as appropriate.\n\n\nLogic Simulation in ModelSim\nThe next step is to simulate your logic with ModelSim. Open ModelSim from Radiant from the Tools menu or the icon in the toolbar. The ModelSim window will open. Get in the habit of watching the transcript window to look for errors and to familiarize yourself with what a good run looks like. If you see errors, close ModelSim, correct your Verilog code in Radiant, and reopen ModelSim. You can also edit the file directly in ModelSim and recompile there without going through the entire synthesis pipeline in Radiant.\n\n\n\n\n\n\nNote\n\n\n\nSome of your designs may include modules from the iCE40 Technology Library (e.g., the HSOSC module we are using to generate our clock signal). If you try to simulate a design including one of these modules, you need to be sure to include the library. When you simulate a design that includes a module from the iCE40 Technology Library, make sure that you include the library by adding under the Libraries tab of the Start Simulation window as shown below. You can also use the -L flag in the command line to vsim.\n\n\n\nStarting Simulation\nIn QuestaSim/ModelSim, simulate your module by choosing Simulate → Start Simulation.... Click on the + symbol next to the work library and select your code (lab1_xx).\nIf the wave pane isn’t open, open it by choosing View → Wave. View all of the inputs and outputs of your design by selecting them in the Objects window and dragging them to the Waves window. In a more complicated design, you may wish to examine internal signals as well.\nManually test your design by forcing the inputs to specific values and then advancing the simulation using “run.” In the transcript window, type:\nforce s 0000\nrun 100\nforce s 0001\nrun 100\nforce s 0010\nrun 100\n...\n\n\n\n\n\n\nWatch Out for Optimization\n\n\n\nIf you’re not seeing all the signals in your design, it’s possible that QuestaSim optimized them away. To configure the optimization settings, see the relevant section in the QuestaSim/ModelSim tutorial.\n\n\nYou should see the led and seg outputs displaying appropriate values. Check the outputs against your expectations. If you find any discrepancies, fix the code and resimulate. A helpful shortcut to avoid restarting ModelSim is that you can edit the module by finding it under “work” in the library pane, right clicking, and choosing Edit. Make your fixes, then right click again and choose Recompile. Then type restart -f in the transcript window to restart simulation without having to set up the waveforms window again. When you return to Radiant, you’ll find your corrected code.\n\n\n\nPin Assignment\nNext, assign pins to relate the signal names in your Verilog code to physical pin numbers on the FPGA. Launch Tools → Device Constraint Editor. A table listing all inputs and outputs for the project should appear. Under Pin, type the pin number to associate with the given signal.\n\n\n\n\n\n\nFigure 10: Radiant pin assignments.\n\n\n\nThe FPGA pinouts are shown in the Board Schematic. Most of the user input/output (I/O) pins are tapped out to the headers and labeled on the board silk screen. Some have special functions; for example, FPGA pin P42 is connected to LED D6.\nThe pin numbers for the LEDs and switches are marked on the board’s silkscreen. For the outputs for the 7-segment display, you may select any I/O pins you’d like. Do make sure that these pins are not being used for other purposes.\nThe Device Constraint Editor is also the place where you can configure the pullup resistors for the I/O pins. To do this, examine the PULLMODE column for any input pins. In your design, this will be the pins connected to s[3:0]. These should be configured with pull-up resistors to avoid invalid logic levels (the exact value is not very important. A value between 10k and 100k is generally sufficient).\n\n\nSeven Segment Display Circuit\nThe 7-segment display will be used throughout the class for general output of numbers. In this lab assignment, though, it will be used to output the hexadecimal number entered by the user through the DIP switches.\nEach segment of the display works as an independent LED. Therefore, the same current-limiting concern with the LEDs applies to the display as to the on-board bank of LEDs. You can limit the current into each segment of the display the same way you did for the LEDs on board, adding a suitable resistor to provide roughly 5-20 mA of current. You can find resistors and other such components in the supply cabinet or in the stockroom.\nConsult the data sheet for the pinout of the common anode dual seven segment display. All seven segments share the same anode, which should be connected to VCC (3.3 V). Each of the segments has its own cathode, which can be pulled to 0 to turn on the segments.\nBe sure to turn power off before wiring circuits on your board. You can choose either side of the display to use in this lab. After deciding on which side to use, you will need to connect the VDD pin of that side (either VDD1 or VDD2) to 3.3 V. Then connect the input pins of the same side of the display to the header pins you chose. Remember to add suitable resistors between each of the inputs to the display and the header pins. These LEDs are common anode LEDs. That is, all the anodes from the LEDs are connected to a single VDD (VDD1 or VDD2). You are driving the cathode of each LED. Given this information, you might need to modify your Verilog file. Do so in the simplest way possible.\n\n\nGenerating the FPGA Configuration Files\nNow you will synthesize your HDL into a programming file to be transferred onto the FPGA. This outputs a binary file (.bin) in your project directory that can be used to program the FPGA directly over JTAG using the onboard USB programmer. Be sure your SystemVerilog files are saved, and click the green “Play” triangle to start the synthesis process. To help sort the many messages that the compilation process generates, click a tab under the Message area to see only that type of message. If compilation is successful but generates warnings, check the Warning and Error tabs for errors relevant to your design. Warnings about incomplete I/O assignments may be ignored if you have in fact assigned all relevant I/O pins.\nLaunch Tools → Netlist Analyzer and examine the RTL schematic of your design. This shows the logic synthesized from your Verilog design. Ensure the hardware matches your expectations.\nLook at the Reports tab. In the Project Summary under Resource Usage you should see a total number of registers and pins that match your expectations. Under Analysis & Synthesis, you can see how the logic blocks and registers are broken down in each module. Under Fitter, the Pin-Out File should match the pin assignments you intended.\n\n\n\n\n\n\nTroubleshooting Tips\n\n\n\nIf some of you are seeing issues with specific pins on your FPGA there could be a few different reasons and corresponding steps to take to troubleshoot.\n\nYou could have an electrical short which is causing some pins to be electrically connected that should not due to solder bridges. Double check to make sure that the pins are isolated and not connected together by checking the resistance between the pins with a multimeter.\nYou are trying to use a pin that is shared between the FPGA and the MCU and the MCU is not leaving that pin floating or it is driving it as an output. You can get around this by wiping the code on the MCU by uploading a file with a blank main function.\nYou should also read through the Nucleo board documentation to see what pins have special functions that are used by default by the MCU. Hint: You likely want to stay away from using the pins that the MCU uses for serial communication by default."
  },
  {
    "objectID": "lab/lab1/index.html#share-your-feedback",
    "href": "lab/lab1/index.html#share-your-feedback",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lab/lab1/index.html#footnotes",
    "href": "lab/lab1/index.html#footnotes",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn order for the NUCLEO board to be compatible with SEGGER, it is necessary to reflash the ST-LINK programmer with SEGGER J-Link firmware to convert it to a J-Link. This has been already taken care of on the board in your kit, but if you want to use another STM32 board with SEGGER you’ll need to follow the instructions here to do this yourself.↩︎"
  },
  {
    "objectID": "lab/lab5/index.html",
    "href": "lab/lab5/index.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Under Construction\n\n\n\nThis lab is currently in development and will be released later this semester."
  },
  {
    "objectID": "lab/specs/general-lab-specs.html",
    "href": "lab/specs/general-lab-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nGeneral Schematic Specifications\n\nAll pin names labeled\nAll pin numbers labeled\nCrossing wires clearly identified as junction or unconnected\nNeat layout (e.g., clear organization and spacing)\nAll parts labeled with part number\nAll component values present\n\nBlock Diagram\n\nBlock diagram present with one block per SystemVerilog module\nEach block includes all input and output signals\n\nHDL & Code Specifications\nGeneral Formatting\n\nDescriptive filename (e.g., lab2_jb.sv)\nDescriptive variable names\nNeat formatting (e.g., standard indentation, consistent formatting for variable names (kebab-case/snake_case/camelCase/PascalCase ))\nDescriptive and clear function/module names\n\nComments\n\nComments to indicate the purpose of each function/module\n\nLab Writeup/Summary\n\nBrief (e.g., 3-5 sentence) description of the main goals of the assignment and what was done.\nExplanation of design approach. How did you go about designing and implementing the design?\nExplanation of testing approach. How did you verify your design was behaving as expected?\nStatement of whether the design meets all the requirements. If not, list the shortcomings.\nNumber of hours spent working on the lab are included.\nWriteup contains minimal spelling or grammar issues and any errors do not significantly detract from clarity of the writeup.\n(Optional) List commments or suggestions on what was particularly good about the assignment or what you think needs to change in future versions.\n\n\n\n\nExcellence\nGeneral Schematic Specifications \n\nStandard symbols used for all components where applicable\nSignals “flow” from left to right where possible (e.g., inputs on left hand side, outputs on right hand side)\nTitle block with author name, title, and date\n\nHDL & Code Specifications\nGeneral Formatting\n\nName, email, and date at the top of every file\nComment at the top of each source code file to describe what is in it\nClear and organized hierarchy (e.g., deliniation between top level modules and submodules)\n\nTestbenches\n\nTestbenches written for each individual module to demonstrate proper operation\nTestbench output included in the report\n\nLab Writeup/Summary\n\nWriteup is free of spelling and grammar issues"
  },
  {
    "objectID": "lab/specs/lab6-specs.html",
    "href": "lab/specs/lab6-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nDesign uses CMSIS library device templates.\nSPI library written\nSPI library can communicate with the digital temperature sensor to read the current temperature\nSystem properly handles temperatures between -10 ˚C and 30 ˚C.\nWebpage displays current temperature with units\nWebpage updates temperature when refreshed\nWebpage properly displays the LED state\nWebpage can control the LED state\n\n\n\nExcellence\n\nReport includes sample SPI transaction from logic analyzer\nSystem reads temperature values at either user-configured resolution (e.g., user can choose from 8/9/10/11/12-bit resolution on webpage)."
  },
  {
    "objectID": "lab/specs/lab3-specs.html",
    "href": "lab/specs/lab3-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nCircuit correctly reads inputs from \\(4 \\times 4\\) keypad.\nDual seven-segment display shows the last two hexadecimal digits pressed.\nMost recent numeric entry is shown on the right.\nDesign does not lock up when multiple buttons are pressed at once. (i.e., it just holds the current values on the display and functions properly again when the buttons are released.)\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\nEach button press registered only once (e.g., no switch bouncing)\nSeven segment displays are same brightness regardless of how many segments are illuminated.\nDesign has no latches.\nDesign has no tristate buffers.\nReport includes state transition diagram illustrating the operation of the system.\n\n\n\nExcellence\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\nKeypad and seven-segment display are aligned in the same orientation (i.e., the top of the numbers on both are facing the same direction).\nState transition diagram is completely specified (i.e., all transitions between states are specified, output conditions specified in each state)\nReport includes state transition table to document the nextstate and output values for each state based on the current state and inputs.\nReport explains tradeoffs between the chosen design decisions and alternatives (e.g., why did you select a certain switch debouncing strategy and what are the tradeoffs between your chosen method and others?)."
  },
  {
    "objectID": "lab/specs/lab5-specs.html",
    "href": "lab/specs/lab5-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\n\nExcellence"
  },
  {
    "objectID": "lab/specs/lab1-specs.html",
    "href": "lab/specs/lab1-specs.html",
    "title": "HMC E155",
    "section": "",
    "text": "Proficiency\n\nDevelopment board is fully assembled (e.g., all parts soldered)\nVerilog module to control LEDs and a 7-segment display written\nFPGA programmed with Verilog code.\n7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF\nAll digits are unique (e.g., 0x6 and 0xb are different shapes)\nDIP switches to control the display are arranged so that each adjacent switch controls the next bit. (e.g., the switch for bit 0 is next to the switch for bit 1, which is next to the switch for bit 2, etc.)\nLEDs display the specified logic operations properly.\n\n\n\nExcellence\n\nCalculations provided to demonstrate that the current draw for each segment in the seven-segment display is within recommended operating conditions.\nModelSim simulation (either manually force or automatic testbench) to demonstrate that the design is working properly.\nAll digits are equally bright, regardless of the number of segments illuminated."
  },
  {
    "objectID": "lab/lab3/index.html",
    "href": "lab/lab3/index.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab you will learn how to use an FPGA to scan inputs from a keypad."
  },
  {
    "objectID": "lab/lab3/index.html#introduction",
    "href": "lab/lab3/index.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab you will learn how to use an FPGA to scan inputs from a keypad."
  },
  {
    "objectID": "lab/lab3/index.html#learning-objectives",
    "href": "lab/lab3/index.html#learning-objectives",
    "title": "Lab 3: Keypad Scanner",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nDesigned a circuit interface to read a matrix keypad.\nUnderstood and implemented a solution to deal with switch bouncing.\nImplemented robust digital design strategies to ensure appropriate behavior with a variety of different user inputs."
  },
  {
    "objectID": "lab/lab3/index.html#requirements",
    "href": "lab/lab3/index.html#requirements",
    "title": "Lab 3: Keypad Scanner",
    "section": "Requirements",
    "text": "Requirements\nDesign and construct a circuit on your FPGA to read a 4-by-4 matrix keypad. Display the last two hexadecimal digits pressed on your dual seven-segment display, with the most recent entry appearing at the right. The keypad and your display should be in the same orientation.\nEach key press should be recorded exactly once, at the time the key is pressed, no matter how long or short a time the user holds the key down. If additional keys are pressed while still holding down the first key, these inputs should be ignored. The seven-segment displays should not flicker and should be the same brightness regardless of how many segments are displayed."
  },
  {
    "objectID": "lab/lab3/index.html#discussion",
    "href": "lab/lab3/index.html#discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Discussion",
    "text": "Discussion\nA matrix keypad has four rows and four columns, connected to 8 pins, as shown below for two different models. When you press a key, the corresponding row and column are connected. Check this with a multimeter to confirm your pinout.\n\n\n\n\n\n\nFigure 1: Pinout of keypads.\n\n\n\nMechanical switches are prone to a phenomenon called switch bounce, where the switch makes and breaks its connection repeatedly on a time scale of microseconds to a few milliseconds. You should design your system in such a way that a single keypress registers only once even if there is some momentary bounce.\nThis is a thinking person’s lab. If you thoroughly understand the problem and design a simple scanner circuit, you can complete the lab fairly efficiently. If you go by trial and error, you may find yourself in lab indefinitely. You will need to generate rather complex stimuli to simulate your keypad scanner. Many students have been tempted to skip simulating and debug on the real hardware. Almost all have regretted it. Similarly, some students have been lured down the path of asynchronous design, at their peril."
  },
  {
    "objectID": "lab/lab3/index.html#hints",
    "href": "lab/lab3/index.html#hints",
    "title": "Lab 3: Keypad Scanner",
    "section": "Hints",
    "text": "Hints\nLook at your RTL schematic in your synthesis tool (Tools -&gt; Netlist Analyzer). Understand why your code produces the hardware you see. Be sure your combinational logic doesn’t have any registers. Be sure your logic has no latches or tristate buffers. The oscilloscope is handy for tracking down timing problems."
  },
  {
    "objectID": "lab/lab3/index.html#share-your-feedback",
    "href": "lab/lab3/index.html#share-your-feedback",
    "title": "Lab 3: Keypad Scanner",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lab/lab4/index.html",
    "href": "lab/lab4/index.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab you will use your MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations."
  },
  {
    "objectID": "lab/lab4/index.html#introduction",
    "href": "lab/lab4/index.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab you will use your MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations."
  },
  {
    "objectID": "lab/lab4/index.html#learning-objectives",
    "href": "lab/lab4/index.html#learning-objectives",
    "title": "Lab 4: Digital Audio",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nBuilt a circuit to enable an I/O pin from your MCU to drive a speaker\nImplemented the timer functionality available on the MCU by reading the datasheet and writing your own library in C from scratch"
  },
  {
    "objectID": "lab/lab4/index.html#requirements",
    "href": "lab/lab4/index.html#requirements",
    "title": "Lab 4: Digital Audio",
    "section": "Requirements",
    "text": "Requirements\nBuild a system to play music on a speaker. Use your MCU, an LM386 audio amplifier, and an 8-ohm speaker. The MCU should read a list of notes specifying the pitch (in Hz) and duration (in ms) of each note. It should generate a corresponding sequence of square waves. A frequency of 0 indicates a rest (silence for the given duration). A duration of 0 indicates the end of the song. Your system should play accurate pitches regardless of the frequency. Test your system on the score of Für Elise, which is provided. Your code should manually define #define macros and register structures for the memory-mapped registers you need to manipulate to help you practice developing your own device drivers from scratch using only the reference manual as a reference. In particular, this means that you are not allowed to use the CMSIS headers for your device."
  },
  {
    "objectID": "lab/lab4/index.html#discussion",
    "href": "lab/lab4/index.html#discussion",
    "title": "Lab 4: Digital Audio",
    "section": "Discussion",
    "text": "Discussion\nYou can find lab5_starter.c on the class web page with the Für Elise score provided as an array of ordered pairs of pitch frequencies and durations.\nA goal of this lab is for you to learn to interpret a datasheet and figure out how the timer works. Write your own code from scratch to use the system timer.\nThe GPIO pins don’t generate enough output current to play satisfactory music directly on the speaker, so use an LM386 audio amplifier between the MCU and the speaker. Do not connect the MCU directly to the speaker, as the current draw could damage it. The datasheet shows AC coupling from the amplifier to the speaker, but you can leave out the capacitors and resistors and produce an acceptable square wave. Volume control is optional (but recommended for your own sanity and that of your roommates and labmates). There are only a limited number of speakers available in the lab so please leave the speakers in the supply cabinet when you leave the lab. Do not leave them attached to your breadboard when you are done working. If you kill a speaker, throw it away rather than putting it back in the cabinet for your unfortunate classmates."
  },
  {
    "objectID": "lab/lab4/index.html#optional-exercise",
    "href": "lab/lab4/index.html#optional-exercise",
    "title": "Lab 4: Digital Audio",
    "section": "Optional Exercise",
    "text": "Optional Exercise\nIn the past students have enjoyed composing their own tune to play on their MCU. The following information may help if you wish to compose your own piece of music.\nThe duration depends on an arbitrary choice of tempo (speed at which the piece is played). If a whole note is chosen to be 1/2 a second long, other notes follow accordingly:\n\n\n\n\nNote Type\nDuration [s]\n\n\n\n\nWhole\n0.5\n\n\nHalf\n0.25\n\n\nQuarter\n0.125\n\n\nEighth\n0.0625\n\n\nSixteenth\n0.03125\n\n\n\n\nRecall that the A above middle C (called A4) is 440 Hz (at least in the United States) and that an octave spans a factor of 2 in frequency. There are twelve notes in an octave spaced evenly on a geometric scale, so each is separated in frequency by a factor of 21/12.\n\n\n\n\nNote\nFrequency (Hz)\n\n\n\n\nA3\n220\n\n\nA3 sharp / B3 flat\n233.1\n\n\nB3\n246.9\n\n\nC4 (middle C)\n261.6\n\n\nC4 sharp / D4 flat\n277.2\n\n\nD4\n293.7\n\n\nD4 sharp / E4 flat\n311.1\n\n\nE4\n329.6\n\n\nF4\n349.2\n\n\nF4 sharp / G4 flat\n370.0\n\n\nG4\n392.0\n\n\nG4 sharp / A4 flat\n415.3\n\n\nA4\n440\n\n\nA4 sharp / B4 flat\n466.2\n\n\nB4\n493.9\n\n\nC5\n523.3\n\n\nC5 sharp / D5 flat\n554.4\n\n\nD5\n587.3\n\n\nD5 sharp / E5 flat\n622.2\n\n\nE5\n659.2\n\n\nF5\n698.4\n\n\nF5 sharp / G5 flat\n740.9\n\n\nG5\n784.0\n\n\nG5 sharp / A5 flat\n830.6\n\n\nA5\n880"
  },
  {
    "objectID": "lab/lab4/index.html#what-to-turn-in",
    "href": "lab/lab4/index.html#what-to-turn-in",
    "title": "Lab 4: Digital Audio",
    "section": "What to Turn In",
    "text": "What to Turn In\nWhen you are done, have your lab checked off by the instructor. You should thoroughly understand how it works and what would happen if any changes were made. Turn in your lab writeup including the following information:\n\nSchematics of the breadboarded circuit.\nYour source code.\nHow many hours did you spend on this lab? This will not count toward your grade."
  },
  {
    "objectID": "lab/lab4/index.html#credits",
    "href": "lab/lab4/index.html#credits",
    "title": "Lab 4: Digital Audio",
    "section": "Credits",
    "text": "Credits\nThis lab was originally developed in 2015 by Alex Alves ’16, redesigned for the μMudd Mark 5.1 in 2019 by Caleb Norfleet ’21, and redesigned for the μMudd MkVI in Fall 2021 by Prof. Josh Brake."
  },
  {
    "objectID": "lab/lab4/index.html#share-your-feedback",
    "href": "lab/lab4/index.html#share-your-feedback",
    "title": "Lab 4: Digital Audio",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lab/lab2/index.html",
    "href": "lab/lab2/index.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA."
  },
  {
    "objectID": "lab/lab2/index.html#introduction",
    "href": "lab/lab2/index.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab you will learn how to use time multiplexing to efficiently use the I/O on your FPGA."
  },
  {
    "objectID": "lab/lab2/index.html#learning-objectives",
    "href": "lab/lab2/index.html#learning-objectives",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this lab you will have…\n\nImplemented a time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins.\nBuilt a simple transistor circuit to drive large currents from the FPGA pins.\nPracticed your ability to build Verilog systems in a modular way."
  },
  {
    "objectID": "lab/lab2/index.html#requirements",
    "href": "lab/lab2/index.html#requirements",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Requirements",
    "text": "Requirements\nDisplay two independent hexadecimal numbers on your dual seven-segment display. Use a DIP switch and four other input pins (possibly connected to a DIP switch on a breadboard) to provide the data for two hexadecimal numbers. You must use a single seven-segment decoder HDL module to drive the cathodes for both digits on the display, which therefore must be wired for multiplexed operation. Also, display the sum of the numbers on five LEDs. The seven segment display should be oriented to display the numbers upright to the viewer."
  },
  {
    "objectID": "lab/lab2/index.html#discussion",
    "href": "lab/lab2/index.html#discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Discussion",
    "text": "Discussion\nTime-multiplexing is a technique to share a common expensive hardware resource for several purposes at different times. For example, the multicycle processor in E85 multiplexed the memory for both instruction and data access and multiplexed the ALU for data processing instructions, branch calculations, and program counter increments.\nIn this lab, you will time-multiplex your seven-segment decoder module to run both halves of a dual display. A convenient way to control which half is active is to turn ON the common anode of only one display at a time. The anode requires substantial current, more than an FPGA output pin can drive. You can use a transistor to drive the large current. The lab has a stock of 2N3906 PNP transistors suitable for this purpose. Be sure to limit the base current so that you don’t draw too much current from the FPGA pin and choose a suitable switching speed. If you switch too slowly, your eye will notice the flicker. If you switch too fast for the electronics, the two digits will bleed together."
  },
  {
    "objectID": "lab/lab2/index.html#hints",
    "href": "lab/lab2/index.html#hints",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Hints",
    "text": "Hints\nLook at your RTL schematic in your synthesis tool (Tools -&gt; Netlist Analyzer). Understand why your code produces the hardware you see. Be sure your combinational logic doesn’t have any registers. Be sure your logic has no latches or tristate buffers. The oscilloscope is handy for tracking down timing problems."
  },
  {
    "objectID": "lab/lab2/index.html#share-your-feedback",
    "href": "lab/lab2/index.html#share-your-feedback",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lab/lab6/index.html",
    "href": "lab/lab6/index.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "By the end of this lab you will have…\n\nDesigned and built a simple IoT device\nWritten C libraries using the CMSIS device templates to implement the SPI functionality of the MCU\nInterfaced with a temperature sensor module over an SPI link\nInterfaced the MCU with an ESP8266 module over a UART link\nUse the logic analyze functionality of the scope in the Digital Lab to debug serial communication protocols and export captured signal data.\nWritten a simple HTML page to control and display data from the peripherals connected to your MCU."
  },
  {
    "objectID": "lab/lab6/index.html#learning-objectives",
    "href": "lab/lab6/index.html#learning-objectives",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "By the end of this lab you will have…\n\nDesigned and built a simple IoT device\nWritten C libraries using the CMSIS device templates to implement the SPI functionality of the MCU\nInterfaced with a temperature sensor module over an SPI link\nInterfaced the MCU with an ESP8266 module over a UART link\nUse the logic analyze functionality of the scope in the Digital Lab to debug serial communication protocols and export captured signal data.\nWritten a simple HTML page to control and display data from the peripherals connected to your MCU."
  },
  {
    "objectID": "lab/lab6/index.html#requirements",
    "href": "lab/lab6/index.html#requirements",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Requirements",
    "text": "Requirements\nBuild an internet-accessible device to control an onboard LED and measure ambient temperature. Use an ESP8266 with the provided web server code to host the webpage and use the onboard MCU GPIO and SPI peripherals to toggle an LED and to read temperature from a provided sensor chip. An end-user must be able to turn the LED ON and OFF and view the current temperature from the webpage.\nIn addition to the standard deliverables in your report (summary, schematic, etc.), your report also must include an example of a SPI read/write interaction with all pertinent data signals (e.g., CE, SCK, SDO, SDI) captured using the logic analyzer functionality of the oscilloscopes in the Digital Lab.\nAt heart, this lab asks you to consult the MCU documentation to learn how to directly control the SPI memory-mapped peripheral on the MCU, so refrain from consulting any other C device drivers that can be found on the web or elsewhere.\nNote that for this lab your SPI device driver must use the Common Microcontroller Software Interface Standard (CMSIS) device templates included in the stm32l432xx.h device header. See the provided example device drivers on the course GitHub repository for an example. The GPIO driver provides a good example of how to use the information included in the CMSIS headers.\n\nNote: There are only a limited number of ESP8266 boards and DS1722 SPI temperature sensors available for this lab. Please do not remove these devices from the digital lab so that everyone can access these shared resources."
  },
  {
    "objectID": "lab/lab6/index.html#esp8266-web-server",
    "href": "lab/lab6/index.html#esp8266-web-server",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "ESP8266 Web Server",
    "text": "ESP8266 Web Server\nBroadly speaking, everything that you see on the internet is the product of one computer presenting text to another. The text is often formatted in a special, internet-specific, way that includes information about how to display it which is referred to as hypertext. (Forgive the early internet engineers for this indulgence; I’m sure it sounded really cool at the time.) Hypertext is specified using a compact programming language called hypertext markup language or HTML. It is transferred over the internet based on a predefined set of agreements between all computers which is referred to as the hypertext transfer protocol or HTTP. The latter most of these acronyms should be familiar: whenever you type http:// into a web browser you are informing your computer that you are attempting to retrieve hypertext from the address that follows.\nThere are two common tools that interact with HTTP: the web browser, which lives on a receiving computer, sends internet requests, and renders the received hypertext; and the web server, which listens for requests from the internet and sends out hypertext in response.\nImplementing an HTTP web server on the ARM microcontroller is a non-trivial task. Instead, you will be using an ESP8266, a small WiFi development board which incorporates a TCP/IP stack as well as onboard WiFi and an integrated antenna. You are provided an Arduino language program which hosts an HTTP web server with an HTML page generated by the MCU."
  },
  {
    "objectID": "lab/lab6/index.html#esp8266-mcu-interface",
    "href": "lab/lab6/index.html#esp8266-mcu-interface",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "ESP8266-MCU Interface",
    "text": "ESP8266-MCU Interface\nDownload the Lab 6 starter code and support files from the class web page. You may use any code we have developed in class to help you write your code.\nESP8266 development boards are available from the E155 supply closet and are pre-programmed with the webserver code. The SSID for the WiFi access points associated with each board is Lab6_ESP_xx where xx is the number listed on each board.\nThe ESP8266 board requires 3.3 V power. However, it has an onboard regulator so you can power the board with between 3-6 V using the V+ and GND pins. If after supplying power to the chip and waiting for it to initialize you do not see the expected WiFi network appear, you may need to reprogram the chip with the provided code.\nThe MCU must supply a webpage to the ESP8266, and must interpret any web browser requests from the ESP8266. The devices interface through a 125000 baud serial UART connection on the MCU and the UART TX and RX lines of the ESP8266. Note that with a UART connection the receive and transmit lines should be crossed. In other words, the TX of the transmitter should be connected to the RX of the receiver and the RX of the transmitter should be connected to the TX of the receiver.\nThe protocol is as follows:\n\nWhen the ESP8266 updates the webpage from the MCU, it sends the most recent request from the client, within /REQ:'...'\\n. For example, a user accessing the page http://&lt;server_address&gt;/ledon would result in the request /REQ:ledonn being sent to the microcontroller. A user accessing the root webpage of the server, http://&lt;server_address&gt;/ would result in the request /REQ:\\n. Note that you must use http:// and not https://.\nThe MCU then transmits the entire web page to the ESP8266. The ESP8266 expects a webpage encoded as an HTML file. Therefore the webpage must start with ‘&lt;!DOCTYPE html&gt;&lt;html&gt;’ and end with ‘&lt;/html&gt;’. The ESP will wait for either &lt;/html&gt; or 200 ms from the last byte sent over serial before terminating the HTTP request and forwarding the content to the web browser.\n\nThe ESP8266 will create a WiFi access point named whatever SSID is labeled on the board. Connect to this WiFi network, and then go to http://192.168.4.1/. Beware that the ESP is slow and it may sometimes take a few attempts to connect."
  },
  {
    "objectID": "lab/lab6/index.html#digital-temperature-sensor",
    "href": "lab/lab6/index.html#digital-temperature-sensor",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Digital Temperature Sensor",
    "text": "Digital Temperature Sensor\nThe temperature sensor you will interface with for this lab is the DS1722 Digital Thermometer with SPI/3-Wire Interface from Maxim Integrated. This chip is an example of a simple peripheral that supports an SPI interface. You will need to get a DS1722 chip from the E155 stock cabinet mounted on an SOIC-8 breakout board. There are some boards that are already soldered, but if you are unable to find any pre-soldered boards to use, there may also be some chips and extra breakout boards you can solder yourself. After getting a board, consult the DS1722 datasheet to correctly wire up the device. Make sure to thoroughly read the data sheet and refer to the pinout before attempting to interface with the device!\nThe figure below shows the corresponding pinout between the SMT pads and the header pins on the breakout board for your convenience.\n\n\n\n\n\n\nFigure 1: SMT breakout board pinout."
  },
  {
    "objectID": "lab/lab6/index.html#mcu-hardware-and-the-internet-of-things",
    "href": "lab/lab6/index.html#mcu-hardware-and-the-internet-of-things",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "MCU Hardware and the Internet of Things",
    "text": "MCU Hardware and the Internet of Things\nThe last component of this lab is to write a program that parses a request from the ESP8266, toggles the LED state as necessary, reads from the SPI temperature sensor, and uses this data to generate a webpage that is transmitted to the ESP8266. Make sure that the FPGA code on your board does not interfere with any of the pins which you may want to use for your sensors or else you will experience undefined behavior.\nYou will need to write an HTML webpage that displays dynamic temperature data as well as creating requests to change the state of the LED. There are many ways to do this, but we suggest the following resources for information on HTML formatting and interactive elements:\n\nhttp://www.w3schools.com/html/default.asp\nhttp://www.w3schools.com/html/html_forms.asp\n\nThe final product of this lab is a simple example of an emerging class of devices called the Internet of Things. Proponents of these devices argue that everything—from your washing machine to your car to giant factories—should be connected to the internet so that the shared data can be used to optimize and improve societal functions. Internet-controlled lighting, and internet-accessible sensors are two promising domains for the field, and are exemplified in this lab."
  },
  {
    "objectID": "lab/lab6/index.html#hints",
    "href": "lab/lab6/index.html#hints",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Hints",
    "text": "Hints\nThe time spent on this lab has been highly variable in the past. If SPI doesn’t work on your first try, it can take a long time to debug because there are many different settings, all of which have to be correct. You can increase the chance of SPI working by carefully studying the MCU documentation before coding. Before connecting the peripheral device, look at the SPI outputs on a logic analyzer and make sure that the clock, SDO, and the chip enables are matching your expectations. Fix your code if they do not. Then attach the peripheral and recheck all the signals including SDI."
  },
  {
    "objectID": "lab/lab6/index.html#what-to-turn-in",
    "href": "lab/lab6/index.html#what-to-turn-in",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "What to Turn In",
    "text": "What to Turn In\nWhen you are done, have your lab checked off by the instructor. You should thoroughly understand how it works and what would happen if any changes were made. Turn in your lab writeup including the following information:\n\nSchematics of the breadboarded circuit.\nA screen capture (exported from the scope, not a photo captured using a camera) of an example SPI transaction captured on the oscilloscope/logic analyzer.\nYour source code.\nHow many hours did you spend on the lab? This will not count toward your grade."
  },
  {
    "objectID": "lab/lab6/index.html#share-your-feedback",
    "href": "lab/lab6/index.html#share-your-feedback",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lab/lab7/index.html",
    "href": "lab/lab7/index.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "By the end of this lab you will have…\n\nLearned to read and implement a complex specification\nBuilt a nontrivial system on an FPGA that requires thoughtful architecture to fit on the chip\nDesigned and implemented an interface to communicate between the FPGA and microprocessor on your MCU\nLearned how to use a logic analyzer to analyze and debug your system\nGained experience with hardware accelerators"
  },
  {
    "objectID": "lab/lab7/index.html#learning-objectives",
    "href": "lab/lab7/index.html#learning-objectives",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "By the end of this lab you will have…\n\nLearned to read and implement a complex specification\nBuilt a nontrivial system on an FPGA that requires thoughtful architecture to fit on the chip\nDesigned and implemented an interface to communicate between the FPGA and microprocessor on your MCU\nLearned how to use a logic analyzer to analyze and debug your system\nGained experience with hardware accelerators"
  },
  {
    "objectID": "lab/lab7/index.html#requirements",
    "href": "lab/lab7/index.html#requirements",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Requirements",
    "text": "Requirements\nConstruct a hardware accelerator to perform 128-bit AES encryption. Send a plaintext message and key from a micro- processor to the accelerator and verify that the cyphertext received back is correct. Display the SPI communication on the logic analyzer."
  },
  {
    "objectID": "lab/lab7/index.html#the-advanced-encryption-standard",
    "href": "lab/lab7/index.html#the-advanced-encryption-standard",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "The Advanced Encryption Standard",
    "text": "The Advanced Encryption Standard\nThe Advanced Encryption Standard is described in an unusually succinct and clear standard. Reading the standard carefully will save you time. See Appendix A-1 for an example of the key expansion during each round and Appendix B for an example of the intermediate results during each round.\n\nImplementation\nDownload the starter source code and libraries from the course website. The provided MCU libraries (included in the lib subdirectory of the project) support a number of peripherals on the MCU so that you can directly use them and do not need to write them yourself.\nExamine aes_starter.sv, sbox.txt. aes_starter.sv contains the top-level module, an SPI interface, and two testbenches. The testbench module tests the entire system including the SPI link. The testbench_aes_core module is a separate testbench that tests only the aes_core module without the SPI link. It is suggested that you use testbench_aes_core first to check your core and then test the whole system including the SPI link with the full testbench. These testbenches apply and check the test vector described in Appendix A-1 and B.\nThe starter code also contains the mixcolumns logic that operates on a 128-bit intermediate state. The Galois field arithmetic for mixcolumns is more complicated than for the rest of AES, and the implementation is based on a paper cited in the code. The sbox module and sbox.txt lookup table perform the sbox substitution on a single byte.\nThe MCU code lab7.c sends a key and plaintext message over SPI to the FPGA, then checks that the result is correct. Set up your project to target the FPGA on your board and develop the remaining modules necessary to implement AES. You will need to carefully read the specification to figure out what these are and how to connect them. Starting with a high-level block diagram of the system is a very helpful step to make sure that you are understanding the AES procedure correctly. The MCU starter code can be opened directly in SEGGER Embedded Studio and directly compiled and uploaded to the MCU and does not need any further modification.\nYou will discover that the logic is too large to implement all the rounds as one giant block of combinational logic. Therefore, you will need to perform the rounds sequentially. You will also need to pay careful attention to the timing within each round since you need to allow for the one-cycle latency required to perform the sbox byte substitution which uses the synchronous RAM blocks.\nTurn in the usual report including design approach, block diagram, code, schematics, results, and time spent."
  },
  {
    "objectID": "lab/lab7/index.html#hints",
    "href": "lab/lab7/index.html#hints",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Hints",
    "text": "Hints\nPrevious students have spent a highly variable amount of time on this lab. Here are some suggestions to make it go faster.\n\nStart by thoroughly understanding the specification\nIn prior labs you may have gotten in the habit of thinking in code. Remember to go back to thinking about hardware rather than function calls. Draw a block diagram for your hardware using elements such as registers, multiplexers, FSMs, and blocks of combinational logic. Name all of the signals between blocks. Remember how the E85 multicycle processor had a datapath that required certain control signals such as mux selects, and a controller that generates the control signals at the appropriate times. You’ll find a similar organization helpful. Write idiomatic Verilog code that exactly matches your block diagram.\n\n\nWatch for warnings in synthesis and simulation, and correct these before moving ahead.\nGet your design working in simulation first. When debugging, find the first place you can tell a signal is wrong. Add all the relevant inputs that influence that signal. If one of them is wrong, recursively work backward. When the inputs are good and the output is bad, you’ve isolated the bug and can look for it in that part of the code. Learn to do this systematically so you can find and solve each bug in minutes rather than hours.\nIf the design works in simulation but not on hardware, it is often a wiring error or a discrepancy between how you timed your control signals and what the C code expects. Make sure you’ve read the provided code carefully and are producing signals at the right times. Check that your FPGA and microcontroller are expecting the same polarity and phase for your SPI clock signal. Use the many channels of the logic analyzer to view all of the relevant signals at once and check them against your expectations. If you have a hard bug, it’s helpful to tap out intermediate signals, such as the state of a FSM, onto FPGA pins so you can watch them on the logic analyzer.\nHave fun! This is a sophisticated system and you should feel proud when you have built and debugged it!"
  },
  {
    "objectID": "lab/lab7/index.html#credits",
    "href": "lab/lab7/index.html#credits",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Credits",
    "text": "Credits\nThis lab was original developed in 2015 by Ben Chasnov ’16, redesigned for the μMudd Mark 5.1 in 2019 by Caleb Norfleet ’21, and revamped for the μMudd Mark 6 in 2021 by Prof. Josh Brake."
  },
  {
    "objectID": "lab/lab7/index.html#share-your-feedback",
    "href": "lab/lab7/index.html#share-your-feedback",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Share Your Feedback",
    "text": "Share Your Feedback\n\n\n\n\n\n\nShare Your Feedback!\n\n\n\nIf you caught any typos or have any suggestions for this page, please open an issue on the website Github repository. Click the link here for instructions on how to create an issue."
  },
  {
    "objectID": "lecture/index.html",
    "href": "lecture/index.html",
    "title": "Lecture",
    "section": "",
    "text": "See the list below for links to lecture slides and handouts. Slides and handouts will normally be posted shortly before each class period.\n\nLecture 1: Introduction and Analog Behavior of Digital Systems [slides] [handout]\nLecture 2: Combinational and Sequential Logic [slides] [handout]\nLecture 3: Verilog Review [slides] [handout]"
  },
  {
    "objectID": "project/specs/project-midpoint-specs.html",
    "href": "project/specs/project-midpoint-specs.html",
    "title": "Project Midpoint Demo Specs",
    "section": "",
    "text": "Clear and concise written summary of current status\nSchematics of all breadboarded circuits\nBlock diagram of system components and the interfaces between them\nHardware demo functioning (potentailly with some minor bugs)\nMore than 25% of the way to the final deliverable\nClear description of microcontroller routines\nAll external parts ordered"
  },
  {
    "objectID": "project/specs/project-midpoint-specs.html#proficiency",
    "href": "project/specs/project-midpoint-specs.html#proficiency",
    "title": "Project Midpoint Demo Specs",
    "section": "",
    "text": "Clear and concise written summary of current status\nSchematics of all breadboarded circuits\nBlock diagram of system components and the interfaces between them\nHardware demo functioning (potentailly with some minor bugs)\nMore than 25% of the way to the final deliverable\nClear description of microcontroller routines\nAll external parts ordered"
  },
  {
    "objectID": "project/specs/project-midpoint-specs.html#excellence",
    "href": "project/specs/project-midpoint-specs.html#excellence",
    "title": "Project Midpoint Demo Specs",
    "section": "Excellence",
    "text": "Excellence\n\nAll interfaces in the block diagram defined (e.g., SPI, I2C, GPIO)\nHardware demo functioning well\nWriting is well organized\nSolid grammar or spelling issues (no more than a few minor errors which do not detract from the point).\nCompleted riskiest element of the project\nMore than 50% of the way to the final deliverable"
  },
  {
    "objectID": "project/specs/project-final-report-specs.html",
    "href": "project/specs/project-final-report-specs.html",
    "title": "Project Final Portfolio Specs",
    "section": "",
    "text": "Written documentation should follow all the specifications for written documentation as laid out in the general lab specs. In addition, the report should address these project-specific specifications."
  },
  {
    "objectID": "project/specs/project-final-report-specs.html#proficiency",
    "href": "project/specs/project-final-report-specs.html#proficiency",
    "title": "Project Final Portfolio Specs",
    "section": "Proficiency",
    "text": "Proficiency\n\nTechnical Information\n\nBill of materials including all relevant components with quantities, part numbers, and prices.\nMicrocontroller design overview: description of what the MCU is doing.\nFPGA design overview: what is the FPGA doing along with main design features.\n\n\n\nWritten Documentation\n\nNames and short bios of team members with link to personal website or LinkedIn profile.\nAbstract which briefly describes the main purpose and operation of the system.\nNew hardware listed in section with description\nResults: What are the main results of your project.\nReferences: Citation (and hyperlinks where relevant) to any outside resources that were referenced in the design of the project.\nAcknowledgements\nAll project code (software and HDL) included in Git repository\n\n\n\nWriting and Organization\n\nWebsite is well organized with clear separation of relevant information.\nNo more than a few minor spelling or grammar issues.\nNo missing placeholders (e.g., XX) or dead hyperlinks."
  },
  {
    "objectID": "project/specs/project-final-report-specs.html#excellence",
    "href": "project/specs/project-final-report-specs.html#excellence",
    "title": "Project Final Portfolio Specs",
    "section": "Excellence",
    "text": "Excellence\n\nTechnical Documentation\n\nSchematics are neatly drawn with a CAD program (e.g., KiCad). All necessary labels present (pins names & numbers, part numbers, etc.)\nBlock diagram is neat and completely specified (e.g., all communication protocols labeled, bus widths indicated, etc.)\n\n\n\nWritten Documentation\n\nNew hardware described with notes about the features to be implemented and how they go beyond the previous material covered in the course.\nResults section clearly and quantitatively outlines the key performance aspects of the design with commentary to explain the design decisions.\nReferences are formatted with a clean and consistent format.\nAll project code is accompanied by comments throughout\nGit repository contains a README.md file to describe the main elements of the project and where they are found.\n\n\n\nWriting and Organization\n\nExcellent spelling and grammar throughout\n\n\n\nMultimedia Documentation\n\nShort video showcasing a demonstration of the project\nPhotos documenting final design"
  },
  {
    "objectID": "project/specs/project-final-report-specs.html#optional",
    "href": "project/specs/project-final-report-specs.html#optional",
    "title": "Project Final Portfolio Specs",
    "section": "Optional",
    "text": "Optional\n\nPhotos documenting the build process"
  },
  {
    "objectID": "project/specs/project-proposal-specs.html",
    "href": "project/specs/project-proposal-specs.html",
    "title": "Project Proposal Specs",
    "section": "",
    "text": "The goal of the proposal is to describe what you plan to build and how you plan to build it. The specifications below provide the expectations for the project proposal.\nIt should be no longer than 2-pages worth of text along with any technical documentation needed (i.e., diagrams, tables, or other figures do not count against the 2-page limit). The point is for you to make your description cleard, direct, and concise.\nWhile you are free to organize your proposal in the way that best suits your project, you should be sure to address the following sections:"
  },
  {
    "objectID": "project/specs/project-proposal-specs.html#proficiency",
    "href": "project/specs/project-proposal-specs.html#proficiency",
    "title": "Project Proposal Specs",
    "section": "Proficiency",
    "text": "Proficiency\n\nGeneral\n\nBill of materials included with list of all items needed for the project\nProject lists specifications for design\nIdentifies the riskiest element of the project\n\n\n\nTechnical\n\nDescribes microcontroller use\nProject uses FPGA\nProject uses new hardware\n\n\n\nDocumentation\n\nBlock diagram of system provided showing all elements of the design and their connections."
  },
  {
    "objectID": "project/specs/project-proposal-specs.html#excellence",
    "href": "project/specs/project-proposal-specs.html#excellence",
    "title": "Project Proposal Specs",
    "section": "Excellence",
    "text": "Excellence\n\nGeneral\n\nCompletely clear what the project must do to meet specs.\nRough timeline included which lists the tasks which need to be completed, the order in which they will be pursued, and the time they are expected to take.\nShort explanation of how the project tasks will be divided among the team members.\nWriting is well organized\nNo grammar or spelling issues.\n\n\n\nTechnical\n\nProject uses functionality of microcontroller not previously covered in labs\nProject uses functionality of FPGA not previously covered in labs\nProject uses new non-trivial new hardware (e.g., digital chip with non-trivial interface)\n\n\n\nDocumentation\n\nBill of materials includes part numbers, quantities, and prices for all components. Prices for components available in the stock room should be indicated as “stockroom”.\nBlock diagram of system clearly deliniates all protocols and interfaces.\nBlock diagram is computer drawn and neatly laid out."
  },
  {
    "objectID": "project/final-project-requirements.html",
    "href": "project/final-project-requirements.html",
    "title": "MicroPs Final Project Requirements",
    "section": "",
    "text": "The E155 Final Project is a chance for you to apply your new skills in digital design to a moderately-sized problem as part of a two- or three-person team. You should begin thinking about a project and teammate right away. Your project has the following deliverables.\n\n\n\n\n\n\n\n\nDate\nDeliverable\nNotes\n\n\n\n\n10/27\nProject Proposal\nDue via Canvas\n\n\n10/31 & 11/2\nProposal Debriefs\nDuring lab checkoff times\n\n\n11/7 & 11/9\nPresentations\nDuring class\n\n\n11/16\nMidpoint Report & Demo\nDuring class time and lab slot\n\n\n12/5 & 12/7\nFinal Checkoffs\nDuring lab checkoff times\n\n\n12/7\nFinal Report Website\nDue by end of day\n\n\n12/8 @ 2 pm\nDemo Day\nPublic event to show off projects"
  },
  {
    "objectID": "project/final-project-requirements.html#overview",
    "href": "project/final-project-requirements.html#overview",
    "title": "MicroPs Final Project Requirements",
    "section": "",
    "text": "The E155 Final Project is a chance for you to apply your new skills in digital design to a moderately-sized problem as part of a two- or three-person team. You should begin thinking about a project and teammate right away. Your project has the following deliverables.\n\n\n\n\n\n\n\n\nDate\nDeliverable\nNotes\n\n\n\n\n10/27\nProject Proposal\nDue via Canvas\n\n\n10/31 & 11/2\nProposal Debriefs\nDuring lab checkoff times\n\n\n11/7 & 11/9\nPresentations\nDuring class\n\n\n11/16\nMidpoint Report & Demo\nDuring class time and lab slot\n\n\n12/5 & 12/7\nFinal Checkoffs\nDuring lab checkoff times\n\n\n12/7\nFinal Report Website\nDue by end of day\n\n\n12/8 @ 2 pm\nDemo Day\nPublic event to show off projects"
  },
  {
    "objectID": "project/final-project-requirements.html#project-scope",
    "href": "project/final-project-requirements.html#project-scope",
    "title": "MicroPs Final Project Requirements",
    "section": "Project Scope",
    "text": "Project Scope\nBe creative when selecting your project. Your project should be bigger than a 1-week lab assignment, but small enough to be doable. If in doubt, err on the side of smaller. You will fail the class if you undertake a project that is too big and produce no completed work.\nA successful project will use both the FPGA and MCU and will perform a function that is useful or interesting. You also must use a new piece of hardware in your final project (various sensors or displays are popular choices). You can find examples of past final projects on the class web page. Examples include games, electromechanical systems, prototypes for a startup company, or elements of a Clinic project (with your advisor’s permission)."
  },
  {
    "objectID": "project/final-project-requirements.html#budget",
    "href": "project/final-project-requirements.html#budget",
    "title": "MicroPs Final Project Requirements",
    "section": "Budget",
    "text": "Budget\nIf your team needs parts that are not available in the stockroom, you may spend up to $50 to purchase them. You will need to save your receipts, fill out a reimbursement form available from the department website, and have me approve the reimbursement (list me as the faculty advisor on the form). You may exceed this budget, but you must pay the remainder out of your own pocket."
  },
  {
    "objectID": "project/final-project-requirements.html#deliverables",
    "href": "project/final-project-requirements.html#deliverables",
    "title": "MicroPs Final Project Requirements",
    "section": "Deliverables",
    "text": "Deliverables\nYour team is responsible for the following deliverables at the dates described above:\n\nProject Proposal\nA 2-page proposal describing what you plan to build. It must be specific enough that I can tell when you demonstrate your project that it meets the specs of the proposal. Do not list stretch goals or wiggle words; simply state what you are committing to deliver. You may need to do some preliminary technical work to gain confidence you can deliver what you promise. Include a bill of materials with the parts you expect to need along with prices for any supplies that are not available in the stock room. Describe the main subsystems of the design and the features of the MCU that you plan to use. Explain the new piece(s) of hardware and show that both the FPGA and MCU are performing nontrivial functions appropriate to each. Include a block diagram showing the components and the interfaces between each.\n\n\nMidpoint Report & Demo\nA 4-page report (plus appendices) documenting your design at the midpoint. Your report should be submitted before your scheduled checkpoint slot. The status report should include:\n\nSchematics of anything on a breadboard,\nBlock diagrams of the logic on your FPGA,\nAn outline of the routines used on the MCU.\n\nYou should include as an appendix either your Verilog code or software that is mostly complete (but do not have to have both ready). You must be ready to demonstrate some working hardware in the lab.\n\n\nPresentations\nYour team will sign up for a 10-minute in-class presentation shortly after your proposal debrief. Your presentation should include a 3-minute overview of your project followed by an in-depth presentation of a specific technical problem your team is working on and has not yet solved. The goal of the presentation is to get input from other students who might have ideas of how to solve your problem so you must explain the problem clearly enough to get meaningful suggestions back.\n\n\nProject Demonstration\nDemonstrate a working project to the instructor in the lab. There will be signups for demonstration periods, during which you will show that you meet your specifications and be asked technical questions about the operation of your design. Come prepared with printouts of your schematics, software and Verilog. If your project is one day late, one letter grade will be deducted.\n\n\nFinal Report\nThe final report for this project will be a portfolio website hosted on Github pages. The website should document your design with all source code in the linked Github repository. Clearly explain how your design works. If you have developed techniques that would be useful for students in the future (e.g., how to interface to an LCD display), document these features well so that future students may build on your work.\nThe website should include:\n\nComplete schematics and block diagrams\nWell-commented and cleanly-formatted code (C and Verilog)\nPhotos of your finished design\nA video (hosted in the provided Google Drive folder) demonstrating your project. Any videos should be titled “&lt;LastName1&gt;&lt;LastName2&gt;&lt;VideoName&gt;” to clearly identify your videos in the folder.\n\nLate projects will not be accepted except in the case of unusual extenuating circumstances. Be careful to choose a project within a scope that you can reasonably expect to finish. If you realize your project is too large, contact me as soon as possible to renegotiate your project proposal. I will not accept revisions to the proposal after the Friday following the in-class presentation."
  },
  {
    "objectID": "project/final-project-requirements.html#grading",
    "href": "project/final-project-requirements.html#grading",
    "title": "MicroPs Final Project Requirements",
    "section": "Grading",
    "text": "Grading\nYour project will be graded according to the policy laid out in the syllabus. For reference, that policy can be found here.\nIf you feel there has been inequality between the work you and your teammate deliver, contact me personally."
  },
  {
    "objectID": "project/reports/2022/index.html",
    "href": "project/reports/2022/index.html",
    "title": "Fall 2022",
    "section": "",
    "text": "Title\nTeam Members\nWebsite URL\n\n\nRobotic Slide Whistle\nDeclan O’Neill, Kip Macsai-Goren\nhttps://doneill890.github.io/slide-whistle/\n\n\nAuto Audio Harmonizer\nBrian Simpkins, Kevin Kim\nhttps://briansimpkins.github.io/E155_Final/\n\n\nAnalog Signal Display (Scope)\nTristan Huang, Alexa Wright\nhttps://thuang8.github.io/E155_FA22_Final_Project_TH_AW/\n\n\nGuarded Safe\nLimnanthes Serafini, Noah Limpert\nhttps://magpyed.github.io/E155-FA22-Final-Project/\n\n\nRFID Doorbell\nJoseph Zales, Ava Fascetti\nhttps://joseph-q-zales.github.io/HMC-MicroPs-Final-Portfolio/\n\n\nPinball Machine\nAlessandro Maiuolo, Cristian Gonzalez\nhttps://cristiango23.github.io/E155-FA22-Final-Project/\n\n\nRandom Clock\nRuth Mueller, Kevin Wan\nhttps://koooo-142857.github.io/E155_Random_Clock/\n\n\nPet Autofeeder\nCedar Turek, Manuel Mendoza Manriquez\nhttps://cturek.github.io/E155-Autofeeder/\n\n\nSelf-balancing Robot\nTanvika Dasari, Eric Chen\nhttps://tanvikad.github.io/balance-robot/\n\n\nCrane Game\nMiles Cook, Penny Hernandez\nhttps://mcook26.github.io/Crane-Game/"
  }
]